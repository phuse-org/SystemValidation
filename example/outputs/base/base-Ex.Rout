
R version 4.0.3 (2020-10-10) -- "Bunny-Wunnies Freak Out"
Copyright (C) 2020 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "base"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("Arithmetic")
> ### * Arithmetic
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Arithmetic
> ### Title: Arithmetic Operators
> ### Aliases: + - * ** / ^ %% %/% Arithmetic
> ### Keywords: arith
> 
> ### ** Examples
> 
> x <- -1:12
> x + 1
 [1]  0  1  2  3  4  5  6  7  8  9 10 11 12 13
> 2 * x + 3
 [1]  1  3  5  7  9 11 13 15 17 19 21 23 25 27
> x %% 2 #-- is periodic
 [1] 1 0 1 0 1 0 1 0 1 0 1 0 1 0
> x %/% 5
 [1] -1  0  0  0  0  0  1  1  1  1  1  2  2  2
> x %% Inf # now is defined by limit (gave NaN in earlier versions of R)
 [1] Inf   0   1   2   3   4   5   6   7   8   9  10  11  12
> 
> 
> 
> cleanEx()
> nameEx("Bessel")
> ### * Bessel
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Bessel
> ### Title: Bessel Functions
> ### Aliases: bessel Bessel besselI besselJ besselK besselY
> ### Keywords: math
> 
> ### ** Examples
> 
> require(graphics)
> 
> nus <- c(0:5, 10, 20)
> 
> x <- seq(0, 4, length.out = 501)
> plot(x, x, ylim = c(0, 6), ylab = "", type = "n",
+      main = "Bessel Functions  I_nu(x)")
> for(nu in nus) lines(x, besselI(x, nu = nu), col = nu + 2)
> legend(0, 6, legend = paste("nu=", nus), col = nus + 2, lwd = 1)
> 
> x <- seq(0, 40, length.out = 801); yl <- c(-.5, 1)
> plot(x, x, ylim = yl, ylab = "", type = "n",
+      main = "Bessel Functions  J_nu(x)")
> abline(h=0, v=0, lty=3)
> for(nu in nus) lines(x, besselJ(x, nu = nu), col = nu + 2)
> legend("topright", legend = paste("nu=", nus), col = nus + 2, lwd = 1, bty="n")
> 
> ## Negative nu's --------------------------------------------------
> xx <- 2:7
> nu <- seq(-10, 9, length.out = 2001)
> ## --- I() --- --- --- ---
> matplot(nu, t(outer(xx, nu, besselI)), type = "l", ylim = c(-50, 200),
+         main = expression(paste("Bessel ", I[nu](x), " for fixed ", x,
+                                 ",  as ", f(nu))),
+         xlab = expression(nu))
> abline(v = 0, col = "light gray", lty = 3)
> legend(5, 200, legend = paste("x=", xx), col=seq(xx), lty=1:5)
> 
> ## --- J() --- --- --- ---
> bJ <- t(outer(xx, nu, besselJ))
> matplot(nu, bJ, type = "l", ylim = c(-500, 200),
+         xlab = quote(nu), ylab = quote(J[nu](x)),
+         main = expression(paste("Bessel ", J[nu](x), " for fixed ", x)))
> abline(v = 0, col = "light gray", lty = 3)
> legend("topright", legend = paste("x=", xx), col=seq(xx), lty=1:5)
> 
> ## ZOOM into right part:
> matplot(nu[nu > -2], bJ[nu > -2,], type = "l",
+         xlab = quote(nu), ylab = quote(J[nu](x)),
+         main = expression(paste("Bessel ", J[nu](x), " for fixed ", x)))
> abline(h=0, v = 0, col = "gray60", lty = 3)
> legend("topright", legend = paste("x=", xx), col=seq(xx), lty=1:5)
> 
> 
> ##---------------  x --> 0  -----------------------------
> x0 <- 2^seq(-16, 5, length.out=256)
> plot(range(x0), c(1e-40, 1), log = "xy", xlab = "x", ylab = "", type = "n",
+      main = "Bessel Functions  J_nu(x)  near 0\n log - log  scale") ; axis(2, at=1)
> for(nu in sort(c(nus, nus+0.5)))
+     lines(x0, besselJ(x0, nu = nu), col = nu + 2, lty= 1+ (nu%%1 > 0))
> legend("right", legend = paste("nu=", paste(nus, nus+0.5, sep=", ")),
+        col = nus + 2, lwd = 1, bty="n")
> 
> x0 <- 2^seq(-10, 8, length.out=256)
> plot(range(x0), 10^c(-100, 80), log = "xy", xlab = "x", ylab = "", type = "n",
+      main = "Bessel Functions  K_nu(x)  near 0\n log - log  scale") ; axis(2, at=1)
> for(nu in sort(c(nus, nus+0.5)))
+     lines(x0, besselK(x0, nu = nu), col = nu + 2, lty= 1+ (nu%%1 > 0))
> legend("topright", legend = paste("nu=", paste(nus, nus + 0.5, sep = ", ")),
+        col = nus + 2, lwd = 1, bty="n")
> 
> x <- x[x > 0]
> plot(x, x, ylim = c(1e-18, 1e11), log = "y", ylab = "", type = "n",
+      main = "Bessel Functions  K_nu(x)"); axis(2, at=1)
> for(nu in nus) lines(x, besselK(x, nu = nu), col = nu + 2)
> legend(0, 1e-5, legend=paste("nu=", nus), col = nus + 2, lwd = 1)
> 
> yl <- c(-1.6, .6)
> plot(x, x, ylim = yl, ylab = "", type = "n",
+      main = "Bessel Functions  Y_nu(x)")
> for(nu in nus){
+     xx <- x[x > .6*nu]
+     lines(xx, besselY(xx, nu=nu), col = nu+2)
+ }
> legend(25, -.5, legend = paste("nu=", nus), col = nus+2, lwd = 1)
> 
> ## negative nu in bessel_Y -- was bogus for a long time
> curve(besselY(x, -0.1), 0, 10, ylim = c(-3,1), ylab = "")
> for(nu in c(seq(-0.2, -2, by = -0.1)))
+   curve(besselY(x, nu), add = TRUE)
> title(expression(besselY(x, nu) * "   " *
+                  {nu == list(-0.1, -0.2, ..., -2)}))
> 
> 
> 
> cleanEx()
> nameEx("Colon")
> ### * Colon
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Colon
> ### Title: Colon Operator
> ### Aliases: : colon
> ### Keywords: manip
> 
> ### ** Examples
> 
> 1:4
[1] 1 2 3 4
> pi:6 # real
[1] 3.141593 4.141593 5.141593
> 6:pi # integer
[1] 6 5 4
> 
> f1 <- gl(2, 3); f1
[1] 1 1 1 2 2 2
Levels: 1 2
> f2 <- gl(3, 2); f2
[1] 1 1 2 2 3 3
Levels: 1 2 3
> f1:f2 # a factor, the "cross"  f1 x f2
[1] 1:1 1:1 1:2 2:2 2:3 2:3
Levels: 1:1 1:2 1:3 2:1 2:2 2:3
> 
> 
> 
> cleanEx()
> nameEx("Comparison")
> ### * Comparison
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Comparison
> ### Title: Relational Operators
> ### Aliases: < <= == != >= > Comparison collation
> ### Keywords: logic
> 
> ### ** Examples
> 
> x <- stats::rnorm(20)
> x < 1
 [1]  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE
[13]  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE
> x[x > 0]
 [1] 0.1836433 1.5952808 0.3295078 0.4874291 0.7383247 0.5757814 1.5117812
 [8] 0.3898432 1.1249309 0.9438362 0.8212212 0.5939013
> 
> x1 <- 0.5 - 0.3
> x2 <- 0.3 - 0.1
> x1 == x2                           # FALSE on most machines
[1] FALSE
> identical(all.equal(x1, x2), TRUE) # TRUE everywhere
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("Constants")
> ### * Constants
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Constants
> ### Title: Built-in Constants
> ### Aliases: Constants LETTERS letters month.abb month.name pi
> ### Keywords: sysdata
> 
> ### ** Examples
> 
> ## John Machin (ca 1706) computed pi to over 100 decimal places
> ## using the Taylor series expansion of the second term of
> pi - 4*(4*atan(1/5) - atan(1/239))
[1] -4.440892e-16
> 
> ## months in English
> month.name
 [1] "January"   "February"  "March"     "April"     "May"       "June"     
 [7] "July"      "August"    "September" "October"   "November"  "December" 
> ## months in your current locale
> format(ISOdate(2000, 1:12, 1), "%B")
 [1] "January"   "February"  "March"     "April"     "May"       "June"     
 [7] "July"      "August"    "September" "October"   "November"  "December" 
> format(ISOdate(2000, 1:12, 1), "%b")
 [1] "Jan" "Feb" "Mar" "Apr" "May" "Jun" "Jul" "Aug" "Sep" "Oct" "Nov" "Dec"
> 
> 
> 
> cleanEx()
> nameEx("Control")
> ### * Control
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Control
> ### Title: Control Flow
> ### Aliases: Control if else for in while repeat break next
> ### Keywords: programming iteration logic
> 
> ### ** Examples
> 
> for(i in 1:5) print(1:i)
[1] 1
[1] 1 2
[1] 1 2 3
[1] 1 2 3 4
[1] 1 2 3 4 5
> for(n in c(2,5,10,20,50)) {
+    x <- stats::rnorm(n)
+    cat(n, ": ", sum(x^2), "\n", sep = "")
+ }
2: 0.4261692
5: 4.262527
10: 9.965956
20: 14.54905
50: 41.44845
> f <- factor(sample(letters[1:5], 10, replace = TRUE))
> for(i in unique(f)) print(i)
[1] "a"
[1] "d"
[1] "b"
[1] "c"
[1] "e"
> 
> 
> 
> cleanEx()
> nameEx("Cstack_info")
> ### * Cstack_info
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Cstack_info
> ### Title: Report Information on C Stack Size and Usage
> ### Aliases: Cstack_info
> ### Keywords: utilities
> 
> ### ** Examples
> 
> 
> cleanEx()
> nameEx("DateTimeClasses")
> ### * DateTimeClasses
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: DateTimeClasses
> ### Title: Date-Time Classes
> ### Aliases: DateTimeClasses POSIXct POSIXlt POSIXt print.POSIXct
> ###   print.POSIXlt summary.POSIXct summary.POSIXlt +.POSIXt -.POSIXt
> ###   Ops.POSIXt Math.POSIXt Summary.POSIXct Math.POSIXlt Summary.POSIXlt
> ###   [.POSIXct [<-.POSIXct [[.POSIXct [.POSIXlt [<-.POSIXlt [[.POSIXlt
> ###   [[<-.POSIXlt as.data.frame.POSIXct as.data.frame.POSIXlt
> ###   as.list.POSIXct as.list.POSIXlt .leap.seconds anyNA.POSIXlt
> ###   is.na.POSIXlt c.POSIXct c.POSIXlt as.matrix.POSIXlt length.POSIXlt
> ###   length<-.POSIXct length<-.POSIXlt mean.POSIXct mean.POSIXlt
> ###   str.POSIXt check_tzones duplicated.POSIXlt unique.POSIXlt
> ###   split.POSIXct names.POSIXlt names<-.POSIXlt date-time
> ### Keywords: utilities chron
> 
> ### ** Examples
> 
> ## look at *internal* representation of "POSIXlt" :
> leapS <- as.POSIXlt(.leap.seconds)
> names(leapS) ; is.list(leapS)
NULL
[1] TRUE
> ## str() "too smart" -->  need unclass(.):
> utils::str(unclass(leapS), vec.len = 7)
List of 11
 $ sec   : num [1:27] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ...
 $ min   : int [1:27] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ...
 $ hour  : int [1:27] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ...
 $ mday  : int [1:27] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ...
 $ mon   : int [1:27] 6 0 0 0 0 0 0 0 0 6 6 6 6 0 0 0 6 6 ...
 $ year  : int [1:27] 72 73 74 75 76 77 78 79 80 81 82 83 85 88 90 91 92 93 ...
 $ wday  : int [1:27] 6 1 2 3 4 6 0 1 2 3 4 5 1 5 1 2 3 4 ...
 $ yday  : int [1:27] 182 0 0 0 0 0 0 0 0 181 181 181 181 0 0 0 182 181 ...
 $ isdst : int [1:27] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ...
 $ zone  : chr [1:27] "UTC" "UTC" "UTC" "UTC" "UTC" "UTC" "UTC" ...
 $ gmtoff: int [1:27] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ...
 - attr(*, "tzone")= chr [1:3] "Etc/UTC" "UTC" "UTC"
> ## Extracting *single* components of POSIXlt objects:
> leapS[1 : 5, "year"]
[1] 72 73 74 75 76
> 
> ##  length(.) <- n   now works for "POSIXct" and "POSIXlt" :
> for(lpS in list(.leap.seconds, leapS)) {
+     ls <- lpS; length(ls) <- 12
+     l2 <- lpS; length(l2) <- 5 + length(lpS)
+     stopifnot(exprs = {
+       ## length(.) <- * is compatible to subsetting/indexing:
+       identical(ls, lpS[seq_along(ls)])
+       identical(l2, lpS[seq_along(l2)])
+       ## has filled with NA's
+       is.na(l2[(length(lpS)+1):length(l2)])
+     })
+ }
> 
> 
> 
> cleanEx()
> nameEx("Dates")
> ### * Dates
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Dates
> ### Title: Date Class
> ### Aliases: Date Dates print.Date summary.Date Math.Date Summary.Date
> ###   [.Date [<-.Date length<-.Date [[.Date as.data.frame.Date as.list.Date
> ###   c.Date mean.Date split.Date
> ### Keywords: utilities chron
> 
> ### ** Examples
> (Dls <- as.Date(.leap.seconds))
 [1] "1972-07-01" "1973-01-01" "1974-01-01" "1975-01-01" "1976-01-01"
 [6] "1977-01-01" "1978-01-01" "1979-01-01" "1980-01-01" "1981-07-01"
[11] "1982-07-01" "1983-07-01" "1985-07-01" "1988-01-01" "1990-01-01"
[16] "1991-01-01" "1992-07-01" "1993-07-01" "1994-07-01" "1996-01-01"
[21] "1997-07-01" "1999-01-01" "2006-01-01" "2009-01-01" "2012-07-01"
[26] "2015-07-01" "2017-01-01"
> 
> ##  length(<Date>) <- n   now works
> ls <- Dls; length(ls) <- 12
> l2 <- Dls; length(l2) <- 5 + length(Dls)
> stopifnot(exprs = {
+   ## length(.) <- * is compatible to subsetting/indexing:
+   identical(ls, Dls[seq_along(ls)])
+   identical(l2, Dls[seq_along(l2)])
+   ## has filled with NA's
+   is.na(l2[(length(Dls)+1):length(l2)])
+ })
> 
> 
> 
> cleanEx()
> nameEx("Encoding")
> ### * Encoding
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Encoding
> ### Title: Read or Set the Declared Encodings for a Character Vector
> ### Aliases: Encoding Encoding<- enc2native enc2utf8
> ### Keywords: utilities character
> 
> ### ** Examples
> 
> ## x is intended to be in latin1
> x <- "fa\xE7ile"
> Encoding(x)
[1] "unknown"
> Encoding(x) <- "latin1"
> x
[1] "façile"
> xx <- iconv(x, "latin1", "UTF-8")
> Encoding(c(x, xx))
[1] "latin1" "UTF-8" 
> c(x, xx)
[1] "façile" "façile"
> Encoding(xx) <- "bytes"
> xx # will be encoded in hex
[1] "fa\\xc3\\xa7ile"
> cat("xx = ", xx, "\n", sep = "")
xx = fa\xc3\xa7ile
> 
> 
> 
> cleanEx()
> nameEx("Extract")
> ### * Extract
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Extract
> ### Title: Extract or Replace Parts of an Object
> ### Aliases: Extract Subscript [ [.listof [.simple.list [.Dlist [[ $
> ###   getElement [<- [[<- $<-
> ### Keywords: array list
> 
> ### ** Examples
> 
> x <- 1:12
> m <- matrix(1:6, nrow = 2, dimnames = list(c("a", "b"), LETTERS[1:3]))
> li <- list(pi = pi, e = exp(1))
> x[10]                 # the tenth element of x
[1] 10
> x <- x[-1]            # delete the 1st element of x
> m[1,]                 # the first row of matrix m
A B C 
1 3 5 
> m[1, , drop = FALSE]  # is a 1-row matrix
  A B C
a 1 3 5
> m[,c(TRUE,FALSE,TRUE)]# logical indexing
  A C
a 1 5
b 2 6
> m[cbind(c(1,2,1),3:1)]# matrix numeric index
[1] 5 4 1
> ci <- cbind(c("a", "b", "a"), c("A", "C", "B"))
> m[ci]                 # matrix character index
[1] 1 6 3
> m <- m[,-1]           # delete the first column of m
> li[[1]]               # the first element of list li
[1] 3.141593
> y <- list(1, 2, a = 4, 5)
> y[c(3, 4)]            # a list containing elements 3 and 4 of y
$a
[1] 4

[[2]]
[1] 5

> y$a                   # the element of y named a
[1] 4
> 
> ## non-integer indices are truncated:
> (i <- 3.999999999) # "4" is printed
[1] 4
> (1:5)[i]  # 3
[1] 3
> 
> ## named atomic vectors, compare "[" and "[[" :
> nx <- c(Abc = 123, pi = pi)
> nx[1] ; nx["pi"] # keeps names, whereas "[[" does not:
Abc 
123 
      pi 
3.141593 
> nx[[1]] ; nx[["pi"]]
[1] 123
[1] 3.141593
> ## Don't show: 
> stopifnot(identical(names(nx[1]), "Abc"),
+         identical(names(nx["pi"]), "pi"),
+         is.null(names(nx[["Abc"]])), is.null(names(nx[[2]])))
> ## End(Don't show)
> ## recursive indexing into lists
> z <- list(a = list(b = 9, c = "hello"), d = 1:5)
> unlist(z)
    a.b     a.c      d1      d2      d3      d4      d5 
    "9" "hello"     "1"     "2"     "3"     "4"     "5" 
> z[[c(1, 2)]]
[1] "hello"
> z[[c(1, 2, 1)]]  # both "hello"
[1] "hello"
> z[[c("a", "b")]] <- "new"
> unlist(z)
    a.b     a.c      d1      d2      d3      d4      d5 
  "new" "hello"     "1"     "2"     "3"     "4"     "5" 
> 
> ## check $ and [[ for environments
> e1 <- new.env()
> e1$a <- 10
> e1[["a"]]
[1] 10
> e1[["b"]] <- 20
> e1$b
[1] 20
> ls(e1)
[1] "a" "b"
> 
> ## partial matching - possibly with warning :
> stopifnot(identical(li$p, pi))
> op <- options(warnPartialMatchDollar = TRUE)
> stopifnot( identical(li$p, pi), #-- a warning
+   inherits(tryCatch (li$p, warning = identity), "warning"))
Warning in li$p : partial match of 'p' to 'pi'
> ## revert the warning option:
> if(is.null(op[[1]])) op[[1]] <- FALSE; options(op)
> 
> 
> 
> cleanEx()
> nameEx("Extract.data.frame")
> ### * Extract.data.frame
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Extract.data.frame
> ### Title: Extract or Replace Parts of a Data Frame
> ### Aliases: [.data.frame [[.data.frame [<-.data.frame [[<-.data.frame
> ###   $<-.data.frame
> ### Keywords: array
> 
> ### ** Examples
> 
> sw <- swiss[1:5, 1:4]  # select a manageable subset
> 
> sw[1:3]      # select columns
             Fertility Agriculture Examination
Courtelary        80.2        17.0          15
Delemont          83.1        45.1           6
Franches-Mnt      92.5        39.7           5
Moutier           85.8        36.5          12
Neuveville        76.9        43.5          17
> sw[, 1:3]    # same
             Fertility Agriculture Examination
Courtelary        80.2        17.0          15
Delemont          83.1        45.1           6
Franches-Mnt      92.5        39.7           5
Moutier           85.8        36.5          12
Neuveville        76.9        43.5          17
> sw[4:5, 1:3] # select rows and columns
           Fertility Agriculture Examination
Moutier         85.8        36.5          12
Neuveville      76.9        43.5          17
> sw[1]        # a one-column data frame
             Fertility
Courtelary        80.2
Delemont          83.1
Franches-Mnt      92.5
Moutier           85.8
Neuveville        76.9
> sw[, 1, drop = FALSE]  # the same
             Fertility
Courtelary        80.2
Delemont          83.1
Franches-Mnt      92.5
Moutier           85.8
Neuveville        76.9
> sw[, 1]      # a (unnamed) vector
[1] 80.2 83.1 92.5 85.8 76.9
> sw[[1]]      # the same
[1] 80.2 83.1 92.5 85.8 76.9
> sw$Fert      # the same (possibly w/ warning, see ?Extract)
[1] 80.2 83.1 92.5 85.8 76.9
> 
> sw[1,]       # a one-row data frame
           Fertility Agriculture Examination Education
Courtelary      80.2          17          15        12
> sw[1,, drop = TRUE]  # a list
$Fertility
[1] 80.2

$Agriculture
[1] 17

$Examination
[1] 15

$Education
[1] 12

> 
> sw["C", ] # partially matches
           Fertility Agriculture Examination Education
Courtelary      80.2          17          15        12
> sw[match("C", row.names(sw)), ] # no exact match
   Fertility Agriculture Examination Education
NA        NA          NA          NA        NA
> try(sw[, "Ferti"]) # column names must match exactly
Error in `[.data.frame`(sw, , "Ferti") : undefined columns selected
> 
> ## Don't show: 
> stopifnot(identical(sw[, 1], sw[[1]]),
+           identical(sw[, 1][1], 80.2),
+           identical(sw[, 1, drop = FALSE], sw[1]),
+           is.data.frame(sw[1 ]), dim(sw[1 ]) == c(5, 1),
+           is.data.frame(sw[1,]), dim(sw[1,]) == c(1, 4),
+           is.list(s1 <- sw[1, , drop = TRUE]), identical(s1$Fertility, 80.2))
> tools::assertError(sw[, "Ferti"])
> ## End(Don't show)
> swiss[ c(1, 1:2), ]   # duplicate row, unique row names are created
             Fertility Agriculture Examination Education Catholic
Courtelary        80.2        17.0          15        12     9.96
Courtelary.1      80.2        17.0          15        12     9.96
Delemont          83.1        45.1           6         9    84.84
             Infant.Mortality
Courtelary               22.2
Courtelary.1             22.2
Delemont                 22.2
> 
> sw[sw <= 6] <- 6  # logical matrix indexing
> sw
             Fertility Agriculture Examination Education
Courtelary        80.2        17.0          15        12
Delemont          83.1        45.1           6         9
Franches-Mnt      92.5        39.7           6         6
Moutier           85.8        36.5          12         7
Neuveville        76.9        43.5          17        15
> 
> ## adding a column
> sw["new1"] <- LETTERS[1:5]   # adds a character column
> sw[["new2"]] <- letters[1:5] # ditto
> sw[, "new3"] <- LETTERS[1:5] # ditto
> sw$new4 <- 1:5
> sapply(sw, class)
  Fertility Agriculture Examination   Education        new1        new2 
  "numeric"   "numeric"   "numeric"   "numeric" "character" "character" 
       new3        new4 
"character"   "integer" 
> sw$new  # -> NULL: no unique partial match
NULL
> sw$new4 <- NULL              # delete the column
> sw
             Fertility Agriculture Examination Education new1 new2 new3
Courtelary        80.2        17.0          15        12    A    a    A
Delemont          83.1        45.1           6         9    B    b    B
Franches-Mnt      92.5        39.7           6         6    C    c    C
Moutier           85.8        36.5          12         7    D    d    D
Neuveville        76.9        43.5          17        15    E    e    E
> sw[6:8] <- list(letters[10:14], NULL, aa = 1:5)
> # update col. 6, delete 7, append
> sw
             Fertility Agriculture Examination Education new1 new2 aa
Courtelary        80.2        17.0          15        12    A    j  1
Delemont          83.1        45.1           6         9    B    k  2
Franches-Mnt      92.5        39.7           6         6    C    l  3
Moutier           85.8        36.5          12         7    D    m  4
Neuveville        76.9        43.5          17        15    E    n  5
> 
> ## matrices in a data frame
> A <- data.frame(x = 1:3, y = I(matrix(4:9, 3, 2)),
+                          z = I(matrix(letters[1:9], 3, 3)))
> A[1:3, "y"] # a matrix
     [,1] [,2]
[1,]    4    7
[2,]    5    8
[3,]    6    9
> A[1:3, "z"] # a matrix
     [,1] [,2] [,3]
[1,] "a"  "d"  "g" 
[2,] "b"  "e"  "h" 
[3,] "c"  "f"  "i" 
> A[, "y"]    # a matrix
     [,1] [,2]
[1,]    4    7
[2,]    5    8
[3,]    6    9
> stopifnot(identical(colnames(A), c("x", "y", "z")), ncol(A) == 3L,
+           identical(A[,"y"], A[1:3, "y"]),
+           inherits (A[,"y"], "AsIs"))
> 
> ## keeping special attributes: use a class with a
> ## "as.data.frame" and "[" method;
> ## "avector" := vector that keeps attributes.   Could provide a constructor
> ##  avector <- function(x) { class(x) <- c("avector", class(x)); x }
> as.data.frame.avector <- as.data.frame.vector
> 
> `[.avector` <- function(x,i,...) {
+   r <- NextMethod("[")
+   mostattributes(r) <- attributes(x)
+   r
+ }
> 
> d <- data.frame(i = 0:7, f = gl(2,4),
+                 u = structure(11:18, unit = "kg", class = "avector"))
> str(d[2:4, -1]) # 'u' keeps its "unit"
'data.frame':	3 obs. of  2 variables:
 $ f: Factor w/ 2 levels "1","2": 1 1 1
 $ u: 'avector' int  12 13 14
  ..- attr(*, "unit")= chr "kg"
> ## Don't show: 
> stopifnot(identical(d[2:4,-1][,"u"],
+                     structure(12:14, unit = "kg", class = "avector")))
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("Extract.factor")
> ### * Extract.factor
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Extract.factor
> ### Title: Extract or Replace Parts of a Factor
> ### Aliases: [.factor [<-.factor [[.factor [[<-.factor
> ### Keywords: category
> 
> ### ** Examples
> 
> ## following example(factor)
> (ff <- factor(substring("statistics", 1:10, 1:10), levels = letters))
 [1] s t a t i s t i c s
Levels: a b c d e f g h i j k l m n o p q r s t u v w x y z
> ff[, drop = TRUE]
 [1] s t a t i s t i c s
Levels: a c i s t
> factor(letters[7:10])[2:3, drop = TRUE]
[1] h i
Levels: h i
> 
> 
> 
> cleanEx()
> nameEx("Extremes")
> ### * Extremes
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Extremes
> ### Title: Maxima and Minima
> ### Aliases: max min pmax pmin pmax.int pmin.int
> ### Keywords: univar arith
> 
> ### ** Examples
> 
> require(stats); require(graphics)
>  min(5:1, pi) #-> one number
[1] 1
> pmin(5:1, pi) #->  5  numbers
[1] 3.141593 3.141593 3.000000 2.000000 1.000000
> 
> x <- sort(rnorm(100));  cH <- 1.35
> pmin(cH, quantile(x)) # no names
[1] -2.2146999 -0.4942425  0.1139092  0.6915454  1.3500000
> pmin(quantile(x), cH) # has names
        0%        25%        50%        75%       100% 
-2.2146999 -0.4942425  0.1139092  0.6915454  1.3500000 
> plot(x, pmin(cH, pmax(-cH, x)), type = "b", main =  "Huber's function")
> 
> cut01 <- function(x) pmax(pmin(x, 1), 0)
> curve(      x^2 - 1/4, -1.4, 1.5, col = 2)
> curve(cut01(x^2 - 1/4), col = "blue", add = TRUE, n = 500)
> ## pmax(), pmin() preserve attributes of *first* argument
> D <- diag(x = (3:1)/4) ; n0 <- numeric()
> stopifnot(identical(D,  cut01(D) ),
+           identical(n0, cut01(n0)),
+           identical(n0, cut01(NULL)),
+           identical(n0, pmax(3:1, n0, 2)),
+           identical(n0, pmax(n0, 4)))
> 
> 
> 
> cleanEx()
> nameEx("La_library")
> ### * La_library
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: La_library
> ### Title: LAPACK Library
> ### Aliases: La_library
> ### Keywords: utilities
> 
> ### ** Examples
> 
> La_library()
[1] "/usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.8.so"
> 
> 
> 
> cleanEx()
> nameEx("La_version")
> ### * La_version
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: La_version
> ### Title: LAPACK Version
> ### Aliases: La_version
> ### Keywords: utilities
> 
> ### ** Examples
> 
> La_version()
[1] "3.9.0"
> 
> 
> 
> cleanEx()
> nameEx("Last.value")
> ### * Last.value
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Last.value
> ### Title: Value of Last Evaluated Expression
> ### Aliases: .Last.value
> ### Keywords: programming
> 
> ### ** Examples
> 
> ## These will not work correctly from example(),
> ## but they will in make check or if pasted in,
> ## as example() does not run them at the top level
> gamma(1:15)          # think of some intensive calculation...
 [1]           1           1           2           6          24         120
 [7]         720        5040       40320      362880     3628800    39916800
[13]   479001600  6227020800 87178291200
> fac14 <- .Last.value # keep them
> 
> library("splines") # returns invisibly
> .Last.value    # shows what library(.) above returned
[1] "splines"   "stats"     "graphics"  "grDevices" "utils"     "datasets" 
[7] "methods"   "base"     
> ## Don't show: 
> detach("package:splines")
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("Log")
> ### * Log
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: log
> ### Title: Logarithms and Exponentials
> ### Aliases: log logb log10 log2 log1p exp expm1
> ### Keywords: math
> 
> ### ** Examples
> 
> log(exp(3))
[1] 3
> log10(1e7) # = 7
[1] 7
> 
> x <- 10^-(1+2*1:9)
> cbind(x, log(1+x), log1p(x), exp(x)-1, expm1(x))
          x                                                    
 [1,] 1e-03 9.995003e-04 9.995003e-04 1.000500e-03 1.000500e-03
 [2,] 1e-05 9.999950e-06 9.999950e-06 1.000005e-05 1.000005e-05
 [3,] 1e-07 1.000000e-07 1.000000e-07 1.000000e-07 1.000000e-07
 [4,] 1e-09 1.000000e-09 1.000000e-09 1.000000e-09 1.000000e-09
 [5,] 1e-11 1.000000e-11 1.000000e-11 1.000000e-11 1.000000e-11
 [6,] 1e-13 9.992007e-14 1.000000e-13 9.992007e-14 1.000000e-13
 [7,] 1e-15 1.110223e-15 1.000000e-15 1.110223e-15 1.000000e-15
 [8,] 1e-17 0.000000e+00 1.000000e-17 0.000000e+00 1.000000e-17
 [9,] 1e-19 0.000000e+00 1.000000e-19 0.000000e+00 1.000000e-19
> 
> 
> 
> cleanEx()
> nameEx("Logic")
> ### * Logic
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Logic
> ### Title: Logical Operators
> ### Aliases: ! & && | || xor Logic isTRUE isFALSE
> ### Keywords: logic
> 
> ### ** Examples
> 
> y <- 1 + (x <- stats::rpois(50, lambda = 1.5) / 4 - 1)
> x[(x > 0) & (x < 1)]    # all x values between 0 and 1
[1] 0.25
> if (any(x == 0) || any(y == 0)) "zero encountered"
[1] "zero encountered"
> 
> ## construct truth tables :
> 
> x <- c(NA, FALSE, TRUE)
> names(x) <- as.character(x)
> outer(x, x, "&") ## AND table
       <NA> FALSE  TRUE
<NA>     NA FALSE    NA
FALSE FALSE FALSE FALSE
TRUE     NA FALSE  TRUE
> outer(x, x, "|") ## OR  table
      <NA> FALSE TRUE
<NA>    NA    NA TRUE
FALSE   NA FALSE TRUE
TRUE  TRUE  TRUE TRUE
> 
> 
> 
> cleanEx()
> nameEx("MathFun")
> ### * MathFun
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: MathFun
> ### Title: Miscellaneous Mathematical Functions
> ### Aliases: abs sqrt
> ### Keywords: math
> 
> ### ** Examples
> 
> require(stats) # for spline
> require(graphics)
> xx <- -9:9
> plot(xx, sqrt(abs(xx)),  col = "red")
> lines(spline(xx, sqrt(abs(xx)), n=101), col = "pink")
> 
> 
> 
> cleanEx()
> nameEx("NA")
> ### * NA
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: NA
> ### Title: 'Not Available' / Missing Values
> ### Aliases: NA NA_integer_ NA_real_ NA_complex_ NA_character_ is.na
> ###   is.na.data.frame is.na<- is.na<-.default anyNA anyNA.data.frame
> ###   anyMissing
> ### Keywords: NA logic manip
> 
> ### ** Examples
> 
> is.na(c(1, NA))        #> FALSE  TRUE
[1] FALSE  TRUE
> is.na(paste(c(1, NA))) #> FALSE FALSE
[1] FALSE FALSE
> 
> (xx <- c(0:4))
[1] 0 1 2 3 4
> is.na(xx) <- c(2, 4)
> xx                     #> 0 NA  2 NA  4
[1]  0 NA  2 NA  4
> anyNA(xx) # TRUE
[1] TRUE
> 
> # Some logical operations do not return NA
> c(TRUE, FALSE) & NA
[1]    NA FALSE
> c(TRUE, FALSE) | NA
[1] TRUE   NA
> 
> 
> ## anyNA() can work recursively with list()s:
> LL <- list(1:5, c(NA, 5:8), c("A","NA"), c("a", NA_character_))
> L2 <- LL[c(1,3)]
> sapply(LL, anyNA); c(anyNA(LL), anyNA(LL, TRUE))
[1] FALSE  TRUE FALSE  TRUE
[1] FALSE  TRUE
> sapply(L2, anyNA); c(anyNA(L2), anyNA(L2, TRUE))
[1] FALSE FALSE
[1] FALSE FALSE
> 
> ## ... lists, and hence data frames, too:
> dN <- dd <- USJudgeRatings; dN[3,6] <- NA
> anyNA(dd) # FALSE
[1] FALSE
> anyNA(dN) # TRUE
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("NULL")
> ### * NULL
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: NULL
> ### Title: The Null Object
> ### Aliases: NULL as.null as.null.default is.null
> ### Keywords: attribute manip list sysdata
> 
> ### ** Examples
> 
> is.null(list())     # FALSE (on purpose!)
[1] FALSE
> is.null(pairlist()) # TRUE
[1] TRUE
> is.null(integer(0)) # FALSE
[1] FALSE
> is.null(logical(0)) # FALSE
[1] FALSE
> as.null(list(a = 1, b = "c"))
NULL
> 
> 
> 
> cleanEx()
> nameEx("NumericConstants")
> ### * NumericConstants
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: NumericConstants
> ### Title: Numeric Constants
> ### Aliases: NumericConstants 1L 0x1 1i
> ### Keywords: documentation
> 
> ### ** Examples
> 
> ## You can create numbers using fixed or scientific formatting.
> 2.1
[1] 2.1
> 2.1e10
[1] 2.1e+10
> -2.1E-10
[1] -2.1e-10
> 
> ## The resulting objects have class numeric and type double.
> class(2.1)
[1] "numeric"
> typeof(2.1)
[1] "double"
> 
> ## This holds even if what you typed looked like an integer.
> class(2)
[1] "numeric"
> typeof(2)
[1] "double"
> 
> ## If you actually wanted integers, use an "L" suffix.
> class(2L)
[1] "integer"
> typeof(2L)
[1] "integer"
> 
> ## These are equal but not identical
> 2 == 2L
[1] TRUE
> identical(2, 2L)
[1] FALSE
> 
> ## You can write numbers between 0 and 1 without a leading "0"
> ## (but typically this makes code harder to read)
> .1234
[1] 0.1234
> 
> sqrt(1i) # remember elementary math?
[1] 0.7071068+0.7071068i
> utils::str(0xA0)
 num 160
> identical(1L, as.integer(1))
[1] TRUE
> 
> ## You can combine the "0x" prefix with the "L" suffix :
> identical(0xFL, as.integer(15))
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("Ops.Date")
> ### * Ops.Date
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Ops.Date
> ### Title: Operators on the Date Class
> ### Aliases: +.Date -.Date Ops.Date
> ### Keywords: utilities chron
> 
> ### ** Examples
> 
> 
> cleanEx()
> nameEx("Paren")
> ### * Paren
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Paren
> ### Title: Parentheses and Braces
> ### Aliases: Paren ( {
> ### Keywords: programming
> 
> ### ** Examples
> 
> f <- get("(")
> e <- expression(3 + 2 * 4)
> identical(f(e), e)
[1] TRUE
> 
> do <- get("{")
> do(x <- 3, y <- 2*x-3, 6-x-y); x; y
[1] 0
[1] 3
[1] 3
> 
> ## note the differences
> (2+3)
[1] 5
> {2+3; 4+5}
[1] 9
> (invisible(2+3))
[1] 5
> {invisible(2+3)}
> 
> 
> 
> cleanEx()
> nameEx("Platform")
> ### * Platform
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: .Platform
> ### Title: Platform Specific Variables
> ### Aliases: .Platform
> ### Keywords: file utilities
> 
> ### ** Examples
> 
> ## Note: this can be done in a system-independent way by dir.exists()
> if(.Platform$OS.type == "unix") {
+    system.test <- function(...) system(paste("test", ...)) == 0L
+    dir.exists2 <- function(dir)
+        sapply(dir, function(d) system.test("-d", d))
+    dir.exists2(c(R.home(), "/tmp", "~", "/NO")) # > T T T F
+ }
/usr/local/lib/R             /tmp                ~              /NO 
            TRUE             TRUE             TRUE            FALSE 
> 
> 
> 
> cleanEx()
> nameEx("Primitive")
> ### * Primitive
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Primitive
> ### Title: Look Up a Primitive Function
> ### Aliases: .Primitive primitive
> ### Keywords: interface
> 
> ### ** Examples
> 
> mysqrt <- .Primitive("sqrt")
> c
function (...)  .Primitive("c")
> .Internal # this one *must* be primitive!
function (call)  .Primitive(".Internal")
> `if` # need backticks
.Primitive("if")
> 
> 
> 
> cleanEx()
> nameEx("Quotes")
> ### * Quotes
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Quotes
> ### Title: Quotes
> ### Aliases: Quotes backtick backquote ' " `
> ### Keywords: documentation
> 
> ### ** Examples
> 
> 'single quotes can be used more-or-less interchangeably'
[1] "single quotes can be used more-or-less interchangeably"
> "with double quotes to create character vectors"
[1] "with double quotes to create character vectors"
> 
> ## Single quotes inside single-quoted strings need backslash-escaping.
> ## Ditto double quotes inside double-quoted strings.
> ##
> identical('"It\'s alive!", he screamed.',
+           "\"It's alive!\", he screamed.") # same
[1] TRUE
> 
> ## Backslashes need doubling, or they have a special meaning.
> x <- "In ALGOL, you could do logical AND with /\\."
> print(x)      # shows it as above ("input-like")
[1] "In ALGOL, you could do logical AND with /\\."
> writeLines(x) # shows it as you like it ;-)
In ALGOL, you could do logical AND with /\.
> 
> ## Single backslashes followed by a letter are used to denote
> ## special characters like tab(ulator)s and newlines:
> x <- "long\tlines can be\nbroken with newlines"
> writeLines(x) # see also ?strwrap
long	lines can be
broken with newlines
> 
> ## Backticks are used for non-standard variable names.
> ## (See make.names and ?Reserved for what counts as
> ## non-standard.)
> `x y` <- 1:5
> `x y`
[1] 1 2 3 4 5
> d <- data.frame(`1st column` = rchisq(5, 2), check.names = FALSE)
> d$`1st column`
[1] 0.3102827 3.7648032 3.6090250 1.6723553 2.4450873
> 
> ## Backslashes followed by up to three numbers are interpreted as
> ## octal notation for ASCII characters.
> "\110\145\154\154\157\40\127\157\162\154\144\41"
[1] "Hello World!"
> 
> ## \x followed by up to two numbers is interpreted as
> ## hexadecimal notation for ASCII characters.
> (hw1 <- "\x48\x65\x6c\x6c\x6f\x20\x57\x6f\x72\x6c\x64\x21")
[1] "Hello World!"
> 
> ## Mixing octal and hexadecimal in the same string is OK
> (hw2 <- "\110\x65\154\x6c\157\x20\127\x6f\162\x6c\144\x21")
[1] "Hello World!"
> 
> ## \u is also hexadecimal, but supported up to 4 numbers,
> ## using Unicode specification.  In the previous example,
> ## you can simply replace \x with \u.
> (hw3 <- "\u48\u65\u6c\u6c\u6f\u20\u57\u6f\u72\u6c\u64\u21")
[1] "Hello World!"
> 
> ## The last three are all identical to
> hw <- "Hello World!"
> stopifnot(identical(hw, hw1), identical(hw1, hw2), identical(hw2, hw3))
> 
> ## Using Unicode makes more sense for non-latin characters.
> (nn <- "\u0126\u0119\u1114\u022d\u2001\u03e2\u0954\u0f3f\u13d3\u147b\u203c")
[1] "Ħęᄔȭ Ϣ॔༿Ꮣᑻ‼"
> 
> ## Mixing \x and \u throws a _parse_ error (which is not catchable!)
> ## Not run: 
> ##D   "\x48\u65\x6c\u6c\x6f\u20\x57\u6f\x72\u6c\x64\u21"
> ## End(Not run)
> ##   -->   Error: mixing Unicode and octal/hex escapes .....
> 
> ## \U works like \u, but supports up to eight numbers.
> ## So we can replace \u with \U in the previous example.
> n2 <- "\U0126\U0119\U1114\U022d\U2001\U03e2\U0954\U0f3f\U13d3\U147b\U203c"
> stopifnot(identical(nn, n2))
> 
> ## Under systems supporting multi-byte locales (and not Windows),
> ## \U also supports the rarer characters outside the usual 16^4 range.
> ## See the R language manual,
> ## https://cran.r-project.org/doc/manuals/r-release/R-lang.html#Literal-constants
> ## and bug 16098 https://bugs.r-project.org/bugzilla3/show_bug.cgi?id=16098
> "\U1d4d7" # On Windows this gives the incorrect value of "\Ud4d7"
[1] "𝓗"
> 
> ## nul characters (for terminating strings in C) are not allowed (parse errors)
> ## Not run: ##D 
> ##D   "foo\0bar"     # Error: nul character not allowed (line 1)
> ##D   "foo\u0000bar" # same error
> ## End(Not run)
> 
> ## A Windows path written as a raw string constant:
> r"(c:\Program files\R)"
[1] "c:\\Program files\\R"
> 
> ## More raw strings:
> r"{(\1\2)}"
[1] "(\\1\\2)"
> r"(use both "double" and 'single' quotes)"
[1] "use both \"double\" and 'single' quotes"
> r"---(\1--)-)---"
[1] "\\1--)-"
> 
> 
> 
> cleanEx()
> nameEx("Random-user")
> ### * Random-user
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Random.user
> ### Title: User-supplied Random Number Generation
> ### Aliases: Random.user
> ### Keywords: distribution sysdata
> 
> ### ** Examples
> ## Not run: 
> ##D ##  Marsaglia's congruential PRNG
> ##D #include <R_ext/Random.h>
> ##D 
> ##D static Int32 seed;
> ##D static double res;
> ##D static int nseed = 1;
> ##D 
> ##D double * user_unif_rand()
> ##D {
> ##D     seed = 69069 * seed + 1;
> ##D     res = seed * 2.32830643653869e-10;
> ##D     return &res;
> ##D }
> ##D 
> ##D void  user_unif_init(Int32 seed_in) { seed = seed_in; }
> ##D int * user_unif_nseed() { return &nseed; }
> ##D int * user_unif_seedloc() { return (int *) &seed; }
> ##D 
> ##D /*  ratio-of-uniforms for normal  */
> ##D #include <math.h>
> ##D static double x;
> ##D 
> ##D double * user_norm_rand()
> ##D {
> ##D     double u, v, z;
> ##D     do {
> ##D         u = unif_rand();
> ##D         v = 0.857764 * (2. * unif_rand() - 1);
> ##D         x = v/u; z = 0.25 * x * x;
> ##D         if (z < 1. - u) break;
> ##D         if (z > 0.259/u + 0.35) continue;
> ##D     } while (z > -log(u));
> ##D     return &x;
> ##D }
> ##D 
> ##D ## Use under Unix:
> ##D R CMD SHLIB urand.c
> ##D R
> ##D > dyn.load("urand.so")
> ##D > RNGkind("user")
> ##D > runif(10)
> ##D > .Random.seed
> ##D > RNGkind(, "user")
> ##D > rnorm(10)
> ##D > RNGkind()
> ##D [1] "user-supplied" "user-supplied"
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("Random")
> ### * Random
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Random
> ### Title: Random Number Generation
> ### Aliases: Random RNG RNGkind RNGversion set.seed .Random.seed
> ### Keywords: distribution sysdata
> 
> ### ** Examples
> 
> require(stats)
> 
> ## Seed the current RNG, i.e., set the RNG status
> set.seed(42); u1 <- runif(30)
> set.seed(42); u2 <- runif(30) # the same because of identical RNG status:
> stopifnot(identical(u1, u2))
> 
> ok <- RNGkind()
> RNGkind("Wich")  # (partial string matching on 'kind')
> 
> ## This shows how 'runif(.)' works for Wichmann-Hill,
> ## using only R functions:
> 
> p.WH <- c(30269, 30307, 30323)
> a.WH <- c(  171,   172,   170)
> next.WHseed <- function(i.seed = .Random.seed[-1])
+   { (a.WH * i.seed) %% p.WH }
> my.runif1 <- function(i.seed = .Random.seed)
+   { ns <- next.WHseed(i.seed[-1]); sum(ns / p.WH) %% 1 }
> set.seed(1998-12-04)# (when the next lines were added to the souRce)
> rs <- .Random.seed
> (WHs <- next.WHseed(rs[-1]))
[1] 16476 24419 11857
> u <- runif(1)
> stopifnot(
+  next.WHseed(rs[-1]) == .Random.seed[-1],
+  all.equal(u, my.runif1(rs))
+ )
> 
> ## ----
> .Random.seed
[1] 10400 16476 24419 11857
> RNGkind("Super") # matches  "Super-Duper"
> RNGkind()
[1] "Super-Duper" "Inversion"   "Rejection"  
> .Random.seed # new, corresponding to  Super-Duper
[1]      10402   47619480 -915084615
> 
> ## Reset:
> RNGkind(ok[1])
> 
> RNGversion(getRversion()) # the default version for this R version
> 
> ## ----
> sum(duplicated(runif(1e6))) # around 110 for default generator
[1] 103
> ## and we would expect about almost sure duplicates beyond about
> qbirthday(1 - 1e-6, classes = 2e9) # 235,000
[1] 235075
> 
> 
> 
> cleanEx()
> nameEx("Recall")
> ### * Recall
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Recall
> ### Title: Recursive Calling
> ### Aliases: Recall
> ### Keywords: programming
> 
> ### ** Examples
> 
> ## A trivial (but inefficient!) example:
> fib <- function(n)
+    if(n<=2) { if(n>=0) 1 else 0 } else Recall(n-1) + Recall(n-2)
> fibonacci <- fib; rm(fib)
> ## renaming wouldn't work without Recall
> fibonacci(10) # 55
[1] 55
> 
> 
> 
> cleanEx()
> nameEx("Rhome")
> ### * Rhome
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Rhome
> ### Title: Return the R Home Directory
> ### Aliases: R.home R_HOME
> ### Keywords: utilities
> 
> ### ** Examples
> 
> ## These result quite platform dependently :
> rbind(home = R.home(),
+       bin  = R.home("bin")) # often a sub directory of 'home'
     [,1]                  
home "/usr/local/lib/R"    
bin  "/usr/local/lib/R/bin"
> list.files(R.home("bin"))
 [1] "BATCH"         "build"         "check"         "COMPILE"      
 [5] "config"        "exec"          "INSTALL"       "javareconf"   
 [9] "libtool"       "LINK"          "mkinstalldirs" "pager"        
[13] "R"             "Rcmd"          "Rd2pdf"        "Rdconv"       
[17] "Rdiff"         "REMOVE"        "Rprof"         "Rscript"      
[21] "rtags"         "SHLIB"         "Stangle"       "Sweave"       
> 
> 
> 
> cleanEx()
> nameEx("Round")
> ### * Round
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Round
> ### Title: Rounding of Numbers
> ### Aliases: ceiling floor round signif trunc
> ### Keywords: arith
> 
> ### ** Examples
> 
> round(.5 + -2:4) # IEEE / IEC rounding: -2  0  0  2  2  4  4
[1] -2  0  0  2  2  4  4
> ## (this is *good* behaviour -- do *NOT* report it as bug !)
> 
> ( x1 <- seq(-2, 4, by = .5) )
 [1] -2.0 -1.5 -1.0 -0.5  0.0  0.5  1.0  1.5  2.0  2.5  3.0  3.5  4.0
> round(x1) #-- IEEE / IEC rounding !
 [1] -2 -2 -1  0  0  0  1  2  2  2  3  4  4
> x1[trunc(x1) != floor(x1)]
[1] -1.5 -0.5
> x1[round(x1) != floor(x1 + .5)]
[1] -1.5  0.5  2.5
> (non.int <- ceiling(x1) != floor(x1))
 [1] FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE
[13] FALSE
> 
> x2 <- pi * 100^(-1:3)
> round(x2, 3)
[1]       0.031       3.142     314.159   31415.927 3141592.654
> signif(x2, 3)
[1] 3.14e-02 3.14e+00 3.14e+02 3.14e+04 3.14e+06
> 
> 
> 
> cleanEx()
> nameEx("S3method")
> ### * S3method
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: S3method
> ### Title: Register S3 Methods
> ### Aliases: .S3method
> 
> ### ** Examples
> 
> ## Create a generic function and register a method for objects
> ## inheriting from class 'cls':
> gen <- function(x) UseMethod("gen")
> met <- function(x) writeLines("Hello world.")
> .S3method("gen", "cls", met)
> ## Create an object inheriting from class 'cls', and call the
> ## generic on it:
> x <- structure(123, class = "cls")
> gen(x)
Hello world.
> 
> 
> 
> cleanEx()
> nameEx("Special")
> ### * Special
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Special
> ### Title: Special Functions of Mathematics
> ### Aliases: Special beta lbeta gamma lgamma psigamma digamma trigamma
> ###   choose lchoose factorial lfactorial
> ### Keywords: math
> 
> ### ** Examples
> 
> require(graphics)
> 
> choose(5, 2)
[1] 10
> for (n in 0:10) print(choose(n, k = 0:n))
[1] 1
[1] 1 1
[1] 1 2 1
[1] 1 3 3 1
[1] 1 4 6 4 1
[1]  1  5 10 10  5  1
[1]  1  6 15 20 15  6  1
[1]  1  7 21 35 35 21  7  1
[1]  1  8 28 56 70 56 28  8  1
 [1]   1   9  36  84 126 126  84  36   9   1
 [1]   1  10  45 120 210 252 210 120  45  10   1
> 
> factorial(100)
[1] 9.332622e+157
> lfactorial(10000)
[1] 82108.93
> 
> ## gamma has 1st order poles at 0, -1, -2, ...
> ## this will generate loss of precision warnings, so turn off
> op <- options("warn")
> options(warn = -1)
> x <- sort(c(seq(-3, 4, length.out = 201), outer(0:-3, (-1:1)*1e-6, "+")))
> plot(x, gamma(x), ylim = c(-20,20), col = "red", type = "l", lwd = 2,
+      main = expression(Gamma(x)))
> abline(h = 0, v = -3:0, lty = 3, col = "midnightblue")
> options(op)
> 
> x <- seq(0.1, 4, length.out = 201); dx <- diff(x)[1]
> par(mfrow = c(2, 3))
> for (ch in c("", "l","di","tri","tetra","penta")) {
+   is.deriv <- nchar(ch) >= 2
+   nm <- paste0(ch, "gamma")
+   if (is.deriv) {
+     dy <- diff(y) / dx # finite difference
+     der <- which(ch == c("di","tri","tetra","penta")) - 1
+     nm2 <- paste0("psigamma(*, deriv = ", der,")")
+     nm  <- if(der >= 2) nm2 else paste(nm, nm2, sep = " ==\n")
+     y <- psigamma(x, deriv = der)
+   } else {
+     y <- get(nm)(x)
+   }
+   plot(x, y, type = "l", main = nm, col = "red")
+   abline(h = 0, col = "lightgray")
+   if (is.deriv) lines(x[-1], dy, col = "blue", lty = 2)
+ }
> par(mfrow = c(1, 1))
> 
> ## "Extended" Pascal triangle:
> fN <- function(n) formatC(n, width=2)
> for (n in -4:10) {
+     cat(fN(n),":", fN(choose(n, k = -2:max(3, n+2))))
+     cat("\n")
+ }
-4 :  0  0  1 -4 10 -20
-3 :  0  0  1 -3  6 -10
-2 :  0  0  1 -2  3 -4
-1 :  0  0  1 -1  1 -1
 0 :  0  0  1  0  0  0
 1 :  0  0  1  1  0  0
 2 :  0  0  1  2  1  0  0
 3 :  0  0  1  3  3  1  0  0
 4 :  0  0  1  4  6  4  1  0  0
 5 :  0  0  1  5 10 10  5  1  0  0
 6 :  0  0  1  6 15 20 15  6  1  0  0
 7 :  0  0  1  7 21 35 35 21  7  1  0  0
 8 :  0  0  1  8 28 56 70 56 28  8  1  0  0
 9 :  0  0  1  9 36 84 126 126 84 36  9  1  0  0
10 :  0  0  1 10 45 120 210 252 210 120 45 10  1  0  0
> 
> ## R code version of choose()  [simplistic; warning for k < 0]:
> mychoose <- function(r, k)
+     ifelse(k <= 0, (k == 0),
+            sapply(k, function(k) prod(r:(r-k+1))) / factorial(k))
> k <- -1:6
> cbind(k = k, choose(1/2, k), mychoose(1/2, k))
Warning in gamma(x + 1) : NaNs produced
      k                        
[1,] -1  0.00000000  0.00000000
[2,]  0  1.00000000  1.00000000
[3,]  1  0.50000000  0.50000000
[4,]  2 -0.12500000 -0.12500000
[5,]  3  0.06250000  0.06250000
[6,]  4 -0.03906250 -0.03906250
[7,]  5  0.02734375  0.02734375
[8,]  6 -0.02050781 -0.02050781
> 
> ## Binomial theorem for n = 1/2 ;
> ## sqrt(1+x) = (1+x)^(1/2) = sum_{k=0}^Inf  choose(1/2, k) * x^k :
> k <- 0:10 # 10 is sufficient for ~ 9 digit precision:
> sqrt(1.25)
[1] 1.118034
> sum(choose(1/2, k)* .25^k)
[1] 1.118034
> 
> ## Don't show: 
> k. <- 1:9
> stopifnot(all.equal( (choose(1/2, k.) -> ck.),
+                     mychoose(1/2, k.)),
+           all.equal(lchoose(1/2, k.), log(abs(ck.))),
+           all.equal(sqrt(1.25),
+                     sum(choose(1/2, k)* .25^k)))
> ## End(Don't show)
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("Startup")
> ### * Startup
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Startup
> ### Title: Initialization at Start of an R Session
> ### Aliases: Startup Rprofile .Rprofile Rprofile.site Renviron
> ###   Renviron.site .Renviron .First .First.sys .OptRequireMethods
> ###   R_DEFAULT_PACKAGES R_ENVIRON R_ENVIRON_USER R_PROFILE R_PROFILE_USER
> ### Keywords: environment
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ## Example ~/.Renviron on Unix
> ##D R_LIBS=~/R/library
> ##D PAGER=/usr/local/bin/less
> ##D 
> ##D ## Example .Renviron on Windows
> ##D R_LIBS=C:/R/library
> ##D MY_TCLTK="c:/Program Files/Tcl/bin"
> ##D 
> ##D ## Example of setting R_DEFAULT_PACKAGES (from R CMD check)
> ##D R_DEFAULT_PACKAGES='utils,grDevices,graphics,stats'
> ##D # this loads the packages in the order given, so they appear on
> ##D # the search path in reverse order.
> ##D 
> ##D ## Example of .Rprofile
> ##D options(width=65, digits=5)
> ##D options(show.signif.stars=FALSE)
> ##D setHook(packageEvent("grDevices", "onLoad"),
> ##D         function(...) grDevices::ps.options(horizontal=FALSE))
> ##D set.seed(1234)
> ##D .First <- function() cat("\n   Welcome to R!\n\n")
> ##D .Last <- function()  cat("\n   Goodbye!\n\n")
> ##D 
> ##D ## Example of Rprofile.site
> ##D local({
> ##D   # add MASS to the default packages, set a CRAN mirror
> ##D   old <- getOption("defaultPackages"); r <- getOption("repos")
> ##D   r["CRAN"] <- "http://my.local.cran"
> ##D   options(defaultPackages = c(old, "MASS"), repos = r)
> ##D   ## (for Unix terminal users) set the width from COLUMNS if set
> ##D   cols <- Sys.getenv("COLUMNS")
> ##D   if(nzchar(cols)) options(width = as.integer(cols))
> ##D   # interactive sessions get a fortune cookie (needs fortunes package)
> ##D   if (interactive())
> ##D     fortunes::fortune()
> ##D })
> ##D 
> ##D ## if .Renviron contains
> ##D FOOBAR="coo\bar"doh\ex"abc\"def'"
> ##D 
> ##D ## then we get
> ##D # > cat(Sys.getenv("FOOBAR"), "\n")
> ##D # coo\bardoh\exabc"def'
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("Syntax")
> ### * Syntax
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Syntax
> ### Title: Operator Syntax and Precedence
> ### Aliases: Syntax
> ### Keywords: documentation programming
> 
> ### ** Examples
> 
> ## Logical AND ("&&") has higher precedence than OR ("||"):
> TRUE || TRUE && FALSE   # is the same as
[1] TRUE
> TRUE || (TRUE && FALSE) # and different from
[1] TRUE
> (TRUE || TRUE) && FALSE
[1] FALSE
> 
> ## Special operators have higher precedence than "!" (logical NOT).
> ## You can use this for %in% :
> ! 1:10 %in% c(2, 3, 5, 7) # same as !(1:10 %in% c(2, 3, 5, 7))
 [1]  TRUE FALSE FALSE  TRUE FALSE  TRUE FALSE  TRUE  TRUE  TRUE
> ## but we strongly advise to use the "!( ... )" form in this case!
> 
> 
> ## '=' has lower precedence than '<-' ... so you should not mix them
> ##     (and '<-' is considered better style anyway):
> 
> 
> 
> cleanEx()
> nameEx("Sys.getenv")
> ### * Sys.getenv
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Sys.getenv
> ### Title: Get Environment Variables
> ### Aliases: Sys.getenv
> ### Keywords: environment utilities
> 
> ### ** Examples
> 
> ## whether HOST is set will be shell-dependent e.g. Solaris' csh does not.
> Sys.getenv(c("R_HOME", "R_PAPERSIZE", "R_PRINTCMD", "HOST"))
            R_HOME        R_PAPERSIZE         R_PRINTCMD               HOST 
"/usr/local/lib/R"           "letter"     "/usr/bin/lpr"                 "" 
> 
> names(s <- Sys.getenv()) # all settings (the values could be very long)
 [1] "BIBINPUTS"          "BSTINPUTS"          "CRAN"              
 [4] "EDITOR"             "HOME"               "HOSTNAME"          
 [7] "LANG"               "LC_ALL"             "LD_LIBRARY_PATH"   
[10] "LN_S"               "MAKE"               "PAGER"             
[13] "PATH"               "PWD"                "R_ARCH"            
[16] "R_BROWSER"          "R_BZIPCMD"          "R_CMD"             
[19] "R_DOC_DIR"          "R_ENVIRON"          "R_ENVIRON_USER"    
[22] "R_GZIPCMD"          "R_HOME"             "R_INCLUDE_DIR"     
[25] "R_LIBS"             "R_LIBS_SITE"        "R_LIBS_USER"       
[28] "R_OSTYPE"           "R_PAPERSIZE"        "R_PAPERSIZE_USER"  
[31] "R_PDFVIEWER"        "R_PLATFORM"         "R_PRINTCMD"        
[34] "R_PROFILE"          "R_PROFILE_USER"     "R_RD4PDF"          
[37] "R_SESSION_TMPDIR"   "R_SHARE_DIR"        "R_STRIP_SHARED_LIB"
[40] "R_STRIP_STATIC_LIB" "R_SYSTEM_ABI"       "R_TEXI2DVICMD"     
[43] "R_UNZIPCMD"         "R_VERSION"          "R_ZIPCMD"          
[46] "SED"                "SHLVL"              "TAR"               
[49] "TERM"               "TEXINPUTS"          "TZ"                
> head(s, 12)# using the Dlist print() method
BIBINPUTS               .:.:/usr/local/lib/R/share/texmf/bibtex/bib::/usr/local/lib/R/share/texmf/bibtex/bib:
BSTINPUTS               .:.:/usr/local/lib/R/share/texmf/bibtex/bst::/usr/local/lib/R/share/texmf/bibtex/bst:
CRAN                    https://packagemanager.rstudio.com/all/__linux__/focal/latest
EDITOR                  vi
HOME                    /root
HOSTNAME                8d9262e4ff0b
LANG                    en_US.UTF-8
LC_ALL                  en_US.UTF-8
LD_LIBRARY_PATH         /usr/local/lib/R/lib:/usr/local/lib:/usr/lib/x86_64-linux-gnu:/usr/lib/jvm/java-11-openjdk-amd64/lib/server:/usr/local/lib/R/lib:/usr/local/lib:/usr/lib/x86_64-linux-gnu:/usr/lib/jvm/java-11-openjdk-amd64/lib/server:/usr/local/lib/R/lib:/usr/local/lib:/usr/lib/x86_64-linux-gnu:/usr/lib/jvm/java-11-openjdk-amd64/lib/server:/usr/local/lib/R/lib:/usr/local/lib:/usr/lib/x86_64-linux-gnu:/usr/lib/jvm/java-11-openjdk-amd64/lib/server:/usr/local/lib/R/lib:/usr/local/lib:/usr/lib/x86_64-linux-gnu:/usr/lib/jvm/java-11-openjdk-amd64/lib/server
LN_S                    ln -s
MAKE                    make
PAGER                   /usr/bin/pager
> 
> ## Language and Locale settings -- but rather use Sys.getlocale()
> s[grep("^L(C|ANG)", names(s))]
LANG                    en_US.UTF-8
LC_ALL                  en_US.UTF-8
> 
> 
> 
> cleanEx()
> nameEx("Sys.getpid")
> ### * Sys.getpid
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Sys.getpid
> ### Title: Get the Process ID of the R Session
> ### Aliases: Sys.getpid
> ### Keywords: utilities
> 
> ### ** Examples
> 
> 
> cleanEx()
> nameEx("Sys.glob")
> ### * Sys.glob
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Sys.glob
> ### Title: Wildcard Expansion on File Paths
> ### Aliases: Sys.glob
> ### Keywords: utilities file
> 
> ### ** Examples
> 
> 
> 
> cleanEx()
> nameEx("Sys.info")
> ### * Sys.info
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Sys.info
> ### Title: Extract System and User Information
> ### Aliases: Sys.info
> ### Keywords: utilities
> 
> ### ** Examples
> 
> Sys.info()
                                             sysname 
                                             "Linux" 
                                             release 
                                  "5.4.0-1040-azure" 
                                             version 
"#42~18.04.1-Ubuntu SMP Mon Feb 8 19:05:32 UTC 2021" 
                                            nodename 
                                      "8d9262e4ff0b" 
                                             machine 
                                            "x86_64" 
                                               login 
                                           "unknown" 
                                                user 
                                              "root" 
                                      effective_user 
                                              "root" 
> ## An alternative (and probably better) way to get the login name on Unix
> Sys.getenv("LOGNAME")
[1] ""
> 
> 
> 
> cleanEx()
> nameEx("Sys.localeconv")
> ### * Sys.localeconv
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Sys.localeconv
> ### Title: Find Details of the Numerical and Monetary Representations in
> ###   the Current Locale
> ### Aliases: localeconv Sys.localeconv
> ### Keywords: utilities
> 
> ### ** Examples
> 
> Sys.localeconv()
    decimal_point     thousands_sep          grouping   int_curr_symbol 
              "."                ""                ""            "USD " 
  currency_symbol mon_decimal_point mon_thousands_sep      mon_grouping 
              "$"               "."               ","        "\003\003" 
    positive_sign     negative_sign   int_frac_digits       frac_digits 
               ""               "-"               "2"               "2" 
    p_cs_precedes    p_sep_by_space     n_cs_precedes    n_sep_by_space 
              "1"               "0"               "1"               "0" 
      p_sign_posn       n_sign_posn 
              "1"               "1" 
> ## The results in the C locale are
> ##    decimal_point     thousands_sep          grouping   int_curr_symbol
> ##              "."                ""                ""                ""
> ##  currency_symbol mon_decimal_point mon_thousands_sep      mon_grouping
> ##               ""                ""                ""                ""
> ##    positive_sign     negative_sign   int_frac_digits       frac_digits
> ##               ""                ""             "127"             "127"
> ##    p_cs_precedes    p_sep_by_space     n_cs_precedes    n_sep_by_space
> ##            "127"             "127"             "127"             "127"
> ##      p_sign_posn       n_sign_posn
> ##            "127"             "127"
> 
> ## Now try your default locale (which might be "C").
> 
> ## Not run: read.table("foo", dec=Sys.localeconv()["decimal_point"])
> 
> 
> 
> cleanEx()
> nameEx("Sys.readlink")
> ### * Sys.readlink
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Sys.readlink
> ### Title: Read File Symbolic Links
> ### Aliases: Sys.readlink
> ### Keywords: file
> 
> ### ** Examples
> 
> ##' To check if files (incl. directories) are symbolic links:
> is.symlink <- function(paths) isTRUE(nzchar(Sys.readlink(paths), keepNA=TRUE))
> ## will return all FALSE when the platform has no `readlink` system call.
> is.symlink("/foo/bar")
[1] FALSE
> 
> 
> 
> cleanEx()
> nameEx("Sys.setenv")
> ### * Sys.setenv
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Sys.setenv
> ### Title: Set or Unset Environment Variables
> ### Aliases: Sys.setenv Sys.unsetenv
> ### Keywords: environment utilities
> 
> ### ** Examples
> 
> print(Sys.setenv(R_TEST = "testit", "A+C" = 123))  # `A+C` could also be used
[1] TRUE TRUE
> Sys.getenv("R_TEST")
[1] "testit"
> Sys.unsetenv("R_TEST")  # may warn and not succeed
> Sys.getenv("R_TEST", unset = NA)
[1] NA
> 
> 
> 
> cleanEx()
> nameEx("Sys.sleep")
> ### * Sys.sleep
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Sys.sleep
> ### Title: Suspend Execution for a Time Interval
> ### Aliases: Sys.sleep
> ### Keywords: utilities
> 
> ### ** Examples
> 
> 
> cleanEx()
> nameEx("Sys.time")
> ### * Sys.time
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Sys.time
> ### Title: Get Current Date and Time
> ### Aliases: Sys.time Sys.Date
> ### Keywords: utilities chron
> 
> ### ** Examples
> 
> 
> cleanEx()
> nameEx("Sys.which")
> ### * Sys.which
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Sys.which
> ### Title: Find Full Paths to Executables
> ### Aliases: Sys.which
> ### Keywords: utilities
> 
> ### ** Examples
> 
> ## the first two are likely to exist everywhere
> ## texi2dvi exists on most Unix-alikes and under MiKTeX
> Sys.which(c("ftp", "ping", "texi2dvi", "this-does-not-exist"))
                ftp                ping            texi2dvi this-does-not-exist 
                 ""                  ""                  ""                  "" 
> 
> 
> 
> cleanEx()
> nameEx("Trig")
> ### * Trig
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Trig
> ### Title: Trigonometric Functions
> ### Aliases: Trig cos sin tan acos arccos asin arcsin atan arctan atan2
> ###   cospi sinpi tanpi
> ### Keywords: math
> 
> ### ** Examples
> 
> x <- seq(-3, 7, by = 1/8)
> tx <- cbind(x, cos(pi*x), cospi(x), sin(pi*x), sinpi(x),
+                tan(pi*x), tanpi(x), deparse.level=2)
Warning in tanpi(x) : NaNs produced
> op <- options(digits = 4, width = 90) # for nice formatting
> head(tx)
          x cos(pi * x... cospi(x) sin(pi * x... sinpi(x) tan(pi * x... tanpi(x)
[1,] -3.000    -1.000e+00  -1.0000    -3.674e-16   0.0000     3.674e-16   0.0000
[2,] -2.875    -9.239e-01  -0.9239    -3.827e-01  -0.3827     4.142e-01   0.4142
[3,] -2.750    -7.071e-01  -0.7071    -7.071e-01  -0.7071     1.000e+00   1.0000
[4,] -2.625    -3.827e-01  -0.3827    -9.239e-01  -0.9239     2.414e+00   2.4142
[5,] -2.500     3.062e-16   0.0000    -1.000e+00  -1.0000    -3.266e+15      NaN
[6,] -2.375     3.827e-01   0.3827    -9.239e-01  -0.9239    -2.414e+00  -2.4142
> tx[ (x %% 1) %in% c(0, 0.5) ,]
         x cos(pi * x... cospi(x) sin(pi * x... sinpi(x) tan(pi * x... tanpi(x)
 [1,] -3.0    -1.000e+00       -1    -3.674e-16        0     3.674e-16        0
 [2,] -2.5     3.062e-16        0    -1.000e+00       -1    -3.266e+15      NaN
 [3,] -2.0     1.000e+00        1     2.449e-16        0     2.449e-16        0
 [4,] -1.5    -1.837e-16        0     1.000e+00        1    -5.444e+15      NaN
 [5,] -1.0    -1.000e+00       -1    -1.225e-16        0     1.225e-16        0
 [6,] -0.5     6.123e-17        0    -1.000e+00       -1    -1.633e+16      NaN
 [7,]  0.0     1.000e+00        1     0.000e+00        0     0.000e+00        0
 [8,]  0.5     6.123e-17        0     1.000e+00        1     1.633e+16      NaN
 [9,]  1.0    -1.000e+00       -1     1.225e-16        0    -1.225e-16        0
[10,]  1.5    -1.837e-16        0    -1.000e+00       -1     5.444e+15      NaN
[11,]  2.0     1.000e+00        1    -2.449e-16        0    -2.449e-16        0
[12,]  2.5     3.062e-16        0     1.000e+00        1     3.266e+15      NaN
[13,]  3.0    -1.000e+00       -1     3.674e-16        0    -3.674e-16        0
[14,]  3.5    -4.286e-16        0    -1.000e+00       -1     2.333e+15      NaN
[15,]  4.0     1.000e+00        1    -4.899e-16        0    -4.899e-16        0
[16,]  4.5     5.511e-16        0     1.000e+00        1     1.815e+15      NaN
[17,]  5.0    -1.000e+00       -1     6.123e-16        0    -6.123e-16        0
[18,]  5.5    -2.450e-15        0    -1.000e+00       -1     4.082e+14      NaN
[19,]  6.0     1.000e+00        1    -7.348e-16        0    -7.348e-16        0
[20,]  6.5    -9.803e-16        0     1.000e+00        1    -1.020e+15      NaN
[21,]  7.0    -1.000e+00       -1     8.573e-16        0    -8.573e-16        0
> options(op)
> 
> 
> 
> cleanEx()
> nameEx("Vectorize")
> ### * Vectorize
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Vectorize
> ### Title: Vectorize a Scalar Function
> ### Aliases: Vectorize
> ### Keywords: manip utilities
> 
> ### ** Examples
> 
> # We use rep.int as rep is primitive
> vrep <- Vectorize(rep.int)
> vrep(1:4, 4:1)
[[1]]
[1] 1 1 1 1

[[2]]
[1] 2 2 2

[[3]]
[1] 3 3

[[4]]
[1] 4

> vrep(times = 1:4, x = 4:1)
[[1]]
[1] 4

[[2]]
[1] 3 3

[[3]]
[1] 2 2 2

[[4]]
[1] 1 1 1 1

> 
> vrep <- Vectorize(rep.int, "times")
> vrep(times = 1:4, x = 42)
[[1]]
[1] 42

[[2]]
[1] 42 42

[[3]]
[1] 42 42 42

[[4]]
[1] 42 42 42 42

> 
> f <- function(x = 1:3, y) c(x, y)
> vf <- Vectorize(f, SIMPLIFY = FALSE)
> f(1:3, 1:3)
[1] 1 2 3 1 2 3
> vf(1:3, 1:3)
[[1]]
[1] 1 1

[[2]]
[1] 2 2

[[3]]
[1] 3 3

> vf(y = 1:3) # Only vectorizes y, not x
[[1]]
[1] 1 2 3 1

[[2]]
[1] 1 2 3 2

[[3]]
[1] 1 2 3 3

> 
> # Nonlinear regression contour plot, based on nls() example
> require(graphics)
> SS <- function(Vm, K, resp, conc) {
+     pred <- (Vm * conc)/(K + conc)
+     sum((resp - pred)^2 / pred)
+ }
> vSS <- Vectorize(SS, c("Vm", "K"))
> Treated <- subset(Puromycin, state == "treated")
> 
> Vm <- seq(140, 310, length.out = 50)
> K <- seq(0, 0.15, length.out = 40)
> SSvals <- outer(Vm, K, vSS, Treated$rate, Treated$conc)
> contour(Vm, K, SSvals, levels = (1:10)^2, xlab = "Vm", ylab = "K")
> 
> # combn() has an argument named FUN
> combnV <- Vectorize(function(x, m, FUNV = NULL) combn(x, m, FUN = FUNV),
+                     vectorize.args = c("x", "m"))
> combnV(4, 1:4)
[[1]]
     [,1] [,2] [,3] [,4]
[1,]    1    2    3    4

[[2]]
     [,1] [,2] [,3] [,4] [,5] [,6]
[1,]    1    1    1    2    2    3
[2,]    2    3    4    3    4    4

[[3]]
     [,1] [,2] [,3] [,4]
[1,]    1    1    1    2
[2,]    2    2    3    3
[3,]    3    4    4    4

[[4]]
     [,1]
[1,]    1
[2,]    2
[3,]    3
[4,]    4

> combnV(4, 1:4, sum)
[[1]]
[1] 1 2 3 4

[[2]]
[1] 3 4 5 5 6 7

[[3]]
[1] 6 7 8 9

[[4]]
[1] 10

> 
> 
> 
> cleanEx()
> nameEx("Version")
> ### * Version
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: R.Version
> ### Title: Version Information
> ### Aliases: R.Version R.version version R.version.string
> ### Keywords: environment sysdata programming
> 
> ### ** Examples
> 
> require(graphics)
> 
> R.version$os # to check how lucky you are ...
[1] "linux-gnu"
> plot(0) # any plot
> mtext(R.version.string, side = 1, line = 4, adj = 1) # a useful bottom-right note
> 
> ## a good way to detect macOS:
> if(grepl("^darwin", R.version$os)) message("running on macOS")
> 
> ## Short R version string, ("space free", useful in file/directory names;
> ##                          also fine for unreleased versions of R):
> shortRversion <- function() {
+    rvs <- R.version.string
+    if(grepl("devel", (st <- R.version$status)))
+        rvs <- sub(paste0(" ",st," "), "-devel_", rvs, fixed=TRUE)
+    gsub("[()]", "", gsub(" ", "_", sub(" version ", "-", rvs)))
+ }
> ## Don't show: 
> stopifnot(identical(grep(" ", shortRversion()), integer(0)))
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("abbreviate")
> ### * abbreviate
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: abbreviate
> ### Title: Abbreviate Strings
> ### Aliases: abbreviate
> ### Keywords: character
> 
> ### ** Examples
> 
> x <- c("abcd", "efgh", "abce")
> abbreviate(x, 2)
  abcd   efgh   abce 
"abcd"   "ef" "abce" 
> abbreviate(x, 2, strict = TRUE) # >> 1st and 3rd are == "ab"
abcd efgh abce 
"ab" "ef" "ab" 
> 
> (st.abb <- abbreviate(state.name, 2))
       Alabama         Alaska        Arizona       Arkansas     California 
         "Alb"          "Als"          "Arz"          "Ark"          "Clf" 
      Colorado    Connecticut       Delaware        Florida        Georgia 
         "Clr"           "Cn"           "Dl"           "Fl"           "Gr" 
        Hawaii          Idaho       Illinois        Indiana           Iowa 
          "Hw"           "Id"           "Il"           "In"           "Iw" 
        Kansas       Kentucky      Louisiana          Maine       Maryland 
         "Kns"          "Knt"           "Ls"          "Man"           "Mr" 
 Massachusetts       Michigan      Minnesota    Mississippi       Missouri 
        "Mssc"           "Mc"          "Mnn"         "Msss"         "Mssr" 
       Montana       Nebraska         Nevada  New Hampshire     New Jersey 
         "Mnt"           "Nb"           "Nv"           "NH"           "NJ" 
    New Mexico       New York North Carolina   North Dakota           Ohio 
          "NM"           "NY"           "NC"           "ND"           "Oh" 
      Oklahoma         Oregon   Pennsylvania   Rhode Island South Carolina 
          "Ok"           "Or"           "Pn"           "RI"           "SC" 
  South Dakota      Tennessee          Texas           Utah        Vermont 
          "SD"           "Tn"           "Tx"           "Ut"          "Vrm" 
      Virginia     Washington  West Virginia      Wisconsin        Wyoming 
         "Vrg"          "Wsh"           "WV"          "Wsc"           "Wy" 
> stopifnot(identical(unname(st.abb),
+            abbreviate(state.name, 2, named=FALSE)))
> table(nchar(st.abb)) # out of 50, 3 need 4 letters :

 2  3  4 
32 15  3 
> as <- abbreviate(state.name, 3, strict = TRUE)
> as[which(as == "Mss")]
Massachusetts   Mississippi      Missouri 
        "Mss"         "Mss"         "Mss" 
> ## Don't show: 
> stopifnot(which(as == "Mss") == c(21,24,25))
> ## End(Don't show)
> ## and without distinguishing vowels:
> st.abb2 <- abbreviate(state.name, 2, FALSE)
> cbind(st.abb, st.abb2)[st.abb2 != st.abb, ]
              st.abb st.abb2
Alabama       "Alb"  "Alab" 
Alaska        "Als"  "Alas" 
Arizona       "Arz"  "Ari"  
California    "Clf"  "Ca"   
Colorado      "Clr"  "Col"  
Connecticut   "Cn"   "Con"  
Delaware      "Dl"   "De"   
Georgia       "Gr"   "Ge"   
Hawaii        "Hw"   "Ha"   
Iowa          "Iw"   "Io"   
Kansas        "Kns"  "Ka"   
Kentucky      "Knt"  "Ke"   
Louisiana     "Ls"   "Lo"   
Maine         "Man"  "Mai"  
Maryland      "Mr"   "Mar"  
Massachusetts "Mssc" "Mas"  
Michigan      "Mc"   "Mic"  
Minnesota     "Mnn"  "Min"  
Mississippi   "Msss" "Missi"
Missouri      "Mssr" "Misso"
Montana       "Mnt"  "Mo"   
Nebraska      "Nb"   "Neb"  
Nevada        "Nv"   "Nev"  
Pennsylvania  "Pn"   "Pe"   
Tennessee     "Tn"   "Ten"  
Texas         "Tx"   "Tex"  
Vermont       "Vrm"  "Ve"   
Virginia      "Vrg"  "Vi"   
Washington    "Wsh"  "Wa"   
Wisconsin     "Wsc"  "Wi"   
> 
> ## method = "both.sides" helps:  no 4-letters, and only 4 3-letters:
> st.ab2 <- abbreviate(state.name, 2, method = "both")
> table(nchar(st.ab2))

 2  3 
46  4 
> ## Compare the two methods:
> cbind(st.abb, st.ab2)
               st.abb st.ab2
Alabama        "Alb"  "Al"  
Alaska         "Als"  "Aa"  
Arizona        "Arz"  "Ar"  
Arkansas       "Ark"  "As"  
California     "Clf"  "Cl"  
Colorado       "Clr"  "Co"  
Connecticut    "Cn"   "Cn"  
Delaware       "Dl"   "Dl"  
Florida        "Fl"   "Fl"  
Georgia        "Gr"   "Gr"  
Hawaii         "Hw"   "Hw"  
Idaho          "Id"   "Id"  
Illinois       "Il"   "Il"  
Indiana        "In"   "In"  
Iowa           "Iw"   "Iw"  
Kansas         "Kns"  "Kn"  
Kentucky       "Knt"  "Ky"  
Louisiana      "Ls"   "Ls"  
Maine          "Man"  "Mn"  
Maryland       "Mr"   "Mr"  
Massachusetts  "Mssc" "Ms"  
Michigan       "Mc"   "Mc"  
Minnesota      "Mnn"  "Mnn" 
Mississippi    "Msss" "Mss" 
Missouri       "Mssr" "Mri" 
Montana        "Mnt"  "Mnt" 
Nebraska       "Nb"   "Nb"  
Nevada         "Nv"   "Nv"  
New Hampshire  "NH"   "NH"  
New Jersey     "NJ"   "NJ"  
New Mexico     "NM"   "NM"  
New York       "NY"   "NY"  
North Carolina "NC"   "NC"  
North Dakota   "ND"   "ND"  
Ohio           "Oh"   "Oh"  
Oklahoma       "Ok"   "Ok"  
Oregon         "Or"   "Or"  
Pennsylvania   "Pn"   "Pn"  
Rhode Island   "RI"   "RI"  
South Carolina "SC"   "SC"  
South Dakota   "SD"   "SD"  
Tennessee      "Tn"   "Tn"  
Texas          "Tx"   "Tx"  
Utah           "Ut"   "Ut"  
Vermont        "Vrm"  "Vr"  
Virginia       "Vrg"  "Va"  
Washington     "Wsh"  "Ws"  
West Virginia  "WV"   "WV"  
Wisconsin      "Wsc"  "Wn"  
Wyoming        "Wy"   "Wy"  
> 
> 
> 
> cleanEx()
> nameEx("agrep")
> ### * agrep
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: agrep
> ### Title: Approximate String Matching (Fuzzy Matching)
> ### Aliases: agrep agrepl 'fuzzy matching' .amatch_bounds .amatch_costs
> ### Keywords: character
> 
> ### ** Examples
> 
> agrep("lasy", "1 lazy 2")
[1] 1
> agrep("lasy", c(" 1 lazy 2", "1 lasy 2"), max = list(sub = 0))
[1] 2
> agrep("laysy", c("1 lazy", "1", "1 LAZY"), max = 2)
[1] 1
> agrep("laysy", c("1 lazy", "1", "1 LAZY"), max = 2, value = TRUE)
[1] "1 lazy"
> agrep("laysy", c("1 lazy", "1", "1 LAZY"), max = 2, ignore.case = TRUE)
[1] 1 3
> 
> 
> 
> cleanEx()
> nameEx("all")
> ### * all
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: all
> ### Title: Are All Values True?
> ### Aliases: all
> ### Keywords: logic
> 
> ### ** Examples
> 
> range(x <- sort(round(stats::rnorm(10) - 1.2, 1)))
[1] -2.0  0.4
> if(all(x < 0)) cat("all x values are negative\n")
> 
> all(logical(0))  # true, as all zero of the elements are true.
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("all.equal")
> ### * all.equal
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: all.equal
> ### Title: Test if Two Objects are (Nearly) Equal
> ### Aliases: all.equal all.equal.default all.equal.numeric
> ###   all.equal.character all.equal.environment all.equal.envRefClass
> ###   all.equal.factor all.equal.formula all.equal.list all.equal.language
> ###   all.equal.POSIXt all.equal.raw attr.all.equal
> ### Keywords: programming utilities logic arith
> 
> ### ** Examples
> 
> all.equal(pi, 355/113)
[1] "Mean relative difference: 8.491368e-08"
> # not precise enough (default tol) > relative error
> 
> d45 <- pi*(1/4 + 1:10)
> stopifnot(
+ all.equal(tan(d45), rep(1, 10)))          # TRUE, but
> all      (tan(d45) == rep(1, 10))         # FALSE, since not exactly
[1] FALSE
> all.equal(tan(d45), rep(1, 10), tolerance = 0)  # to see difference
[1] "Mean relative difference: 1.29526e-15"
> 
> ## advanced: equality of environments
> ae <- all.equal(as.environment("package:stats"),
+                 asNamespace("stats"))
> stopifnot(is.character(ae), length(ae) > 10,
+           ## were incorrectly "considered equal" in R <= 3.1.1
+           all.equal(asNamespace("stats"), asNamespace("stats")))
> 
> ## A situation where  'countEQ = TRUE' makes sense:
> x1 <- x2 <- (1:100)/10;  x2[2] <- 1.1*x1[2]
> ## 99 out of 100 pairs (x1[i], x2[i]) are equal:
> plot(x1,x2, main = "all.equal.numeric() -- not counting equal parts")
> all.equal(x1,x2) ## "Mean relative difference: 0.1"
[1] "Mean relative difference: 0.1"
> mtext(paste("all.equal(x1,x2) :", all.equal(x1,x2)), line= -2)
> ##' extract the 'Mean relative difference' as number:
> all.eqNum <- function(...) as.numeric(sub(".*:", '', all.equal(...)))
> set.seed(17)
> ## When x2 is jittered, typically all pairs (x1[i],x2[i]) do differ:
> summary(r <- replicate(100, all.eqNum(x1, x2*(1+rnorm(x1)*1e-7))))
     Min.   1st Qu.    Median      Mean   3rd Qu.      Max. 
3.967e-05 3.968e-05 3.968e-05 3.968e-05 3.969e-05 3.970e-05 
> mtext(paste("mean(all.equal(x1, x2*(1 + eps_k))) {100 x} Mean rel.diff.=",
+             signif(mean(r), 3)), line = -4, adj=0)
> ## With argument  countEQ=TRUE, get "the same" (w/o need for jittering):
> mtext(paste("all.equal(x1,x2, countEQ=TRUE) :",
+           signif(all.eqNum(x1,x2, countEQ=TRUE), 3)), line= -6, col=2)
> 
> 
> 
> cleanEx()
> nameEx("allnames")
> ### * allnames
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: all.names
> ### Title: Find All Names in an Expression
> ### Aliases: all.names all.vars
> ### Keywords: programming
> 
> ### ** Examples
> 
> all.names(expression(sin(x+y)))
[1] "sin" "+"   "x"   "y"  
> all.names(quote(sin(x+y))) # or a call
[1] "sin" "+"   "x"   "y"  
> all.vars(expression(sin(x+y)))
[1] "x" "y"
> 
> 
> 
> cleanEx()
> nameEx("any")
> ### * any
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: any
> ### Title: Are Some Values True?
> ### Aliases: any
> ### Keywords: logic
> 
> ### ** Examples
> 
> range(x <- sort(round(stats::rnorm(10) - 1.2, 1)))
[1] -2.0  0.4
> if(any(x < 0)) cat("x contains negative values\n")
x contains negative values
> 
> 
> 
> cleanEx()
> nameEx("aperm")
> ### * aperm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: aperm
> ### Title: Array Transposition
> ### Aliases: aperm aperm.default aperm.table
> ### Keywords: array
> 
> ### ** Examples
> 
> # interchange the first two subscripts on a 3-way array x
> x  <- array(1:24, 2:4)
> xt <- aperm(x, c(2,1,3))
> stopifnot(t(xt[,,2]) == x[,,2],
+           t(xt[,,3]) == x[,,3],
+           t(xt[,,4]) == x[,,4])
> 
> UCB <- aperm(UCBAdmissions, c(2,1,3))
> UCB[1,,]
          Dept
Admit        A   B   C   D   E   F
  Admitted 512 353 120 138  53  22
  Rejected 313 207 205 279 138 351
> summary(UCB) # UCB is still a contingency table
Number of cases in table: 4526 
Number of factors: 3 
Test for independence of all factors:
	Chisq = 2000.3, df = 16, p-value = 0
> ## Don't show: 
> stopifnot(is.table(UCB))
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("append")
> ### * append
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: append
> ### Title: Vector Merging
> ### Aliases: append
> ### Keywords: manip
> 
> ### ** Examples
> 
> append(1:5, 0:1, after = 3)
[1] 1 2 3 0 1 4 5
> 
> 
> 
> cleanEx()
> nameEx("apply")
> ### * apply
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: apply
> ### Title: Apply Functions Over Array Margins
> ### Aliases: apply
> ### Keywords: iteration array
> 
> ### ** Examples
> 
> ## Compute row and column sums for a matrix:
> x <- cbind(x1 = 3, x2 = c(4:1, 2:5))
> dimnames(x)[[1]] <- letters[1:8]
> apply(x, 2, mean, trim = .2)
x1 x2 
 3  3 
> col.sums <- apply(x, 2, sum)
> row.sums <- apply(x, 1, sum)
> rbind(cbind(x, Rtot = row.sums), Ctot = c(col.sums, sum(col.sums)))
     x1 x2 Rtot
a     3  4    7
b     3  3    6
c     3  2    5
d     3  1    4
e     3  2    5
f     3  3    6
g     3  4    7
h     3  5    8
Ctot 24 24   48
> 
> stopifnot( apply(x, 2, is.vector))
> 
> ## Sort the columns of a matrix
> apply(x, 2, sort)
     x1 x2
[1,]  3  1
[2,]  3  2
[3,]  3  2
[4,]  3  3
[5,]  3  3
[6,]  3  4
[7,]  3  4
[8,]  3  5
> 
> ## keeping named dimnames
> names(dimnames(x)) <- c("row", "col")
> x3 <- array(x, dim = c(dim(x),3),
+ 	    dimnames = c(dimnames(x), list(C = paste0("cop.",1:3))))
> identical(x,  apply( x,  2,  identity))
[1] TRUE
> identical(x3, apply(x3, 2:3, identity))
[1] TRUE
> ## Don't show: 
> xN <- x; dimnames(xN) <- list(row=NULL, col=NULL)
> x2 <- x; names(dimnames(x2)) <- NULL
> fXY <- function(u) c(X=u[1], Y=u[2])
> ax1 <- apply(x, 1, fXY)
> ax2 <- apply(x2,1, fXY)
> stopifnot(identical(dimnames(ax1), list(col=c("X.x1", "Y.x2"), row=letters[1:8])),
+           identical(dimnames(ax2), unname(dimnames(ax1))),
+           identical( x, apply( x, 2, identity)),
+           identical(xN, apply(xN, 2, identity)),
+ 	  identical(dimnames(x),
+ 		    dimnames(apply(x, 2, format))),
+           identical(x3, apply(x3, 2:3, identity)),
+ 	  identical(dimnames(apply(x3, 2:1, identity)),
+ 		    dimnames(x3)[3:1]))
> rm(xN, x2, fXY, ax1, ax2)
> ## End(Don't show)
> ##- function with extra args:
> cave <- function(x, c1, c2) c(mean(x[c1]), mean(x[c2]))
> apply(x, 1, cave,  c1 = "x1", c2 = c("x1","x2"))
      row
         a b   c d   e f   g h
  [1,] 3.0 3 3.0 3 3.0 3 3.0 3
  [2,] 3.5 3 2.5 2 2.5 3 3.5 4
> 
> ma <- matrix(c(1:4, 1, 6:8), nrow = 2)
> ma
     [,1] [,2] [,3] [,4]
[1,]    1    3    1    7
[2,]    2    4    6    8
> apply(ma, 1, table)  #--> a list of length 2
[[1]]

1 3 7 
2 1 1 

[[2]]

2 4 6 8 
1 1 1 1 

> apply(ma, 1, stats::quantile) # 5 x n matrix with rownames
     [,1] [,2]
0%      1  2.0
25%     1  3.5
50%     2  5.0
75%     4  6.5
100%    7  8.0
> 
> stopifnot(dim(ma) == dim(apply(ma, 1:2, sum)))
> 
> ## Example with different lengths for each call
> z <- array(1:24, dim = 2:4)
> zseq <- apply(z, 1:2, function(x) seq_len(max(x)))
> zseq         ## a 2 x 3 matrix
     [,1]       [,2]       [,3]      
[1,] Integer,19 Integer,21 Integer,23
[2,] Integer,20 Integer,22 Integer,24
> typeof(zseq) ## list
[1] "list"
> dim(zseq) ## 2 3
[1] 2 3
> zseq[1,]
[[1]]
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19

[[2]]
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21

[[3]]
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23

> apply(z, 3, function(x) seq_len(max(x)))
[[1]]
[1] 1 2 3 4 5 6

[[2]]
 [1]  1  2  3  4  5  6  7  8  9 10 11 12

[[3]]
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18

[[4]]
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24

> # a list without a dim attribute
> 
> 
> 
> cleanEx()
> nameEx("args")
> ### * args
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: args
> ### Title: Argument List of a Function
> ### Aliases: args
> ### Keywords: documentation
> 
> ### ** Examples
> 
> ## "regular" (non-primitive) functions "print their arguments"
> ## (by returning another function with NULL body which you also see):
> args(ls)
function (name, pos = -1L, envir = as.environment(pos), all.names = FALSE, 
    pattern, sorted = TRUE) 
NULL
> args(graphics::plot.default)
function (x, y = NULL, type = "p", xlim = NULL, ylim = NULL, 
    log = "", main = NULL, sub = NULL, xlab = NULL, ylab = NULL, 
    ann = par("ann"), axes = TRUE, frame.plot = axes, panel.first = NULL, 
    panel.last = NULL, asp = NA, xgap.axis = NA, ygap.axis = NA, 
    ...) 
NULL
> utils::str(ls) # (just "prints": does not show a NULL)
function (name, pos = -1L, envir = as.environment(pos), all.names = FALSE, 
    pattern, sorted = TRUE)  
> 
> ## You can also pass a string naming a function.
> args("scan")
function (file = "", what = double(), nmax = -1L, n = -1L, sep = "", 
    quote = if (identical(sep, "\n")) "" else "'\"", dec = ".", 
    skip = 0L, nlines = 0L, na.strings = "NA", flush = FALSE, 
    fill = FALSE, strip.white = FALSE, quiet = FALSE, blank.lines.skip = TRUE, 
    multi.line = TRUE, comment.char = "", allowEscapes = FALSE, 
    fileEncoding = "", encoding = "unknown", text, skipNul = FALSE) 
NULL
> ## ...but :: package specification doesn't work in this case.
> tryCatch(args("graphics::plot.default"), error = print)
<simpleError in args("graphics::plot.default"): could not find function "graphics::plot.default">
> 
> ## As explained above, args() gives a function with empty body:
> list(is.f = is.function(args(scan)), body = body(args(scan)))
$is.f
[1] TRUE

$body
NULL

> 
> ## Primitive functions mostly behave like non-primitive functions.
> args(c)
function (...) 
NULL
> args(`+`)
function (e1, e2) 
NULL
> ## primitive functions without well-defined argument list return NULL:
> args(`if`)
NULL
> 
> 
> 
> cleanEx()
> nameEx("array")
> ### * array
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: array
> ### Title: Multi-way Arrays
> ### Aliases: array as.array as.array.default is.array
> ### Keywords: array
> 
> ### ** Examples
> 
> dim(as.array(letters))
[1] 26
> array(1:3, c(2,4)) # recycle 1:3 "2 2/3 times"
     [,1] [,2] [,3] [,4]
[1,]    1    3    2    1
[2,]    2    1    3    2
> #     [,1] [,2] [,3] [,4]
> #[1,]    1    3    2    1
> #[2,]    2    1    3    2
> 
> 
> 
> cleanEx()
> nameEx("as.Date")
> ### * as.Date
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.Date
> ### Title: Date Conversion Functions to and from Character
> ### Aliases: format.Date as.character.Date as.Date as.Date.character
> ###   as.Date.default as.Date.factor as.Date.POSIXct as.Date.POSIXlt
> ###   as.Date.date as.Date.dates as.Date.numeric
> ### Keywords: utilities chron
> 
> ### ** Examples
> 
> ## read in date info in format 'ddmmmyyyy'
> ## This will give NA(s) in some locales; setting the C locale
> ## as in the commented lines will overcome this on most systems.
> ## lct <- Sys.getlocale("LC_TIME"); Sys.setlocale("LC_TIME", "C")
> x <- c("1jan1960", "2jan1960", "31mar1960", "30jul1960")
> z <- as.Date(x, "%d%b%Y")
> ## Sys.setlocale("LC_TIME", lct)
> z
[1] "1960-01-01" "1960-01-02" "1960-03-31" "1960-07-30"
> 
> ## read in date/time info in format 'm/d/y'
> dates <- c("02/27/92", "02/27/92", "01/14/92", "02/28/92", "02/01/92")
> as.Date(dates, "%m/%d/%y")
[1] "1992-02-27" "1992-02-27" "1992-01-14" "1992-02-28" "1992-02-01"
> 
> ## date given as number of days since 1900-01-01 (a date in 1989)
> as.Date(32768, origin = "1900-01-01")
[1] "1989-09-19"
> ## Excel is said to use 1900-01-01 as day 1 (Windows default) or
> ## 1904-01-01 as day 0 (Mac default), but this is complicated by Excel
> ## incorrectly treating 1900 as a leap year.
> ## So for dates (post-1901) from Windows Excel
> as.Date(35981, origin = "1899-12-30") # 1998-07-05
[1] "1998-07-05"
> ## and Mac Excel
> as.Date(34519, origin = "1904-01-01") # 1998-07-05
[1] "1998-07-05"
> ## (these values come from http://support.microsoft.com/kb/214330)
> 
> ## Experiment shows that Matlab's origin is 719529 days before ours,
> ## (it takes the non-existent 0000-01-01 as day 1)
> ## so Matlab day 734373 can be imported as
> as.Date(734373, origin = "1970-01-01") - 719529 # 2010-08-23
[1] "2010-08-23"
> ## (value from
> ## http://www.mathworks.de/de/help/matlab/matlab_prog/represent-date-and-times-in-MATLAB.html)
> 
> ## Time zone effect
> z <- ISOdate(2010, 04, 13, c(0,12)) # midnight and midday UTC
> as.Date(z) # in UTC
[1] "2010-04-13" "2010-04-13"
> 
> 
> 
> cleanEx()
> nameEx("as.POSIXlt")
> ### * as.POSIXlt
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.POSIX*
> ### Title: Date-time Conversion Functions
> ### Aliases: as.POSIXct as.POSIXct.default as.POSIXct.POSIXlt
> ###   as.POSIXct.date as.POSIXct.dates as.POSIXct.Date as.POSIXct.numeric
> ###   as.POSIXlt as.POSIXlt.Date as.POSIXlt.date as.POSIXlt.dates
> ###   as.POSIXlt.POSIXct as.POSIXlt.factor as.POSIXlt.character
> ###   as.POSIXlt.default as.POSIXlt.numeric as.double.POSIXlt
> ### Keywords: utilities chron
> 
> ### ** Examples
> 
> 
> cleanEx()
> nameEx("as.environment")
> ### * as.environment
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.environment
> ### Title: Coerce to an Environment Object
> ### Aliases: as.environment
> ### Keywords: data environment
> 
> ### ** Examples
> 
> as.environment(1) ## the global environment
<environment: R_GlobalEnv>
> identical(globalenv(), as.environment(1)) ## is TRUE
[1] TRUE
> try( ## <<- stats need not be attached
+     as.environment("package:stats"))
<environment: package:stats>
attr(,"name")
[1] "package:stats"
attr(,"path")
[1] "/usr/local/lib/R/library/stats"
> ee <- as.environment(list(a = "A", b = pi, ch = letters[1:8]))
> ls(ee) # names of objects in ee
[1] "a"  "b"  "ch"
> utils::ls.str(ee)
a :  chr "A"
b :  num 3.14
ch :  chr [1:8] "a" "b" "c" "d" "e" "f" "g" "h"
> 
> 
> 
> cleanEx()
> nameEx("as.function")
> ### * as.function
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.function
> ### Title: Convert Object to Function
> ### Aliases: as.function as.function.default
> ### Keywords: programming
> 
> ### ** Examples
> 
> as.function(alist(a = , b = 2, a+b))
function (a, b = 2) 
a + b
> as.function(alist(a = , b = 2, a+b))(3)
[1] 5
> 
> 
> 
> cleanEx()
> nameEx("asplit")
> ### * asplit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: asplit
> ### Title: Split Array/Matrix By Its Margins
> ### Aliases: asplit
> ### Keywords: array
> 
> ### ** Examples
> 
> ## A 3-dimensional array of dimension 2 x 3 x 4:
> d <- 2 : 4
> x <- array(seq_len(prod(d)), d)
> x
, , 1

     [,1] [,2] [,3]
[1,]    1    3    5
[2,]    2    4    6

, , 2

     [,1] [,2] [,3]
[1,]    7    9   11
[2,]    8   10   12

, , 3

     [,1] [,2] [,3]
[1,]   13   15   17
[2,]   14   16   18

, , 4

     [,1] [,2] [,3]
[1,]   19   21   23
[2,]   20   22   24

> ## Splitting by margin 2 gives a 1-d list array of length 3
> ## consisting of 2 x 4 arrays:
> asplit(x, 2)
[[1]]
     [,1] [,2] [,3] [,4]
[1,]    1    7   13   19
[2,]    2    8   14   20

[[2]]
     [,1] [,2] [,3] [,4]
[1,]    3    9   15   21
[2,]    4   10   16   22

[[3]]
     [,1] [,2] [,3] [,4]
[1,]    5   11   17   23
[2,]    6   12   18   24

> ## Spltting by margins 1 and 2 gives a 2 x 3 list array
> ## consisting of 1-d arrays of length 4:a
> asplit(x, c(1, 2))
     [,1]      [,2]      [,3]     
[1,] Integer,4 Integer,4 Integer,4
[2,] Integer,4 Integer,4 Integer,4
> ## Compare to
> split(x, slice.index(x, c(1, 2)))
$`1`
[1]  1  7 13 19

$`2`
[1]  2  8 14 20

$`3`
[1]  3  9 15 21

$`4`
[1]  4 10 16 22

$`5`
[1]  5 11 17 23

$`6`
[1]  6 12 18 24

> 
> ## A 2 x 3 matrix:
> (x <- matrix(1 : 6, 2, 3))
     [,1] [,2] [,3]
[1,]    1    3    5
[2,]    2    4    6
> ## To split x by its rows, one can use
> asplit(x, 1)
[[1]]
[1] 1 3 5

[[2]]
[1] 2 4 6

> ## or less efficiently
> split(x, slice.index(x, 1))
$`1`
[1] 1 3 5

$`2`
[1] 2 4 6

> split(x, row(x))
$`1`
[1] 1 3 5

$`2`
[1] 2 4 6

> 
> 
> 
> cleanEx()
> nameEx("assign")
> ### * assign
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: assign
> ### Title: Assign a Value to a Name
> ### Aliases: assign
> ### Keywords: data
> 
> ### ** Examples
> 
> for(i in 1:6) { #-- Create objects  'r.1', 'r.2', ... 'r.6' --
+     nam <- paste("r", i, sep = ".")
+     assign(nam, 1:i)
+ }
> ls(pattern = "^r..$")
[1] "r.1" "r.2" "r.3" "r.4" "r.5" "r.6"
> 
> ##-- Global assignment within a function:
> myf <- function(x) {
+     innerf <- function(x) assign("Global.res", x^2, envir = .GlobalEnv)
+     innerf(x+1)
+ }
> myf(3)
> Global.res # 16
[1] 16
> 
> a <- 1:4
> assign("a[1]", 2)
> a[1] == 2          # FALSE
[1] FALSE
> get("a[1]") == 2   # TRUE
[1] TRUE
> 
> 
> 
> 
> cleanEx()
> nameEx("attach")
> ### * attach
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: attach
> ### Title: Attach Set of R Objects to Search Path
> ### Aliases: attach .conflicts.OK
> ### Keywords: data
> 
> ### ** Examples
> 
> require(utils)
> 
> summary(women$height)   # refers to variable 'height' in the data frame
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
   58.0    61.5    65.0    65.0    68.5    72.0 
> attach(women)
> summary(height)         # The same variable now available by name
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
   58.0    61.5    65.0    65.0    68.5    72.0 
> height <- height*2.54   # Don't do this. It creates a new variable
>                         # in the user's workspace
> find("height")
[1] ".GlobalEnv" "women"     
> summary(height)         # The new variable in the workspace
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
  147.3   156.2   165.1   165.1   174.0   182.9 
> rm(height)
> summary(height)         # The original variable.
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
   58.0    61.5    65.0    65.0    68.5    72.0 
> height <<- height*25.4  # Change the copy in the attached environment
> find("height")
[1] "women"
> summary(height)         # The changed copy
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
   1473    1562    1651    1651    1740    1829 
> detach("women")
> summary(women$height)   # unchanged
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
   58.0    61.5    65.0    65.0    68.5    72.0 
> 
> ## Not run: 
> ##D ## create an environment on the search path and populate it
> ##D sys.source("myfuns.R", envir = attach(NULL, name = "myfuns"))
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("attr")
> ### * attr
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: attr
> ### Title: Object Attributes
> ### Aliases: attr attr<-
> ### Keywords: attribute
> 
> ### ** Examples
> 
> # create a 2 by 5 matrix
> x <- 1:10
> attr(x,"dim") <- c(2, 5)
> 
> 
> 
> cleanEx()
> nameEx("attributes")
> ### * attributes
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: attributes
> ### Title: Object Attribute Lists
> ### Aliases: attributes attributes<- mostattributes<-
> ### Keywords: attribute
> 
> ### ** Examples
> 
> x <- cbind(a = 1:3, pi = pi) # simple matrix with dimnames
> attributes(x)
$dim
[1] 3 2

$dimnames
$dimnames[[1]]
NULL

$dimnames[[2]]
[1] "a"  "pi"


> 
> ## strip an object's attributes:
> attributes(x) <- NULL
> x # now just a vector of length 6
[1] 1.000000 2.000000 3.000000 3.141593 3.141593 3.141593
> 
> mostattributes(x) <- list(mycomment = "really special", dim = 3:2,
+    dimnames = list(LETTERS[1:3], letters[1:5]), names = paste(1:6))
> x # dim(), but not {dim}names
     [,1]     [,2]
[1,]    1 3.141593
[2,]    2 3.141593
[3,]    3 3.141593
attr(,"mycomment")
[1] "really special"
> 
> 
> 
> cleanEx()
> nameEx("autoload")
> ### * autoload
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: autoload
> ### Title: On-demand Loading of Packages
> ### Aliases: autoload autoloader .AutoloadEnv .Autoloaded Autoloads
> ### Keywords: data programming
> 
> ### ** Examples
> 
> require(stats)
> autoload("interpSpline", "splines")
> search()
 [1] ".GlobalEnv"        "CheckExEnv"        "package:stats"    
 [4] "package:graphics"  "package:grDevices" "package:utils"    
 [7] "package:datasets"  "package:methods"   "Autoloads"        
[10] "package:base"     
> ls("Autoloads")
[1] "interpSpline"
> .Autoloaded
[1] "splines"
> 
> x <- sort(stats::rnorm(12))
> y <- x^2
> is <- interpSpline(x, y)
> search() ## now has splines
 [1] ".GlobalEnv"        "package:splines"   "CheckExEnv"       
 [4] "package:stats"     "package:graphics"  "package:grDevices"
 [7] "package:utils"     "package:datasets"  "package:methods"  
[10] "Autoloads"         "package:base"     
> detach("package:splines")
> search()
 [1] ".GlobalEnv"        "CheckExEnv"        "package:stats"    
 [4] "package:graphics"  "package:grDevices" "package:utils"    
 [7] "package:datasets"  "package:methods"   "Autoloads"        
[10] "package:base"     
> is2 <- interpSpline(x, y+x)
> search() ## and again
 [1] ".GlobalEnv"        "package:splines"   "CheckExEnv"       
 [4] "package:stats"     "package:graphics"  "package:grDevices"
 [7] "package:utils"     "package:datasets"  "package:methods"  
[10] "Autoloads"         "package:base"     
> detach("package:splines")
> 
> 
> 
> cleanEx()
> nameEx("backsolve")
> ### * backsolve
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: backsolve
> ### Title: Solve an Upper or Lower Triangular System
> ### Aliases: backsolve forwardsolve
> ### Keywords: algebra array
> 
> ### ** Examples
> 
> ## upper triangular matrix 'r':
> r <- rbind(c(1,2,3),
+            c(0,1,1),
+            c(0,0,2))
> ( y <- backsolve(r, x <- c(8,4,2)) ) # -1 3 1
[1] -1  3  1
> r %*% y # == x = (8,4,2)
     [,1]
[1,]    8
[2,]    4
[3,]    2
> backsolve(r, x, transpose = TRUE) # 8 -12 -5
[1]   8 -12  -5
> 
> 
> 
> cleanEx()
> nameEx("basename")
> ### * basename
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: basename
> ### Title: Manipulate File Paths
> ### Aliases: basename dirname
> ### Keywords: file
> 
> ### ** Examples
> 
> basename(file.path("","p1","p2","p3", c("file1", "file2")))
[1] "file1" "file2"
> dirname(file.path("","p1","p2","p3","filename"))
[1] "/p1/p2/p3"
> 
> 
> 
> cleanEx()
> nameEx("bincode")
> ### * bincode
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: .bincode
> ### Title: Bin a Numeric Vector
> ### Aliases: .bincode
> ### Keywords: category
> 
> ### ** Examples
> 
> ## An example with non-unique breaks:
> x <- c(0, 0.01, 0.5, 0.99, 1)
> b <- c(0, 0, 1, 1)
> .bincode(x, b, TRUE)
[1] NA  2  2  2  2
> .bincode(x, b, FALSE)
[1]  2  2  2  2 NA
> .bincode(x, b, TRUE, TRUE)
[1] 1 2 2 2 2
> .bincode(x, b, FALSE, TRUE)
[1] 2 2 2 2 3
> 
> 
> 
> cleanEx()
> nameEx("bindenv")
> ### * bindenv
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bindenv
> ### Title: Binding and Environment Locking, Active Bindings
> ### Aliases: bindenv lockEnvironment environmentIsLocked lockBinding
> ###   unlockBinding makeActiveBinding bindingIsLocked bindingIsActive
> ###   activeBindingFunction
> ### Keywords: utilities
> 
> ### ** Examples
> 
> # locking environments
> e <- new.env()
> assign("x", 1, envir = e)
> get("x", envir = e)
[1] 1
> lockEnvironment(e)
> get("x", envir = e)
[1] 1
> assign("x", 2, envir = e)
> try(assign("y", 2, envir = e)) # error
Error in assign("y", 2, envir = e) : 
  cannot add bindings to a locked environment
> 
> # locking bindings
> e <- new.env()
> assign("x", 1, envir = e)
> get("x", envir = e)
[1] 1
> lockBinding("x", e)
> try(assign("x", 2, envir = e)) # error
Error in assign("x", 2, envir = e) : 
  cannot change value of locked binding for 'x'
> unlockBinding("x", e)
> assign("x", 2, envir = e)
> get("x", envir = e)
[1] 2
> 
> # active bindings
> f <- local( {
+     x <- 1
+     function(v) {
+        if (missing(v))
+            cat("get\n")
+        else {
+            cat("set\n")
+            x <<- v
+        }
+        x
+     }
+ })
> makeActiveBinding("fred", f, .GlobalEnv)
> bindingIsActive("fred", .GlobalEnv)
[1] TRUE
> fred
get
[1] 1
> fred <- 2
set
> fred
get
[1] 2
> 
> 
> 
> cleanEx()
> nameEx("bitwise")
> ### * bitwise
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bitwise
> ### Title: Bitwise Logical Operations
> ### Aliases: bitwNot bitwAnd bitwOr bitwXor bitwShiftL bitwShiftR
> ### Keywords: logic
> 
> ### ** Examples
> 
> bitwNot(0:12) # -1 -2  ... -13
 [1]  -1  -2  -3  -4  -5  -6  -7  -8  -9 -10 -11 -12 -13
> bitwAnd(15L, 7L) #  7
[1] 7
> bitwOr (15L, 7L) # 15
[1] 15
> bitwXor(15L, 7L) #  8
[1] 8
> bitwXor(-1L, 1L) # -2
[1] -2
> 
> ## The "same" for 'raw' instead of integer :
> rr12 <- as.raw(0:12) ; rbind(rr12, !rr12)
     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13]
rr12   00   01   02   03   04   05   06   07   08    09    0a    0b    0c
       ff   fe   fd   fc   fb   fa   f9   f8   f7    f6    f5    f4    f3
> c(r15 <- as.raw(15), r7 <- as.raw(7)) #  0f 07
[1] 0f 07
> r15 & r7    # 07
[1] 07
> r15 | r7    # 0f
[1] 0f
> xor(r15, r7)# 08
[1] 08
> 
> bitwShiftR(-1, 1:31) # shifts of 2^32-1 = 4294967295
 [1] 2147483647 1073741823  536870911  268435455  134217727   67108863
 [7]   33554431   16777215    8388607    4194303    2097151    1048575
[13]     524287     262143     131071      65535      32767      16383
[19]       8191       4095       2047       1023        511        255
[25]        127         63         31         15          7          3
[31]          1
> 
> 
> 
> cleanEx()
> nameEx("body")
> ### * body
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: body
> ### Title: Access to and Manipulation of the Body of a Function
> ### Aliases: body body<-
> ### Keywords: programming
> 
> ### ** Examples
> 
> body(body)
{
    if (is.character(fun)) 
        fun <- get(fun, mode = "function", envir = parent.frame())
    .Internal(body(fun))
}
> f <- function(x) x^5
> body(f) <- quote(5^x)
> ## or equivalently  body(f) <- expression(5^x)
> f(3) # = 125
[1] 125
> body(f)
5^x
> 
> ## creating a multi-expression body
> e <- expression(y <- x^2, return(y)) # or a list
> body(f) <- as.call(c(as.name("{"), e))
> f
function (x) 
{
    y <- x^2
    return(y)
}
> f(8)
[1] 64
> ## Using substitute() may be simpler than 'as.call(c(as.name("{",..)))':
> stopifnot(identical(body(f), substitute({ y <- x^2; return(y) })))
> 
> 
> 
> cleanEx()
> nameEx("bquote")
> ### * bquote
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bquote
> ### Title: Partial substitution in expressions
> ### Aliases: bquote
> ### Keywords: programming data
> 
> ### ** Examples
> 
> require(graphics)
> 
> a <- 2
> 
> bquote(a == a)
a == a
> quote(a == a)
a == a
> 
> bquote(a == .(a))
a == 2
> substitute(a == A, list(A = a))
a == 2
> 
> plot(1:10, a*(1:10), main = bquote(a == .(a)))
> 
> ## to set a function default arg
> default <- 1
> bquote( function(x, y = .(default)) x+y )
function(x, y = 1) x + y
> 
> exprs <- expression(x <- 1, y <- 2, x + y)
> bquote(function() {..(exprs)}, splice = TRUE)
function() {
    x <- 1
    y <- 2
    x + y
}
> 
> 
> 
> cleanEx()
> nameEx("by")
> ### * by
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: by
> ### Title: Apply a Function to a Data Frame Split by Factors
> ### Aliases: by by.default by.data.frame print.by
> ### Keywords: iteration category
> 
> ### ** Examples
> 
> require(stats)
> by(warpbreaks[, 1:2], warpbreaks[,"tension"], summary)
warpbreaks[, "tension"]: L
     breaks      wool 
 Min.   :14.00   A:9  
 1st Qu.:26.00   B:9  
 Median :29.50        
 Mean   :36.39        
 3rd Qu.:49.25        
 Max.   :70.00        
------------------------------------------------------------ 
warpbreaks[, "tension"]: M
     breaks      wool 
 Min.   :12.00   A:9  
 1st Qu.:18.25   B:9  
 Median :27.00        
 Mean   :26.39        
 3rd Qu.:33.75        
 Max.   :42.00        
------------------------------------------------------------ 
warpbreaks[, "tension"]: H
     breaks      wool 
 Min.   :10.00   A:9  
 1st Qu.:15.25   B:9  
 Median :20.50        
 Mean   :21.67        
 3rd Qu.:25.50        
 Max.   :43.00        
> by(warpbreaks[, 1],   warpbreaks[, -1],       summary)
wool: A
tension: L
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
  25.00   26.00   51.00   44.56   54.00   70.00 
------------------------------------------------------------ 
wool: B
tension: L
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
  14.00   20.00   29.00   28.22   31.00   44.00 
------------------------------------------------------------ 
wool: A
tension: M
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
     12      18      21      24      30      36 
------------------------------------------------------------ 
wool: B
tension: M
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
  16.00   21.00   28.00   28.78   39.00   42.00 
------------------------------------------------------------ 
wool: A
tension: H
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
  10.00   18.00   24.00   24.56   28.00   43.00 
------------------------------------------------------------ 
wool: B
tension: H
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
  13.00   15.00   17.00   18.78   21.00   28.00 
> by(warpbreaks, warpbreaks[,"tension"],
+    function(x) lm(breaks ~ wool, data = x))
warpbreaks[, "tension"]: L

Call:
lm(formula = breaks ~ wool, data = x)

Coefficients:
(Intercept)        woolB  
      44.56       -16.33  

------------------------------------------------------------ 
warpbreaks[, "tension"]: M

Call:
lm(formula = breaks ~ wool, data = x)

Coefficients:
(Intercept)        woolB  
     24.000        4.778  

------------------------------------------------------------ 
warpbreaks[, "tension"]: H

Call:
lm(formula = breaks ~ wool, data = x)

Coefficients:
(Intercept)        woolB  
     24.556       -5.778  

> 
> ## now suppose we want to extract the coefficients by group
> tmp <- with(warpbreaks,
+             by(warpbreaks, tension,
+                function(x) lm(breaks ~ wool, data = x)))
> sapply(tmp, coef)
                    L         M         H
(Intercept)  44.55556 24.000000 24.555556
woolB       -16.33333  4.777778 -5.777778
> 
> 
> 
> cleanEx()
> nameEx("c")
> ### * c
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: c
> ### Title: Combine Values into a Vector or List
> ### Aliases: c c.default
> ### Keywords: manip
> 
> ### ** Examples
> 
> c(1,7:9)
[1] 1 7 8 9
> c(1:5, 10.5, "next")
[1] "1"    "2"    "3"    "4"    "5"    "10.5" "next"
> 
> ## uses with a single argument to drop attributes
> x <- 1:4
> names(x) <- letters[1:4]
> x
a b c d 
1 2 3 4 
> c(x)          # has names
a b c d 
1 2 3 4 
> as.vector(x)  # no names
[1] 1 2 3 4
> dim(x) <- c(2,2)
> x
     [,1] [,2]
[1,]    1    3
[2,]    2    4
> c(x)
[1] 1 2 3 4
> as.vector(x)
[1] 1 2 3 4
> 
> ## append to a list:
> ll <- list(A = 1, c = "C")
> ## do *not* use
> c(ll, d = 1:3) # which is == c(ll, as.list(c(d = 1:3)))
$A
[1] 1

$c
[1] "C"

$d1
[1] 1

$d2
[1] 2

$d3
[1] 3

> ## but rather
> c(ll, d = list(1:3))  # c() combining two lists
$A
[1] 1

$c
[1] "C"

$d
[1] 1 2 3

> 
> c(list(A = c(B = 1)), recursive = TRUE)
A.B 
  1 
> 
> c(options(), recursive = TRUE)
$add.smooth
[1] TRUE

$bitmapType
[1] "cairo"

$browser
[1] "xdg-open"

$browserNLdisabled
[1] FALSE

$CBoundsCheck
[1] FALSE

$check.bounds
[1] FALSE

$citation.bibtex.max
[1] 1

$continue
[1] "+ "

$contrasts.unordered
[1] "contr.treatment"

$contrasts.ordered
[1] "contr.poly"

$defaultPackages1
[1] "datasets"

$defaultPackages2
[1] "utils"

$defaultPackages3
[1] "grDevices"

$defaultPackages4
[1] "graphics"

$defaultPackages5
[1] "stats"

$defaultPackages6
[1] "methods"

$demo.ask
[1] "default"

$deparse.cutoff
[1] 60

$device
function (file = if (onefile) "Rplots.pdf" else "Rplot%03d.pdf", 
    width, height, onefile, family, title, fonts, version, paper, 
    encoding, bg, fg, pointsize, pagecentre, colormodel, useDingbats, 
    useKerning, fillOddEven, compress) 
{
    initPSandPDFfonts()
    new <- list()
    if (!missing(width)) 
        new$width <- width
    if (!missing(height)) 
        new$height <- height
    if (!missing(onefile)) 
        new$onefile <- onefile
    if (!missing(title)) 
        new$title <- title
    if (!missing(fonts)) 
        new$fonts <- fonts
    if (!missing(version)) 
        new$version <- version
    if (!missing(paper)) 
        new$paper <- paper
    if (!missing(encoding)) 
        new$encoding <- encoding
    if (!missing(bg)) 
        new$bg <- bg
    if (!missing(fg)) 
        new$fg <- fg
    if (!missing(pointsize)) 
        new$pointsize <- pointsize
    if (!missing(pagecentre)) 
        new$pagecentre <- pagecentre
    if (!missing(colormodel)) 
        new$colormodel <- colormodel
    if (!missing(useDingbats)) 
        new$useDingbats <- useDingbats
    if (!missing(useKerning)) 
        new$useKerning <- useKerning
    if (!missing(fillOddEven)) 
        new$fillOddEven <- fillOddEven
    if (!missing(compress)) 
        new$compress <- compress
    old <- check.options(new, name.opt = ".PDF.Options", envir = .PSenv)
    if (!missing(family) && (inherits(family, "Type1Font") || 
        inherits(family, "CIDFont"))) {
        enc <- family$encoding
        if (inherits(family, "Type1Font") && !is.null(enc) && 
            enc != "default" && (is.null(old$encoding) || old$encoding == 
            "default")) 
            old$encoding <- enc
        family <- family$metrics
    }
    if (is.null(old$encoding) || old$encoding == "default") 
        old$encoding <- guessEncoding()
    if (!missing(family)) {
        if (length(family) == 4L) {
            family <- c(family, "Symbol.afm")
        }
        else if (length(family) == 5L) {
        }
        else if (length(family) == 1L) {
            pf <- pdfFonts(family)[[1L]]
            if (is.null(pf)) 
                stop(gettextf("unknown family '%s'", family), 
                  domain = NA)
            matchFont(pf, old$encoding)
        }
        else stop("invalid 'family' argument")
        old$family <- family
    }
    version <- old$version
    versions <- c("1.1", "1.2", "1.3", "1.4", "1.5", "1.6", "1.7", 
        "2.0")
    if (version %in% versions) 
        version <- as.integer(strsplit(version, "[.]")[[1L]])
    else stop("invalid PDF version")
    onefile <- old$onefile
    if (!checkIntFormat(file)) 
        stop(gettextf("invalid 'file' argument '%s'", file), 
            domain = NA)
    .External(C_PDF, file, old$paper, old$family, old$encoding, 
        old$bg, old$fg, old$width, old$height, old$pointsize, 
        onefile, old$pagecentre, old$title, old$fonts, version[1L], 
        version[2L], old$colormodel, old$useDingbats, old$useKerning, 
        old$fillOddEven, old$compress)
    invisible()
}
<bytecode: 0x55b753302f00>
<environment: namespace:grDevices>

$device.ask.default
[1] FALSE

$digits
[1] 7

$dvipscmd
[1] "dvips"

$echo
[1] TRUE

$editor
[1] "vi"

$encoding
[1] "native.enc"

$example.ask
[1] "default"

$expressions
[1] 5000

$help.search.types1
[1] "vignette"

$help.search.types2
[1] "demo"

$help.search.types3
[1] "help"

$help.try.all.packages
[1] FALSE

$HTTPUserAgent
[1] "R (4.0.3 x86_64-pc-linux-gnu x86_64 linux-gnu)"

$internet.info
[1] 2

$keep.parse.data
[1] TRUE

$keep.parse.data.pkgs
[1] FALSE

$keep.source
[1] FALSE

$keep.source.pkgs
[1] FALSE

$locatorBell
[1] TRUE

$mailer
[1] "mailto"

$matprod
[1] "default"

$max.print
[1] 99999

$menu.graphics
[1] TRUE

$na.action
[1] "na.omit"

$nwarnings
[1] 50

$OutDec
[1] "."

$pager
[1] "/usr/local/lib/R/bin/pager"

$papersize
[1] "letter"

$PCRE_limit_recursion
[1] NA

$PCRE_study
[1] FALSE

$PCRE_use_JIT
[1] TRUE

$pdfviewer
[1] "/usr/bin/xdg-open"

$pkgType
[1] "source"

$printcmd
[1] "/usr/bin/lpr"

$prompt
[1] "> "

$repos.CRAN
[1] "@CRAN@"

$rl_word_breaks
[1] " \t\n\"\\'`><=%;,|&{()}"

$scipen
[1] 0

$show.coef.Pvalues
[1] TRUE

$show.error.messages
[1] TRUE

$show.signif.stars
[1] TRUE

$showErrorCalls
[1] TRUE

$str.strict.width
[1] "no"

$str.digits.d
[1] 3

$str.vec.len
[1] 4

$str.list.len
[1] 99

$str.drop.deparse.attr
[1] TRUE

$str.formatNum
function (x, ...) 
format(x, trim = TRUE, drop0trailing = TRUE, ...)
<environment: 0x55b753e8c2e0>

$str.dendrogram.last
[1] "`"

$stringsAsFactors
[1] FALSE

$texi2dvi
[1] "/usr/bin/texi2dvi"

$timeout
[1] 60

$ts.eps
[1] 1e-05

$ts.S.compat
[1] FALSE

$unzip
[1] "/usr/bin/unzip"

$useFancyQuotes
[1] TRUE

$verbose
[1] FALSE

$warn
[1] 1

$warning.length
[1] 1000

$warnPartialMatchDollar
[1] FALSE

$width
[1] 80

> c(list(A = c(B = 1, C = 2), B = c(E = 7)), recursive = TRUE)
A.B A.C B.E 
  1   2   7 
> 
> 
> 
> cleanEx()
> nameEx("call")
> ### * call
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: call
> ### Title: Function Calls
> ### Aliases: call is.call as.call
> ### Keywords: programming attribute
> 
> ### ** Examples
> 
> is.call(call) #-> FALSE: Functions are NOT calls
[1] FALSE
> 
> ## set up a function call to round with argument 10.5
> cl <- call("round", 10.5)
> is.call(cl) # TRUE
[1] TRUE
> cl
round(10.5)
> identical(quote(round(10.5)), # <- less functional, but the same
+           cl) # TRUE
[1] TRUE
> ## such a call can also be evaluated.
> eval(cl) # [1] 10
[1] 10
> 
> class(cl) # "call"
[1] "call"
> typeof(cl)# "language"
[1] "language"
> is.call(cl) && is.language(cl) # always TRUE for "call"s
[1] TRUE
> 
> A <- 10.5
> call("round", A)        # round(10.5)
round(10.5)
> call("round", quote(A)) # round(A)
round(A)
> f <- "round"
> call(f, quote(A))       # round(A)
round(A)
> ## if we want to supply a function we need to use as.call or similar
> f <- round
> ## Not run: call(f, quote(A))  # error: first arg must be character
> (g <- as.call(list(f, quote(A))))
.Primitive("round")(A)
> eval(g)
[1] 10
> ## alternatively but less transparently
> g <- list(f, quote(A))
> mode(g) <- "call"
> g
.Primitive("round")(A)
> eval(g)
[1] 10
> ## see also the examples in the help for do.call
> 
> 
> 
> cleanEx()
> nameEx("callCC")
> ### * callCC
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: callCC
> ### Title: Call With Current Continuation
> ### Aliases: callCC
> ### Keywords: programming
> 
> ### ** Examples
> 
> # The following all return the value 1
> callCC(function(k) 1)
[1] 1
> callCC(function(k) k(1))
[1] 1
> callCC(function(k) {k(1); 2})
[1] 1
> callCC(function(k) repeat k(1))
[1] 1
> 
> 
> 
> cleanEx()
> nameEx("capabilities")
> ### * capabilities
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: capabilities
> ### Title: Report Capabilities of this Build of R
> ### Aliases: capabilities
> ### Keywords: utilities
> 
> ### ** Examples
> 
> capabilities()
       jpeg         png        tiff       tcltk         X11        aqua 
       TRUE        TRUE        TRUE        TRUE       FALSE       FALSE 
   http/ftp     sockets      libxml        fifo      cledit       iconv 
       TRUE        TRUE        TRUE        TRUE       FALSE        TRUE 
        NLS     profmem       cairo         ICU long.double     libcurl 
      FALSE        TRUE        TRUE        TRUE        TRUE        TRUE 
> 
> if(!capabilities("ICU"))
+    warning("ICU is not available")
> 
> ## Does not call the internal X11-checking function:
> capabilities(Xchk = FALSE)
       jpeg         png        tiff       tcltk         X11        aqua 
       TRUE        TRUE        TRUE        TRUE          NA       FALSE 
   http/ftp     sockets      libxml        fifo      cledit       iconv 
       TRUE        TRUE        TRUE        TRUE       FALSE        TRUE 
        NLS     profmem       cairo         ICU long.double     libcurl 
      FALSE        TRUE        TRUE        TRUE        TRUE        TRUE 
> 
> ## See also the examples for 'connections'.
> 
> 
> 
> cleanEx()
> nameEx("cat")
> ### * cat
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cat
> ### Title: Concatenate and Print
> ### Aliases: cat
> ### Keywords: print file connection
> 
> ### ** Examples
> 
> iter <- stats::rpois(1, lambda = 10)
> ## print an informative message
> cat("iteration = ", iter <- iter + 1, "\n")
iteration =  9 
> 
> ## 'fill' and label lines:
> cat(paste(letters, 100* 1:26), fill = TRUE, labels = paste0("{", 1:10, "}:"))
{1}: a 100 b 200 c 300 d 400 e 500 f 600 g 700 h 800 i 900 j 1000 k 1100 l 1200 
{2}: m 1300 n 1400 o 1500 p 1600 q 1700 r 1800 s 1900 t 2000 u 2100 v 2200 
{3}: w 2300 x 2400 y 2500 z 2600
> 
> 
> 
> cleanEx()
> nameEx("cbind")
> ### * cbind
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cbind
> ### Title: Combine R Objects by Rows or Columns
> ### Aliases: cbind rbind cbind.data.frame rbind.data.frame .__H__.cbind
> ###   .__H__.rbind
> ### Keywords: array manip
> 
> ### ** Examples
> 
> m <- cbind(1, 1:7) # the '1' (= shorter vector) is recycled
> m
     [,1] [,2]
[1,]    1    1
[2,]    1    2
[3,]    1    3
[4,]    1    4
[5,]    1    5
[6,]    1    6
[7,]    1    7
> m <- cbind(m, 8:14)[, c(1, 3, 2)] # insert a column
> m
     [,1] [,2] [,3]
[1,]    1    8    1
[2,]    1    9    2
[3,]    1   10    3
[4,]    1   11    4
[5,]    1   12    5
[6,]    1   13    6
[7,]    1   14    7
> cbind(1:7, diag(3)) # vector is subset -> warning
Warning in cbind(1:7, diag(3)) :
  number of rows of result is not a multiple of vector length (arg 1)
     [,1] [,2] [,3] [,4]
[1,]    1    1    0    0
[2,]    2    0    1    0
[3,]    3    0    0    1
> 
> cbind(0, rbind(1, 1:3))
     [,1] [,2] [,3] [,4]
[1,]    0    1    1    1
[2,]    0    1    2    3
> cbind(I = 0, X = rbind(a = 1, b = 1:3))  # use some names
  I      
a 0 1 1 1
b 0 1 2 3
> xx <- data.frame(I = rep(0,2))
> cbind(xx, X = rbind(a = 1, b = 1:3))   # named differently
  I X.1 X.2 X.3
a 0   1   1   1
b 0   1   2   3
> 
> cbind(0, matrix(1, nrow = 0, ncol = 4)) #> Warning (making sense)
Warning in cbind(0, matrix(1, nrow = 0, ncol = 4)) :
  number of rows of result is not a multiple of vector length (arg 1)
     [,1] [,2] [,3] [,4] [,5]
> dim(cbind(0, matrix(1, nrow = 2, ncol = 0))) #-> 2 x 1
[1] 2 1
> 
> ## deparse.level
> dd <- 10
> rbind(1:4, c = 2, "a++" = 10, dd, deparse.level = 0) # middle 2 rownames
    [,1] [,2] [,3] [,4]
       1    2    3    4
c      2    2    2    2
a++   10   10   10   10
      10   10   10   10
> rbind(1:4, c = 2, "a++" = 10, dd, deparse.level = 1) # 3 rownames (default)
    [,1] [,2] [,3] [,4]
       1    2    3    4
c      2    2    2    2
a++   10   10   10   10
dd    10   10   10   10
> rbind(1:4, c = 2, "a++" = 10, dd, deparse.level = 2) # 4 rownames
    [,1] [,2] [,3] [,4]
1:4    1    2    3    4
c      2    2    2    2
a++   10   10   10   10
dd    10   10   10   10
> 
> ## cheap row names:
> b0 <- gl(3,4, labels=letters[1:3])
> bf <- setNames(b0, paste0("o", seq_along(b0)))
> df  <- data.frame(a = 1, B = b0, f = gl(4,3))
> df. <- data.frame(a = 1, B = bf, f = gl(4,3))
> new <- data.frame(a = 8, B ="B", f = "1")
> (df1  <- rbind(df , new))
   a B f
1  1 a 1
2  1 a 1
3  1 a 1
4  1 a 2
5  1 b 2
6  1 b 2
7  1 b 3
8  1 b 3
9  1 c 3
10 1 c 4
11 1 c 4
12 1 c 4
13 8 B 1
> (df.1 <- rbind(df., new))
    a B f
o1  1 a 1
o2  1 a 1
o3  1 a 1
o4  1 a 2
o5  1 b 2
o6  1 b 2
o7  1 b 3
o8  1 b 3
o9  1 c 3
o10 1 c 4
o11 1 c 4
o12 1 c 4
1   8 B 1
> stopifnot(identical(df1, rbind(df,  new, make.row.names=FALSE)),
+           identical(df1, rbind(df., new, make.row.names=FALSE)))
> ## Don't show: 
> ## Testing a semi-official use:
> d2 <- rbind.data.frame(as.list(df), as.list(new))
> d3 <- rbind.data.frame(as.list(df), as.list(new), make.row.names=FALSE)
> stopifnot(identical(.row_names_info(d3), -13L))
> ## no longer: attr(d2, "row.names")[c(1,13)] == c("13", "131")
> row.names(d2) <- attr(d3, "row.names")# = 1:13
> stopifnot(identical(d2, d3))
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("char.expand")
> ### * char.expand
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: char.expand
> ### Title: Expand a String with Respect to a Target Table
> ### Aliases: char.expand
> ### Keywords: character
> 
> ### ** Examples
> 
> locPars <- c("mean", "median", "mode")
> char.expand("me", locPars, warning("Could not expand!"))
character(0)
> char.expand("mo", locPars)
[1] "mode"
> 
> 
> 
> cleanEx()
> nameEx("character")
> ### * character
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: character
> ### Title: Character Vectors
> ### Aliases: character as.character as.character.default
> ###   as.character.factor is.character
> ### Keywords: character classes
> 
> ### ** Examples
> 
> form <- y ~ a + b + c
> as.character(form)  ## length 3
[1] "~"         "y"         "a + b + c"
> deparse(form)       ## like the input
[1] "y ~ a + b + c"
> 
> a0 <- 11/999          # has a repeating decimal representation
> (a1 <- as.character(a0))
[1] "0.011011011011011"
> format(a0, digits = 16) # shows one more digit
[1] "0.01101101101101101"
> a2 <- as.numeric(a1)
> a2 - a0               # normally around -1e-17
[1] -1.040834e-17
> as.character(a2)      # normally different from a1
[1] "0.011011011011011"
> print(c(a0, a2), digits = 16)
[1] 0.01101101101101101 0.01101101101101100
> 
> 
> 
> cleanEx()
> nameEx("charmatch")
> ### * charmatch
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: charmatch
> ### Title: Partial String Matching
> ### Aliases: charmatch
> ### Keywords: character
> 
> ### ** Examples
> 
> charmatch("", "")                             # returns 1
[1] 1
> charmatch("m",   c("mean", "median", "mode")) # returns 0
[1] 0
> charmatch("med", c("mean", "median", "mode")) # returns 2
[1] 2
> 
> 
> 
> cleanEx()
> nameEx("chartr")
> ### * chartr
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: chartr
> ### Title: Character Translation and Casefolding
> ### Aliases: chartr tolower toupper casefold
> ### Keywords: character
> 
> ### ** Examples
> 
> x <- "MiXeD cAsE 123"
> chartr("iXs", "why", x)
[1] "MwheD cAyE 123"
> chartr("a-cX", "D-Fw", x)
[1] "MiweD FAsE 123"
> tolower(x)
[1] "mixed case 123"
> toupper(x)
[1] "MIXED CASE 123"
> 
> ## "Mixed Case" Capitalizing - toupper( every first letter of a word ) :
> 
> .simpleCap <- function(x) {
+     s <- strsplit(x, " ")[[1]]
+     paste(toupper(substring(s, 1, 1)), substring(s, 2),
+           sep = "", collapse = " ")
+ }
> .simpleCap("the quick red fox jumps over the lazy brown dog")
[1] "The Quick Red Fox Jumps Over The Lazy Brown Dog"
> ## ->  [1] "The Quick Red Fox Jumps Over The Lazy Brown Dog"
> 
> ## and the better, more sophisticated version:
> capwords <- function(s, strict = FALSE) {
+     cap <- function(s) paste(toupper(substring(s, 1, 1)),
+                   {s <- substring(s, 2); if(strict) tolower(s) else s},
+                              sep = "", collapse = " " )
+     sapply(strsplit(s, split = " "), cap, USE.NAMES = !is.null(names(s)))
+ }
> capwords(c("using AIC for model selection"))
[1] "Using AIC For Model Selection"
> ## ->  [1] "Using AIC For Model Selection"
> capwords(c("using AIC", "for MODEL selection"), strict = TRUE)
[1] "Using Aic"           "For Model Selection"
> ## ->  [1] "Using Aic"  "For Model Selection"
> ##                ^^^        ^^^^^
> ##               'bad'       'good'
> 
> ## -- Very simple insecure crypto --
> rot <- function(ch, k = 13) {
+    p0 <- function(...) paste(c(...), collapse = "")
+    A <- c(letters, LETTERS, " '")
+    I <- seq_len(k); chartr(p0(A), p0(c(A[-I], A[I])), ch)
+ }
> 
> pw <- "my secret pass phrase"
> (crypw <- rot(pw, 13)) #-> you can send this off
[1] "zLlFrpErGlCnFFlCuEnFr"
> 
> ## now ``decrypt'' :
> rot(crypw, 54 - 13) # -> the original:
[1] "my secret pass phrase"
> stopifnot(identical(pw, rot(crypw, 54 - 13)))
> 
> 
> 
> cleanEx()
> nameEx("chkDots")
> ### * chkDots
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: chkDots
> ### Title: Warn About Extraneous Arguments in the "..." of Its Caller
> ### Aliases: chkDots
> ### Keywords: utilities
> 
> ### ** Examples
> 
> seq.default ## <- you will see  ' chkDots(...) '
function (from = 1, to = 1, by = ((to - from)/(length.out - 1)), 
    length.out = NULL, along.with = NULL, ...) 
{
    is.logint <- function(.) (is.integer(.) || is.logical(.)) && 
        !is.object(.)
    if ((One <- nargs() == 1L) && !missing(from)) {
        lf <- length(from)
        return(if (mode(from) == "numeric" && lf == 1L) {
            if (!is.finite(from)) stop("'from' must be a finite number")
            1L:from
        } else if (lf) 1L:lf else integer())
    }
    if (!missing(along.with)) {
        length.out <- length(along.with)
        if (One) 
            return(if (length.out) seq_len(length.out) else integer())
        intn1 <- is.integer(length.out)
    }
    else if (!missing(length.out)) {
        len <- length(length.out)
        if (!len) 
            stop("argument 'length.out' must be of length 1")
        if (len > 1L) {
            warning("first element used of 'length.out' argument")
            length.out <- length.out[1L]
        }
        if (!(intn1 <- is.logint(length.out))) 
            length.out <- as.numeric(ceiling(length.out))
    }
    chkDots(...)
    if (!missing(from) && length(from) != 1L) 
        stop("'from' must be of length 1")
    if (!missing(to) && length(to) != 1L) 
        stop("'to' must be of length 1")
    if (!missing(from) && !is.finite(if (is.character(from)) from <- as.numeric(from) else from)) 
        stop("'from' must be a finite number")
    if (!missing(to) && !is.finite(if (is.character(to)) to <- as.numeric(to) else to)) 
        stop("'to' must be a finite number")
    if (is.null(length.out)) 
        if (missing(by)) 
            from:to
        else {
            int <- is.logint(from) && is.logint(to)
            del <- to - if (int) 
                as.double(from)
            else from
            if (del == 0 && to == 0) 
                return(to)
            if (length(by) != 1L) 
                stop("'by' must be of length 1")
            if (!is.logint(by)) 
                int <- FALSE
            else if (!int) 
                storage.mode(by) <- "double"
            n <- del/by
            if (!is.finite(n)) {
                if (!is.na(by) && by == 0 && del == 0) 
                  return(from)
                stop("invalid '(to - from)/by'")
            }
            if (n < 0L) 
                stop("wrong sign in 'by' argument")
            if (n > .Machine$integer.max) 
                stop("'by' argument is much too small")
            dd <- abs(del)/max(abs(to), abs(from))
            if (dd < 100 * .Machine$double.eps) 
                return(from)
            if (int) {
                n <- as.integer(n)
                if (n >= 2L) 
                  cumsum(rep.int(c(from, by), c(1L, n)))
                else from + (0L:n) * by
            }
            else {
                n <- as.integer(n + 1e-10)
                x <- from + (0L:n) * by
                if (by > 0) 
                  pmin(x, to)
                else pmax(x, to)
            }
        }
    else if (!is.finite(length.out) || length.out < 0L) 
        stop("'length.out' must be a non-negative number")
    else if (length.out == 0L) 
        integer()
    else if (One) 
        seq_len(length.out)
    else if (missing(by)) {
        if (missing(to)) {
            to <- from + (length.out - 1)
            intdel <- intn1 && is.logint(from) && to <= .Machine$integer.max
            if (intdel) 
                storage.mode(to) <- "integer"
        }
        else intdel <- is.logint(to)
        if (missing(from)) {
            from <- to - (length.out - 1)
            if (intdel) {
                intdel <- intn1 && from >= -.Machine$integer.max
                if (intdel) 
                  storage.mode(from) <- "integer"
            }
        }
        else if (intdel) 
            intdel <- is.logint(from)
        if (length.out > 2L) 
            if (from == to) 
                rep.int(from, length.out)
            else {
                n1 <- length.out - 1L
                if (intdel && intn1 && from%%n1 == to%%n1) {
                  by <- to%/%n1 - from%/%n1
                  cumsum(rep.int(c(from, by), c(1L, n1)))
                }
                else {
                  if (intdel) 
                    storage.mode(from) <- "double"
                  by <- (to - from)/n1
                  as.vector(c(from, from + seq_len(length.out - 
                    2L) * by, to))
                }
            }
        else as.vector(c(from, to))[seq_len(length.out)]
    }
    else if (missing(to)) {
        int <- (intby <- is.logint(by)) && is.logint(from) && 
            (!(nby <- length(by)) || (naby <- is.na(by)) || ((to <- from + 
                (length.out - 1) * by) <= .Machine$integer.max && 
                to >= -.Machine$integer.max))
        if (int && length.out > 2L && nby == 1L && !naby) 
            cumsum(rep.int(c(from, by), c(1L, length.out - 1L)))
        else {
            if (intby && !(int || is.object(from))) 
                storage.mode(by) <- "double"
            from + (0L:(length.out - 1L)) * by
        }
    }
    else if (missing(from)) {
        int <- (intby <- is.logint(by)) && is.logint(to) && (!(nby <- length(by)) || 
            (naby <- is.na(by)) || ((from <- to - (length.out - 
            1) * by) >= -.Machine$integer.max && from <= .Machine$integer.max))
        if (int && length.out > 2L && nby == 1L && !naby) 
            cumsum(rep.int(c(as.integer(from), by), c(1L, length.out - 
                1L)))
        else {
            if (intby && !(int || is.object(to))) 
                storage.mode(by) <- "double"
            to - ((length.out - 1L):0L) * by
        }
    }
    else stop("too many arguments")
}
<bytecode: 0x55b752887f18>
<environment: namespace:base>
> 
> seq(1,5, foo = "bar") # gives warning via chkDots()
Warning: In seq.default(1, 5, foo = "bar") :
 extra argument ‘foo’ will be disregarded
[1] 1 2 3 4 5
> 
> ## warning with more than one ...-entry:
> density.f <- function(x, ...) NextMethod("density")
> x <- density(structure(rnorm(10), class="f"), bar=TRUE, baz=TRUE)
Warning: In density.default(structure(rnorm(10), class = "f"), bar = TRUE, 
    baz = TRUE) :
 extra arguments ‘bar’, ‘baz’ will be disregarded
> 
> 
> 
> cleanEx()
> nameEx("chol")
> ### * chol
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: chol
> ### Title: The Choleski Decomposition
> ### Aliases: chol chol.default
> ### Keywords: algebra array
> 
> ### ** Examples
> 
> ( m <- matrix(c(5,1,1,3),2,2) )
     [,1] [,2]
[1,]    5    1
[2,]    1    3
> ( cm <- chol(m) )
         [,1]      [,2]
[1,] 2.236068 0.4472136
[2,] 0.000000 1.6733201
> t(cm) %*% cm  #-- = 'm'
     [,1] [,2]
[1,]    5    1
[2,]    1    3
> crossprod(cm)  #-- = 'm'
     [,1] [,2]
[1,]    5    1
[2,]    1    3
> 
> # now for something positive semi-definite
> x <- matrix(c(1:5, (1:5)^2), 5, 2)
> x <- cbind(x, x[, 1] + 3*x[, 2])
> colnames(x) <- letters[20:22]
> m <- crossprod(x)
> qr(m)$rank # is 2, as it should be
[1] 2
> 
> # chol() may fail, depending on numerical rounding:
> # chol() unlike qr() does not use a tolerance.
> try(chol(m))
Error in chol.default(m) : 
  the leading minor of order 3 is not positive definite
> 
> (Q <- chol(m, pivot = TRUE))
Warning in chol.default(m, pivot = TRUE) :
  the matrix is either rank-deficient or indefinite
         v        t          u
t 101.0742 7.222415 31.2839385
u   0.0000 1.684259 -0.5614195
v   0.0000 0.000000  0.0000000
attr(,"pivot")
[1] 3 1 2
attr(,"rank")
[1] 2
> ## we can use this by
> pivot <- attr(Q, "pivot")
> crossprod(Q[, order(pivot)]) # recover m
    t    u     v
t  55  225   730
u 225  979  3162
v 730 3162 10216
> 
> ## now for a non-positive-definite matrix
> ( m <- matrix(c(5,-5,-5,3), 2, 2) )
     [,1] [,2]
[1,]    5   -5
[2,]   -5    3
> try(chol(m))  # fails
Error in chol.default(m) : 
  the leading minor of order 2 is not positive definite
> (Q <- chol(m, pivot = TRUE)) # warning
Warning in chol.default(m, pivot = TRUE) :
  the matrix is either rank-deficient or indefinite
         [,1]      [,2]
[1,] 2.236068 -2.236068
[2,] 0.000000 -2.000000
attr(,"pivot")
[1] 1 2
attr(,"rank")
[1] 1
> crossprod(Q)  # not equal to m
     [,1] [,2]
[1,]    5   -5
[2,]   -5    9
> 
> 
> 
> cleanEx()
> nameEx("chol2inv")
> ### * chol2inv
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: chol2inv
> ### Title: Inverse from Choleski (or QR) Decomposition
> ### Aliases: chol2inv
> ### Keywords: algebra array
> 
> ### ** Examples
> 
> cma <- chol(ma  <- cbind(1, 1:3, c(1,3,7)))
> ma %*% chol2inv(cma)
             [,1]         [,2]         [,3]
[1,] 1.000000e+00 0.000000e+00 0.000000e+00
[2,] 1.110223e-16 1.000000e+00 1.110223e-16
[3,] 1.110223e-16 6.661338e-16 1.000000e+00
> 
> 
> 
> cleanEx()
> nameEx("class")
> ### * class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: class
> ### Title: Object Classes
> ### Aliases: class .class2 class<- oldClass oldClass<- unclass inherits
> ### Keywords: methods classes
> 
> ### ** Examples
> 
> x <- 10
> class(x) # "numeric"
[1] "numeric"
> oldClass(x) # NULL
NULL
> inherits(x, "a") #FALSE
[1] FALSE
> class(x) <- c("a", "b")
> inherits(x,"a") #TRUE
[1] TRUE
> inherits(x, "a", TRUE) # 1
[1] 1
> inherits(x, c("a", "b", "c"), TRUE) # 1 2 0
[1] 1 2 0
> 
> class( quote(pi) )           # "name"
[1] "name"
> ## regular calls
> class( quote(sin(pi*x)) )    # "call"
[1] "call"
> ## special calls
> class( quote(x <- 1) )       # "<-"
[1] "<-"
> class( quote((1 < 2)) )      # "("
[1] "("
> class( quote( if(8<3) pi ) ) # "if"
[1] "if"
> 
> .class2(pi)               # "double" "numeric"
[1] "double"  "numeric"
> .class2(matrix(1:6, 2,3)) # "matrix" "array" "integer" "numeric"
[1] "matrix"  "array"   "integer" "numeric"
> 
> 
> 
> cleanEx()
> nameEx("col")
> ### * col
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: col
> ### Title: Column Indexes
> ### Aliases: col .col
> ### Keywords: array
> 
> ### ** Examples
> 
> # extract an off-diagonal of a matrix
> ma <- matrix(1:12, 3, 4)
> ma[row(ma) == col(ma) + 1]
[1] 2 6
> 
> # create an identity 5-by-5 matrix more slowly than diag(n = 5):
> x <- matrix(0, nrow = 5, ncol = 5)
> x[row(x) == col(x)] <- 1
> 
> (i34 <- .col(3:4))
     [,1] [,2] [,3] [,4]
[1,]    1    2    3    4
[2,]    1    2    3    4
[3,]    1    2    3    4
> stopifnot(identical(i34, .col(c(3,4)))) # 'dim' maybe "double"
> 
> 
> 
> cleanEx()
> nameEx("colSums")
> ### * colSums
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: colSums
> ### Title: Form Row and Column Sums and Means
> ### Aliases: colSums rowSums colMeans rowMeans .colSums .rowSums .colMeans
> ###   .rowMeans
> ### Keywords: array algebra arith
> 
> ### ** Examples
> 
> ## Compute row and column sums for a matrix:
> x <- cbind(x1 = 3, x2 = c(4:1, 2:5))
> rowSums(x); colSums(x)
[1] 7 6 5 4 5 6 7 8
x1 x2 
24 24 
> dimnames(x)[[1]] <- letters[1:8]
> rowSums(x); colSums(x); rowMeans(x); colMeans(x)
a b c d e f g h 
7 6 5 4 5 6 7 8 
x1 x2 
24 24 
  a   b   c   d   e   f   g   h 
3.5 3.0 2.5 2.0 2.5 3.0 3.5 4.0 
x1 x2 
 3  3 
> x[] <- as.integer(x)
> rowSums(x); colSums(x)
a b c d e f g h 
7 6 5 4 5 6 7 8 
x1 x2 
24 24 
> x[] <- x < 3
> rowSums(x); colSums(x)
a b c d e f g h 
0 0 1 1 1 0 0 0 
x1 x2 
 0  3 
> x <- cbind(x1 = 3, x2 = c(4:1, 2:5))
> x[3, ] <- NA; x[4, 2] <- NA
> rowSums(x); colSums(x); rowMeans(x); colMeans(x)
[1]  7  6 NA NA  5  6  7  8
x1 x2 
NA NA 
[1] 3.5 3.0  NA  NA 2.5 3.0 3.5 4.0
x1 x2 
NA NA 
> rowSums(x, na.rm = TRUE); colSums(x, na.rm = TRUE)
[1] 7 6 0 3 5 6 7 8
x1 x2 
21 21 
> rowMeans(x, na.rm = TRUE); colMeans(x, na.rm = TRUE)
[1] 3.5 3.0 NaN 3.0 2.5 3.0 3.5 4.0
 x1  x2 
3.0 3.5 
> 
> ## an array
> dim(UCBAdmissions)
[1] 2 2 6
> rowSums(UCBAdmissions); rowSums(UCBAdmissions, dims = 2)
Admitted Rejected 
    1755     2771 
          Gender
Admit      Male Female
  Admitted 1198    557
  Rejected 1493   1278
> colSums(UCBAdmissions); colSums(UCBAdmissions, dims = 2)
        Dept
Gender     A   B   C   D   E   F
  Male   825 560 325 417 191 373
  Female 108  25 593 375 393 341
  A   B   C   D   E   F 
933 585 918 792 584 714 
> 
> ## complex case
> x <- cbind(x1 = 3 + 2i, x2 = c(4:1, 2:5) - 5i)
> x[3, ] <- NA; x[4, 2] <- NA
> rowSums(x); colSums(x); rowMeans(x); colMeans(x)
[1] 7-3i 6-3i   NA   NA 5-3i 6-3i 7-3i 8-3i
x1 x2 
NA NA
[1] 3.5-1.5i 3.0-1.5i       NA       NA 2.5-1.5i 3.0-1.5i 3.5-1.5i 4.0-1.5i
x1 x2 
NA NA
> rowSums(x, na.rm = TRUE); colSums(x, na.rm = TRUE)
[1] 7-3i 6-3i 0+0i 3+2i 5-3i 6-3i 7-3i 8-3i
    x1     x2 
21+14i 21-30i
> rowMeans(x, na.rm = TRUE); colMeans(x, na.rm = TRUE)
[1] 3.5-1.5i 3.0-1.5i NaN+NaNi 3.0+2.0i 2.5-1.5i 3.0-1.5i 3.5-1.5i 4.0-1.5i
    x1     x2 
3.0+2i 3.5-5i
> 
> 
> 
> cleanEx()
> nameEx("colnames")
> ### * colnames
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: row+colnames
> ### Title: Row and Column Names
> ### Aliases: rownames rownames<- colnames colnames<-
> ### Keywords: array manip
> 
> ### ** Examples
> 
> m0 <- matrix(NA, 4, 0)
> rownames(m0)
NULL
> 
> m2 <- cbind(1, 1:4)
> colnames(m2, do.NULL = FALSE)
[1] "col1" "col2"
> colnames(m2) <- c("x","Y")
> rownames(m2) <- rownames(m2, do.NULL = FALSE, prefix = "Obs.")
> m2
      x Y
Obs.1 1 1
Obs.2 1 2
Obs.3 1 3
Obs.4 1 4
> 
> 
> 
> cleanEx()
> nameEx("commandArgs")
> ### * commandArgs
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: commandArgs
> ### Title: Extract Command Line Arguments
> ### Aliases: commandArgs
> ### Keywords: environment sysdata programming
> 
> ### ** Examples
> 
> commandArgs()
[1] "/usr/local/lib/R/bin/exec/R" "--no-save"                  
[3] "--no-restore"                "-f"                         
[5] "base-Ex.R"                   "--restore"                  
[7] "--save"                      "--no-readline"              
[9] "--vanilla"                  
> ## Spawn a copy of this application as it was invoked,
> ## subject to shell quoting issues
> ## system(paste(commandArgs(), collapse = " "))
> 
> 
> 
> cleanEx()
> nameEx("comment")
> ### * comment
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: comment
> ### Title: Query or Set a '"comment"' Attribute
> ### Aliases: comment comment<-
> ### Keywords: attribute
> 
> ### ** Examples
> 
> x <- matrix(1:12, 3, 4)
> comment(x) <- c("This is my very important data from experiment #0234",
+                 "Jun 5, 1998")
> x
     [,1] [,2] [,3] [,4]
[1,]    1    4    7   10
[2,]    2    5    8   11
[3,]    3    6    9   12
> comment(x)
[1] "This is my very important data from experiment #0234"
[2] "Jun 5, 1998"                                         
> 
> 
> 
> cleanEx()
> nameEx("complex")
> ### * complex
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: complex
> ### Title: Complex Numbers and Basic Functionality
> ### Aliases: complex as.complex is.complex Re Im Mod Arg Conj
> ### Keywords: complex
> 
> ### ** Examples
> 
> require(graphics)
> 
> 0i ^ (-3:3)
[1] Inf+0i Inf+0i Inf+0i   1+0i   0+0i   0+0i   0+0i
> 
> matrix(1i^ (-6:5), nrow = 4) #- all columns are the same
      [,1]  [,2]  [,3]
[1,] -1+0i -1+0i -1+0i
[2,]  0-1i  0-1i  0-1i
[3,]  1+0i  1+0i  1+0i
[4,]  0+1i  0+1i  0+1i
> 0 ^ 1i # a complex NaN
[1] NaN+NaNi
> 
> ## create a complex normal vector
> z <- complex(real = stats::rnorm(100), imaginary = stats::rnorm(100))
> ## or also (less efficiently):
> z2 <- 1:2 + 1i*(8:9)
> 
> ## The Arg(.) is an angle:
> zz <- (rep(1:4, len = 9) + 1i*(9:1))/10
> zz.shift <- complex(modulus = Mod(zz), argument = Arg(zz) + pi)
> plot(zz, xlim = c(-1,1), ylim = c(-1,1), col = "red", asp = 1,
+      main = expression(paste("Rotation by "," ", pi == 180^o)))
> abline(h = 0, v = 0, col = "blue", lty = 3)
> points(zz.shift, col = "orange")
> 
> showC <- function(z) noquote(sprintf("(R = %g, I = %g)", Re(z), Im(z)))
> 
> ## The exact result of this *depends* on the platform, compiler, math-library:
> (NpNA <- NaN + NA_complex_) ; str(NpNA) # *behaves* as 'cplx NA' ..
[1] NA
 cplx NA
> stopifnot(is.na(NpNA), is.na(NA_complex_), is.na(Re(NA_complex_)), is.na(Im(NA_complex_)))
> showC(NpNA)# but not always is {shows  '(R = NaN, I = NA)' on some platforms}
[1] (R = NaN, I = NA)
> ## and this is not TRUE everywhere:
> identical(NpNA, NA_complex_)
[1] FALSE
> showC(NA_complex_) # always == (R = NA, I = NA)
[1] (R = NA, I = NA)
> 
> 
> 
> cleanEx()
> nameEx("conditions")
> ### * conditions
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: conditions
> ### Title: Condition Handling and Recovery
> ### Aliases: conditions condition computeRestarts conditionCall
> ###   conditionMessage findRestart invokeRestart tryInvokeRestart
> ###   invokeRestartInteractively isRestart restartDescription
> ###   restartFormals signalCondition simpleCondition simpleError
> ###   simpleWarning simpleMessage errorCondition warningCondition tryCatch
> ###   withCallingHandlers withRestarts suspendInterrupts allowInterrupts
> ###   globalCallingHandlers .signalSimpleWarning .handleSimpleError
> ###   .tryResumeInterrupt as.character.condition as.character.error
> ###   conditionCall.condition conditionMessage.condition print.condition
> ###   print.restart
> ### Keywords: programming error
> 
> ### ** Examples
> 
> tryCatch(1, finally = print("Hello"))
[1] "Hello"
[1] 1
> e <- simpleError("test error")
> ## Not run: 
> ##D  stop(e)
> ##D  tryCatch(stop(e), finally = print("Hello"))
> ##D  tryCatch(stop("fred"), finally = print("Hello"))
> ## End(Not run)
> tryCatch(stop(e), error = function(e) e, finally = print("Hello"))
[1] "Hello"
<simpleError: test error>
> tryCatch(stop("fred"),  error = function(e) e, finally = print("Hello"))
[1] "Hello"
<simpleError in doTryCatch(return(expr), name, parentenv, handler): fred>
> withCallingHandlers({ warning("A"); 1+2 }, warning = function(w) {})
Warning in withCallingHandlers({ : A
[1] 3
> ## Not run: 
> ##D  { withRestarts(stop("A"), abort = function() {}); 1 }
> ## End(Not run)
> withRestarts(invokeRestart("foo", 1, 2), foo = function(x, y) {x + y})
[1] 3
> 
> ##--> More examples are part of
> ##-->   demo(error.catching)
> 
> 
> 
> cleanEx()
> nameEx("conflicts")
> ### * conflicts
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: conflicts
> ### Title: Search for Masked Objects on the Search Path
> ### Aliases: conflicts
> ### Keywords: utilities
> 
> ### ** Examples
> 
> lm <- 1:3
> conflicts(, TRUE)
$.GlobalEnv
[1] "lm"

$CheckExEnv
[1] "F" "T"

$`package:stats`
[1] "lm"

$`package:graphics`
[1] "plot"

$`package:methods`
[1] "body<-"    "kronecker"

$`package:base`
[1] "body<-"    "F"         "kronecker" "plot"      "T"        

> ## gives something like
> # $.GlobalEnv
> # [1] "lm"
> #
> # $package:base
> # [1] "lm"
> 
> ## Remove things from your "workspace" that mask others:
> remove(list = conflicts(detail = TRUE)$.GlobalEnv)
> 
> 
> 
> cleanEx()
> nameEx("connections")
> ### * connections
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: connections
> ### Title: Functions to Manipulate Connections (Files, URLs, ...)
> ### Aliases: connections connection file clipboard pipe fifo gzfile unz
> ###   bzfile xzfile url socketConnection socketAccept serverSocket
> ###   socketTimeout open open.connection isOpen isIncomplete close
> ###   close.connection flush flush.connection print.connection
> ###   summary.connection
> ### Keywords: file connection
> 
> ### ** Examples
> 
> zzfil <- tempfile(fileext=".data")
> zz <- file(zzfil, "w")  # open an output file connection
> cat("TITLE extra line", "2 3 5 7", "", "11 13 17", file = zz, sep = "\n")
> cat("One more line\n", file = zz)
> close(zz)
> readLines(zzfil)
[1] "TITLE extra line" "2 3 5 7"          ""                 "11 13 17"        
[5] "One more line"   
> unlink(zzfil)
> 
> zzfil <- tempfile(fileext=".gz")
> zz <- gzfile(zzfil, "w")  # compressed file
> cat("TITLE extra line", "2 3 5 7", "", "11 13 17", file = zz, sep = "\n")
> close(zz)
> readLines(zz <- gzfile(zzfil))
[1] "TITLE extra line" "2 3 5 7"          ""                 "11 13 17"        
> close(zz)
> unlink(zzfil)
> zz # an invalid connection
A connection, specifically, ‘gzfile’, but invalid.
> 
> zzfil <- tempfile(fileext=".bz2")
> zz <- bzfile(zzfil, "w")  # bzip2-ed file
> cat("TITLE extra line", "2 3 5 7", "", "11 13 17", file = zz, sep = "\n")
> close(zz)
> zz # print() method: invalid connection
A connection, specifically, ‘bzfile’, but invalid.
> print(readLines(zz <- bzfile(zzfil)))
[1] "TITLE extra line" "2 3 5 7"          ""                 "11 13 17"        
> close(zz)
> unlink(zzfil)
> 
> ## An example of a file open for reading and writing
> Tpath <- tempfile("test")
> Tfile <- file(Tpath, "w+")
> c(isOpen(Tfile, "r"), isOpen(Tfile, "w")) # both TRUE
[1] TRUE TRUE
> cat("abc\ndef\n", file = Tfile)
> readLines(Tfile)
[1] "abc" "def"
> seek(Tfile, 0, rw = "r") # reset to beginning
[1] 8
> readLines(Tfile)
[1] "abc" "def"
> cat("ghi\n", file = Tfile)
> readLines(Tfile)
[1] "ghi"
> Tfile # -> print() :  "valid" connection
A connection with                                             
description "/tmp/Rtmptzw2rA/test3d861ed2e5d"
class       "file"                           
mode        "w+"                             
text        "text"                           
opened      "opened"                         
can read    "yes"                            
can write   "yes"                            
> close(Tfile)
> Tfile # -> print() :  "invalid" connection
A connection, specifically, ‘file’, but invalid.
> unlink(Tpath)
> 
> ## We can do the same thing with an anonymous file.
> Tfile <- file()
> cat("abc\ndef\n", file = Tfile)
> readLines(Tfile)
[1] "abc" "def"
> close(Tfile)
> 
> ## Not run: 
> ##D ## fifo example -- may hang even with OS support for fifos
> ##D if(capabilities("fifo")) {
> ##D   zzfil <- tempfile(fileext="-fifo")
> ##D   zz <- fifo(zzfil, "w+")
> ##D   writeLines("abc", zz)
> ##D   print(readLines(zz))
> ##D   close(zz)
> ##D   unlink(zzfil)
> ##D }
> ## End(Not run)
> ## Not run: 
> ##D ## example for a machine running a finger daemon
> ##D 
> ##D con <- socketConnection(port = 79, blocking = TRUE)
> ##D writeLines(paste0(system("whoami", intern = TRUE), "\r"), con)
> ##D gsub(" *$", "", readLines(con))
> ##D close(con)
> ## End(Not run)
> 
> ## Not run: 
> ##D ## Two R processes communicating via non-blocking sockets
> ##D # R process 1
> ##D con1 <- socketConnection(port = 6011, server = TRUE)
> ##D writeLines(LETTERS, con1)
> ##D close(con1)
> ##D 
> ##D # R process 2
> ##D con2 <- socketConnection(Sys.info()["nodename"], port = 6011)
> ##D # as non-blocking, may need to loop for input
> ##D readLines(con2)
> ##D while(isIncomplete(con2)) {
> ##D    Sys.sleep(1)
> ##D    z <- readLines(con2)
> ##D    if(length(z)) print(z)
> ##D }
> ##D close(con2)
> ##D 
> ##D ## examples of use of encodings
> ##D # write a file in UTF-8
> ##D cat(x, file = (con <- file("foo", "w", encoding = "UTF-8"))); close(con)
> ##D # read a 'Windows Unicode' file
> ##D A <- read.table(con <- file("students", encoding = "UCS-2LE")); close(con)
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("crossprod")
> ### * crossprod
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: crossprod
> ### Title: Matrix Crossproduct
> ### Aliases: crossprod tcrossprod
> ### Keywords: algebra array
> 
> ### ** Examples
> 
> (z <- crossprod(1:4))    # = sum(1 + 2^2 + 3^2 + 4^2)
     [,1]
[1,]   30
> drop(z)                  # scalar
[1] 30
> x <- 1:4; names(x) <- letters[1:4]; x
a b c d 
1 2 3 4 
> tcrossprod(as.matrix(x)) # is
  a b  c  d
a 1 2  3  4
b 2 4  6  8
c 3 6  9 12
d 4 8 12 16
> identical(tcrossprod(as.matrix(x)),
+           crossprod(t(x)))
[1] TRUE
> tcrossprod(x)            # no dimnames
     [,1] [,2] [,3] [,4]
[1,]    1    2    3    4
[2,]    2    4    6    8
[3,]    3    6    9   12
[4,]    4    8   12   16
> 
> m <- matrix(1:6, 2,3) ; v <- 1:3; v2 <- 2:1
> stopifnot(identical(tcrossprod(v, m), v %*% t(m)),
+           identical(tcrossprod(v, m), crossprod(v, t(m))),
+           identical(crossprod(m, v2), t(m) %*% v2))
> 
> 
> 
> cleanEx()
> nameEx("cumsum")
> ### * cumsum
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cumsum
> ### Title: Cumulative Sums, Products, and Extremes
> ### Aliases: cumsum cumprod cummin cummax
> ### Keywords: arith
> 
> ### ** Examples
> 
> cumsum(1:10)
 [1]  1  3  6 10 15 21 28 36 45 55
> cumprod(1:10)
 [1]       1       2       6      24     120     720    5040   40320  362880
[10] 3628800
> cummin(c(3:1, 2:0, 4:2))
[1] 3 2 1 1 1 0 0 0 0
> cummax(c(3:1, 2:0, 4:2))
[1] 3 3 3 3 3 3 4 4 4
> 
> 
> 
> cleanEx()
> nameEx("curlGetHeaders")
> ### * curlGetHeaders
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: curlGetHeaders
> ### Title: Retrieve Headers from URLs
> ### Aliases: curlGetHeaders
> 
> ### ** Examples
> ## Not run: 
> ##D  ## a not-always-available site:
> ##D curlGetHeaders("ftps://test.rebex.net/readme.txt")
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("cut.POSIXt")
> ### * cut.POSIXt
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cut.POSIXt
> ### Title: Convert a Date or Date-Time Object to a Factor
> ### Aliases: cut.POSIXt cut.Date
> ### Keywords: manip chron
> 
> ### ** Examples
> 
> ## random dates in a 10-week period
> cut(ISOdate(2001, 1, 1) + 70*86400*stats::runif(100), "weeks")
  [1] 2001-01-15 2001-01-22 2001-02-05 2001-03-05 2001-01-15 2001-03-05
  [7] 2001-03-05 2001-02-12 2001-02-12 2001-01-01 2001-01-15 2001-01-08
 [13] 2001-02-12 2001-01-22 2001-02-19 2001-02-05 2001-02-19 2001-03-05
 [19] 2001-01-22 2001-02-19 2001-03-05 2001-01-15 2001-02-12 2001-01-08
 [25] 2001-01-15 2001-01-22 2001-01-01 2001-01-22 2001-02-26 2001-01-22
 [31] 2001-01-29 2001-02-12 2001-02-05 2001-01-08 2001-02-26 2001-02-12
 [37] 2001-02-26 2001-01-08 2001-02-19 2001-01-29 2001-02-26 2001-02-12
 [43] 2001-02-19 2001-02-05 2001-02-05 2001-02-19 2001-01-01 2001-01-29
 [49] 2001-02-19 2001-02-12 2001-01-29 2001-02-26 2001-01-29 2001-01-15
 [55] 2001-01-01 2001-01-08 2001-01-22 2001-02-05 2001-02-12 2001-01-29
 [61] 2001-03-05 2001-01-22 2001-01-29 2001-01-22 2001-02-12 2001-01-15
 [67] 2001-01-29 2001-02-19 2001-01-01 2001-02-26 2001-01-22 2001-02-26
 [73] 2001-01-22 2001-01-22 2001-01-29 2001-02-26 2001-02-26 2001-01-22
 [79] 2001-02-19 2001-03-05 2001-01-29 2001-02-19 2001-01-29 2001-01-22
 [85] 2001-02-19 2001-01-15 2001-02-19 2001-01-08 2001-01-15 2001-01-08
 [91] 2001-01-15 2001-01-01 2001-02-12 2001-02-26 2001-02-19 2001-02-26
 [97] 2001-01-29 2001-01-29 2001-02-26 2001-02-12
10 Levels: 2001-01-01 2001-01-08 2001-01-15 2001-01-22 ... 2001-03-05
> cut(as.Date("2001/1/1") + 70*stats::runif(100), "weeks")
  [1] 2001-02-12 2001-01-22 2001-01-15 2001-03-05 2001-02-12 2001-01-15
  [7] 2001-01-08 2001-01-29 2001-03-05 2001-02-05 2001-03-05 2001-02-19
 [13] 2001-01-22 2001-01-29 2001-01-08 2001-01-01 2001-02-19 2001-01-08
 [19] 2001-01-29 2001-02-12 2001-03-05 2001-01-29 2001-01-29 2001-01-08
 [25] 2001-02-19 2001-01-29 2001-02-05 2001-01-15 2001-01-15 2001-02-05
 [31] 2001-02-05 2001-01-01 2001-01-01 2001-02-12 2001-03-05 2001-02-05
 [37] 2001-02-05 2001-02-05 2001-03-05 2001-02-05 2001-02-12 2001-02-12
 [43] 2001-01-15 2001-01-15 2001-02-19 2001-01-29 2001-01-08 2001-02-19
 [49] 2001-01-08 2001-02-26 2001-02-12 2001-02-05 2001-01-22 2001-01-29
 [55] 2001-02-05 2001-01-08 2001-02-05 2001-01-01 2001-01-15 2001-01-15
 [61] 2001-01-15 2001-02-26 2001-01-29 2001-02-19 2001-02-26 2001-01-29
 [67] 2001-01-01 2001-01-22 2001-02-19 2001-01-22 2001-02-12 2001-02-26
 [73] 2001-02-26 2001-01-22 2001-01-22 2001-02-26 2001-02-12 2001-02-19
 [79] 2001-02-12 2001-03-05 2001-01-15 2001-01-08 2001-02-26 2001-02-05
 [85] 2001-02-26 2001-01-08 2001-02-19 2001-02-19 2001-03-05 2001-02-05
 [91] 2001-02-19 2001-01-22 2001-01-08 2001-03-05 2001-01-15 2001-02-05
 [97] 2001-01-08 2001-02-26 2001-01-22 2001-02-19
10 Levels: 2001-01-01 2001-01-08 2001-01-15 2001-01-22 ... 2001-03-05
> 
> # The standards all have midnight as the start of the day, but some
> # people incorrectly interpret it at the end of the previous day ...
> tm <- seq(as.POSIXct("2012-06-01 06:00"), by = "6 hours", length.out = 24)
> aggregate(1:24, list(day = cut(tm, "days")), mean)
         day    x
1 2012-06-01  2.0
2 2012-06-02  5.5
3 2012-06-03  9.5
4 2012-06-04 13.5
5 2012-06-05 17.5
6 2012-06-06 21.5
7 2012-06-07 24.0
> # and a version with midnight included in the previous day:
> aggregate(1:24, list(day = cut(tm, "days", right = TRUE)), mean)
         day    x
1 2012-06-01  2.5
2 2012-06-02  6.5
3 2012-06-03 10.5
4 2012-06-04 14.5
5 2012-06-05 18.5
6 2012-06-06 22.5
> 
> 
> 
> cleanEx()
> nameEx("cut")
> ### * cut
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cut
> ### Title: Convert Numeric to Factor
> ### Aliases: cut cut.default
> ### Keywords: category
> 
> ### ** Examples
> 
> Z <- stats::rnorm(10000)
> table(cut(Z, breaks = -6:6))

(-6,-5] (-5,-4] (-4,-3] (-3,-2] (-2,-1]  (-1,0]   (0,1]   (1,2]   (2,3]   (3,4] 
      0       0      18     241    1348    3461    3296    1393     233      10 
  (4,5]   (5,6] 
      0       0 
> sum(table(cut(Z, breaks = -6:6, labels = FALSE)))
[1] 10000
> sum(graphics::hist(Z, breaks = -6:6, plot = FALSE)$counts)
[1] 10000
> 
> cut(rep(1,5), 4) #-- dummy
[1] (0.9995,1] (0.9995,1] (0.9995,1] (0.9995,1] (0.9995,1]
Levels: (0.999,0.9995] (0.9995,1] (1,1.0005] (1.0005,1.001]
> tx0 <- c(9, 4, 6, 5, 3, 10, 5, 3, 5)
> x <- rep(0:8, tx0)
> stopifnot(table(x) == tx0)
> 
> table( cut(x, b = 8))

(-0.008,1]      (1,2]      (2,3]      (3,4]      (4,5]      (5,6]      (6,7] 
        13          6          5          3         10          5          3 
  (7,8.01] 
         5 
> table( cut(x, breaks = 3*(-2:5)))

(-6,-3]  (-3,0]   (0,3]   (3,6]   (6,9]  (9,12] (12,15] 
      0       9      15      18       8       0       0 
> table( cut(x, breaks = 3*(-2:5), right = FALSE))

[-6,-3)  [-3,0)   [0,3)   [3,6)   [6,9)  [9,12) [12,15) 
      0       0      19      18      13       0       0 
> 
> ##--- some values OUTSIDE the breaks :
> table(cx  <- cut(x, breaks = 2*(0:4)))

(0,2] (2,4] (4,6] (6,8] 
   10     8    15     8 
> table(cxl <- cut(x, breaks = 2*(0:4), right = FALSE))

[0,2) [2,4) [4,6) [6,8) 
   13    11    13     8 
> which(is.na(cx));  x[is.na(cx)]  #-- the first 9  values  0
[1] 1 2 3 4 5 6 7 8 9
[1] 0 0 0 0 0 0 0 0 0
> which(is.na(cxl)); x[is.na(cxl)] #-- the last  5  values  8
[1] 46 47 48 49 50
[1] 8 8 8 8 8
> 
> 
> ## Label construction:
> y <- stats::rnorm(100)
> table(cut(y, breaks = pi/3*(-3:3)))

(-3.14,-2.09] (-2.09,-1.05]     (-1.05,0]      (0,1.05]   (1.05,2.09] 
            0             9            45            36            10 
  (2.09,3.14] 
            0 
> table(cut(y, breaks = pi/3*(-3:3), dig.lab = 4))

(-3.142,-2.094] (-2.094,-1.047]      (-1.047,0]       (0,1.047]   (1.047,2.094] 
              0               9              45              36              10 
  (2.094,3.142] 
              0 
> 
> table(cut(y, breaks =  1*(-3:3), dig.lab = 4))

(-3,-2] (-2,-1]  (-1,0]   (0,1]   (1,2]   (2,3] 
      0      10      44      33      13       0 
> # extra digits don't "harm" here
> table(cut(y, breaks =  1*(-3:3), right = FALSE))

[-3,-2) [-2,-1)  [-1,0)   [0,1)   [1,2)   [2,3) 
      0      10      44      33      13       0 
> #- the same, since no exact INT!
> 
> ## sometimes the default dig.lab is not enough to be avoid confusion:
> aaa <- c(1,2,3,4,5,2,3,4,5,6,7)
> cut(aaa, 3)
 [1] (0.994,3] (0.994,3] (0.994,3] (3,5]     (3,5]     (0.994,3] (0.994,3]
 [8] (3,5]     (3,5]     (5,7.01]  (5,7.01] 
Levels: (0.994,3] (3,5] (5,7.01]
> cut(aaa, 3, dig.lab = 4, ordered = TRUE)
 [1] (0.994,3] (0.994,3] (0.994,3] (3,5]     (3,5]     (0.994,3] (0.994,3]
 [8] (3,5]     (3,5]     (5,7.006] (5,7.006]
Levels: (0.994,3] < (3,5] < (5,7.006]
> 
> ## one way to extract the breakpoints
> labs <- levels(cut(aaa, 3))
> cbind(lower = as.numeric( sub("\\((.+),.*", "\\1", labs) ),
+       upper = as.numeric( sub("[^,]*,([^]]*)\\]", "\\1", labs) ))
     lower upper
[1,] 0.994  3.00
[2,] 3.000  5.00
[3,] 5.000  7.01
> 
> 
> 
> cleanEx()
> nameEx("data.class")
> ### * data.class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: data.class
> ### Title: Object Classes
> ### Aliases: data.class
> ### Keywords: classes methods
> 
> ### ** Examples
> 
> x <- LETTERS
> data.class(factor(x))                 # has a class attribute
[1] "factor"
> data.class(matrix(x, ncol = 13))      # has a dim attribute
[1] "matrix"
> data.class(list(x))                   # the same as mode(x)
[1] "list"
> data.class(x)                         # the same as mode(x)
[1] "character"
> 
> stopifnot(data.class(1:2) == "numeric") # compatibility "rule"
> 
> 
> 
> cleanEx()
> nameEx("data.frame")
> ### * data.frame
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: data.frame
> ### Title: Data Frames
> ### Aliases: data.frame default.stringsAsFactors
> ### Keywords: classes methods
> 
> ### ** Examples
> 
> L3 <- LETTERS[1:3]
> fac <- sample(L3, 10, replace = TRUE)
> (d <- data.frame(x = 1, y = 1:10, fac = fac))
   x  y fac
1  1  1   A
2  1  2   C
3  1  3   A
4  1  4   B
5  1  5   A
6  1  6   C
7  1  7   C
8  1  8   B
9  1  9   B
10 1 10   C
> ## The "same" with automatic column names:
> data.frame(1, 1:10, sample(L3, 10, replace = TRUE))
   X1 X1.10 sample.L3..10..replace...TRUE.
1   1     1                              C
2   1     2                              A
3   1     3                              A
4   1     4                              A
5   1     5                              B
6   1     6                              B
7   1     7                              B
8   1     8                              B
9   1     9                              C
10  1    10                              A
> 
> is.data.frame(d)
[1] TRUE
> 
> ## do not convert to factor, using I() :
> (dd <- cbind(d, char = I(letters[1:10])))
   x  y fac char
1  1  1   A    a
2  1  2   C    b
3  1  3   A    c
4  1  4   B    d
5  1  5   A    e
6  1  6   C    f
7  1  7   C    g
8  1  8   B    h
9  1  9   B    i
10 1 10   C    j
> rbind(class = sapply(dd, class), mode = sapply(dd, mode))
      x         y         fac         char       
class "numeric" "integer" "character" "AsIs"     
mode  "numeric" "numeric" "character" "character"
> 
> stopifnot(1:10 == row.names(d))  # {coercion}
> 
> (d0  <- d[, FALSE])   # data frame with 0 columns and 10 rows
data frame with 0 columns and 10 rows
> (d.0 <- d[FALSE, ])   # <0 rows> data frame  (3 named cols)
[1] x   y   fac
<0 rows> (or 0-length row.names)
> (d00 <- d0[FALSE, ])  # data frame with 0 columns and 0 rows
data frame with 0 columns and 0 rows
> 
> 
> 
> cleanEx()
> nameEx("data.matrix")
> ### * data.matrix
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: data.matrix
> ### Title: Convert a Data Frame to a Numeric Matrix
> ### Aliases: data.matrix
> ### Keywords: array
> 
> ### ** Examples
> 
> DF <- data.frame(a = 1:3, b = letters[10:12],
+                  c = seq(as.Date("2004-01-01"), by = "week", len = 3),
+                  stringsAsFactors = TRUE)
> data.matrix(DF[1:2])
     a b
[1,] 1 1
[2,] 2 2
[3,] 3 3
> data.matrix(DF)
     a b     c
[1,] 1 1 12418
[2,] 2 2 12425
[3,] 3 3 12432
> 
> 
> 
> cleanEx()
> nameEx("date")
> ### * date
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: date
> ### Title: System Date and Time
> ### Aliases: date
> ### Keywords: utilities
> 
> ### ** Examples
> 
> 
> cleanEx()
> nameEx("dcf")
> ### * dcf
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dcf
> ### Title: Read and Write Data in DCF Format
> ### Aliases: read.dcf write.dcf
> ### Keywords: print file
> 
> ### ** Examples
> 
> 
> cleanEx()
> nameEx("debug")
> ### * debug
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: debug
> ### Title: Debug a Function
> ### Aliases: debug debugonce undebug isdebugged debuggingState
> ### Keywords: programming environment
> 
> ### ** Examples
> 
> ## Not run: 
> ##D debug(library)
> ##D library(methods)
> ## End(Not run)
> ## Not run: 
> ##D debugonce(sample)
> ##D ## only the first call will be debugged
> ##D sampe(10, 1)
> ##D sample(10, 1)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("delayedAssign")
> ### * delayedAssign
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: delayedAssign
> ### Title: Delay Evaluation
> ### Aliases: delayedAssign promise promises
> ### Keywords: programming data
> 
> ### ** Examples
> 
> msg <- "old"
> delayedAssign("x", msg)
> substitute(x) # shows only 'x', as it is in the global env.
x
> msg <- "new!"
> x # new!
[1] "new!"
> 
> delayedAssign("x", {
+     for(i in 1:3)
+         cat("yippee!\n")
+     10
+ })
> 
> x^2 #- yippee
yippee!
yippee!
yippee!
[1] 100
> x^2 #- simple number
[1] 100
> 
> ne <- new.env()
> delayedAssign("x", pi + 2, assign.env = ne)
> ## See the promise {without "forcing" (i.e. evaluating) it}:
> substitute(x, ne) #  'pi + 2'
pi + 2
> ## Don't show: 
> stopifnot(identical(substitute(x,ne), quote(pi + 2)))
> ## End(Don't show)
> 
> ### Promises in an environment [for advanced users]:  ---------------------
> 
> e <- (function(x, y = 1, z) environment())(cos, "y", {cat(" HO!\n"); pi+2})
> ## How can we look at all promises in an env (w/o forcing them)?
> gete <- function(e_)
+    lapply(lapply(ls(e_), as.name),
+           function(n) eval(substitute(substitute(X, e_), list(X=n))))
> 
> (exps <- gete(e))
[[1]]
cos

[[2]]
[1] "y"

[[3]]
{
    cat(" HO!\n")
    pi + 2
}

> sapply(exps, typeof)
[1] "symbol"    "character" "language" 
> 
> (le <- as.list(e)) # evaluates ("force"s) the promises
 HO!
$x
function (x)  .Primitive("cos")

$y
[1] "y"

$z
[1] 5.141593

> stopifnot(identical(unname(le), lapply(exps, eval))) # and another "Ho!"
 HO!
> 
> 
> 
> cleanEx()
> nameEx("deparse")
> ### * deparse
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: deparse
> ### Title: Expression Deparsing
> ### Aliases: deparse deparse1
> ### Keywords: programming manip data
> 
> ### ** Examples
> 
> require(stats); require(graphics)
> 
> deparse(args(lm))
[1] "function (formula, data, subset, weights, na.action, method = \"qr\", " 
[2] "    model = TRUE, x = FALSE, y = FALSE, qr = TRUE, singular.ok = TRUE, "
[3] "    contrasts = NULL, offset, ...) "                                    
[4] "NULL"                                                                   
> deparse(args(lm), width = 500)
[1] "function (formula, data, subset, weights, na.action, method = \"qr\", model = TRUE, x = FALSE, y = FALSE, qr = TRUE, singular.ok = TRUE, contrasts = NULL, offset, ...) "
[2] "NULL"                                                                                                                                                                    
> 
> myplot <- function(x, y) {
+     plot(x, y, xlab = deparse1(substitute(x)),
+                ylab = deparse1(substitute(y)))
+ }
> 
> e <- quote(`foo bar`)
> deparse(e)
[1] "foo bar"
> deparse(e, backtick = TRUE)
[1] "`foo bar`"
> e <- quote(`foo bar`+1)
> deparse(e)
[1] "`foo bar` + 1"
> deparse(e, control = "all") # wraps it w/ quote( . )
[1] "quote(`foo bar` + 1)"
> 
> 
> 
> cleanEx()
> nameEx("deparseOpts")
> ### * deparseOpts
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: deparseOpts
> ### Title: Options for Expression Deparsing
> ### Aliases: .deparseOpts ..deparseOpts
> ### Keywords: programming
> 
> ### ** Examples
> 
> (iOpt.all <- .deparseOpts("all")) # a four digit integer
[1] 1631
> 
> ## one integer --> vector binary bits
> int2bits <- function(x, base = 2L,
+                      ndigits = 1 + floor(1e-9 + log(max(x,1), base))) {
+     r <- numeric(ndigits)
+     for (i in ndigits:1) {
+         r[i] <- x%%base
+         if (i > 1L)
+             x <- x%/%base
+     }
+     rev(r) # smallest bit at left
+ }
> int2bits(iOpt.all)
 [1] 1 1 1 1 1 0 1 0 0 1 1
> ## what options does  "all" contain ?
> depO.indiv <- setdiff(..deparseOpts, c("all", "exact"))
> (oa <- depO.indiv[int2bits(iOpt.all) == 1])
[1] "keepInteger"      "quoteExpressions" "showAttributes"   "useSource"       
[5] "warnIncomplete"   "keepNA"           "digits17"         "niceNames"       
> stopifnot(identical(iOpt.all, .deparseOpts(oa)))
> 
> ## ditto for "exact" instead of "all":
> int2bits(iOpt.X <- .deparseOpts("exact"))
 [1] 1 1 1 1 1 0 1 0 1 0 1
> (oX <- depO.indiv[int2bits(iOpt.X) == 1])
[1] "keepInteger"      "quoteExpressions" "showAttributes"   "useSource"       
[5] "warnIncomplete"   "keepNA"           "hexNumeric"       "niceNames"       
> diffXall <- oa != oX
> stopifnot(identical(iOpt.X, .deparseOpts(oX)),
+           identical(oX[diffXall], "hexNumeric"),
+           identical(oa[diffXall], "digits17"))
> 
> 
> 
> cleanEx()
> nameEx("det")
> ### * det
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: det
> ### Title: Calculate the Determinant of a Matrix
> ### Aliases: det determinant determinant.matrix
> ### Keywords: array
> 
> ### ** Examples
> 
> (x <- matrix(1:4, ncol = 2))
     [,1] [,2]
[1,]    1    3
[2,]    2    4
> unlist(determinant(x))
   modulus       sign 
 0.6931472 -1.0000000 
> det(x)
[1] -2
> 
> det(print(cbind(1, 1:3, c(2,0,1))))
     [,1] [,2] [,3]
[1,]    1    1    2
[2,]    1    2    0
[3,]    1    3    1
[1] 3
> 
> 
> 
> cleanEx()
> nameEx("detach")
> ### * detach
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: detach
> ### Title: Detach Objects from the Search Path
> ### Aliases: detach
> ### Keywords: data
> 
> ### ** Examples
> 
> require(splines) # package
Loading required package: splines
> detach(package:splines)
> ## or also
> library(splines)
> pkg <- "package:splines"
> ## Don't show: 
> stopifnot(inherits(tryCatch(detach(pkg), error = function(.).),  "error"))
> ## End(Don't show)
> detach(pkg, character.only = TRUE)
> 
> ## careful: do not do this unless 'splines' is not already attached.
> library(splines)
> detach(2) # 'pos' used for 'name'
> 
> ## an example of the name argument to attach
> ## and of detaching a database named by a character vector
> attach_and_detach <- function(db, pos = 2)
+ {
+    name <- deparse1(substitute(db))
+    attach(db, pos = pos, name = name)
+    print(search()[pos])
+    detach(name, character.only = TRUE)
+ }
> attach_and_detach(women, pos = 3)
[1] "women"
> 
> 
> 
> cleanEx()
> nameEx("diag")
> ### * diag
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: diag
> ### Title: Matrix Diagonals
> ### Aliases: diag diag<-
> ### Keywords: array
> 
> ### ** Examples
> 
> dim(diag(3))
[1] 3 3
> diag(10, 3, 4) # guess what?
     [,1] [,2] [,3] [,4]
[1,]   10    0    0    0
[2,]    0   10    0    0
[3,]    0    0   10    0
> all(diag(1:3) == {m <- matrix(0,3,3); diag(m) <- 1:3; m})
[1] TRUE
> 
> ## other "numeric"-like diagonal matrices :
> diag(c(1i,2i))    # complex
     [,1] [,2]
[1,] 0+1i 0+0i
[2,] 0+0i 0+2i
> diag(TRUE, 3)     # logical
      [,1]  [,2]  [,3]
[1,]  TRUE FALSE FALSE
[2,] FALSE  TRUE FALSE
[3,] FALSE FALSE  TRUE
> diag(as.raw(1:3)) # raw
     [,1] [,2] [,3]
[1,]   01   00   00
[2,]   00   02   00
[3,]   00   00   03
> (D2 <- diag(2:1, 4)); typeof(D2) # "integer"
     [,1] [,2] [,3] [,4]
[1,]    2    0    0    0
[2,]    0    1    0    0
[3,]    0    0    2    0
[4,]    0    0    0    1
[1] "integer"
> 
> require(stats)
> ## diag(<var-cov-matrix>) = variances
> diag(var(M <- cbind(X = 1:5, Y = rnorm(5))))
        X         Y 
2.5000000 0.9235968 
> #-> vector with names "X" and "Y"
> rownames(M) <- c(colnames(M), rep("", 3))
> M; diag(M) #  named as well
  X          Y
X 1 -0.6264538
Y 2  0.1836433
  3 -0.8356286
  4  1.5952808
  5  0.3295078
        X         Y 
1.0000000 0.1836433 
> diag(M, names = FALSE) # w/o names
[1] 1.0000000 0.1836433
> ## Don't show: 
> stopifnot(identical(names(diag(M)), colnames(M)),
+                     is.null(names(diag(M,      names=FALSE))),
+                     is.null(names(diag(var(M), names=FALSE)))) 
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("diff")
> ### * diff
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: diff
> ### Title: Lagged Differences
> ### Aliases: diff diff.default diff.POSIXt diff.Date
> ### Keywords: arith
> 
> ### ** Examples
> 
> diff(1:10, 2)
[1] 2 2 2 2 2 2 2 2
> diff(1:10, 2, 2)
[1] 0 0 0 0 0 0
> x <- cumsum(cumsum(1:10))
> diff(x, lag = 2)
[1]   9  16  25  36  49  64  81 100
> diff(x, differences = 2)
[1]  3  4  5  6  7  8  9 10
> 
> diff(.leap.seconds)
Time differences in days
 [1]  184  365  365  365  366  365  365  365  547  365  365  731  914  731  365
[16]  547  365  365  549  547  549 2557 1096 1277 1095  550
> 
> 
> 
> cleanEx()
> nameEx("difftime")
> ### * difftime
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: difftime
> ### Title: Time Intervals / Differences
> ### Aliases: difftime as.difftime as.double.difftime is.numeric.difftime
> ###   print.difftime format.difftime units.difftime units<-.difftime
> ###   Ops.difftime *.difftime /.difftime Math.difftime Summary.difftime
> ###   [.difftime mean.difftime diff.difftime c.difftime length<-.difftime
> ###   as.list.difftime units units<- 'time interval'
> ### Keywords: utilities chron
> 
> ### ** Examples
> 
> 
> cleanEx()
> nameEx("dim")
> ### * dim
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dim
> ### Title: Dimensions of an Object
> ### Aliases: dim dim.data.frame dim<-
> ### Keywords: array
> 
> ### ** Examples
> 
> x <- 1:12 ; dim(x) <- c(3,4)
> x
     [,1] [,2] [,3] [,4]
[1,]    1    4    7   10
[2,]    2    5    8   11
[3,]    3    6    9   12
> 
> # simple versions of nrow and ncol could be defined as follows
> nrow0 <- function(x) dim(x)[1]
> ncol0 <- function(x) dim(x)[2]
> 
> 
> 
> cleanEx()
> nameEx("dimnames")
> ### * dimnames
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dimnames
> ### Title: Dimnames of an Object
> ### Aliases: dimnames dimnames<- dimnames.data.frame dimnames<-.data.frame
> ###   provideDimnames
> ### Keywords: array manip
> 
> ### ** Examples
> 
> ## simple versions of rownames and colnames
> ## could be defined as follows
> rownames0 <- function(x) dimnames(x)[[1]]
> colnames0 <- function(x) dimnames(x)[[2]]
> 
> (dn <- dimnames(A <- provideDimnames(N <- array(1:24, dim = 2:4))))
[[1]]
[1] "A" "B"

[[2]]
[1] "A" "B" "C"

[[3]]
[1] "A" "B" "C" "D"

> A0 <- A; dimnames(A)[2:3] <- list(NULL)
> stopifnot(identical(A0, provideDimnames(A)))
> strd <- function(x) utils::str(dimnames(x))
> strd(provideDimnames(A, base= list(letters[-(1:9)], tail(LETTERS))))
List of 3
 $ : chr [1:2] "A" "B"
 $ : chr [1:3] "U" "V" "W"
 $ : chr [1:4] "j" "k" "l" "m"
> strd(provideDimnames(N, base= list(letters[-(1:9)], tail(LETTERS)))) # recycling
List of 3
 $ : chr [1:2] "j" "k"
 $ : chr [1:3] "U" "V" "W"
 $ : chr [1:4] "j" "k" "l" "m"
> strd(provideDimnames(A, base= list(c("AA","BB")))) # recycling on both levels
List of 3
 $ : chr [1:2] "A" "B"
 $ : chr [1:3] "AA" "BB" "AA1"
 $ : chr [1:4] "AA" "BB" "AA1" "BB1"
> ## set "empty dimnames":
> provideDimnames(rbind(1, 2:3), base = list(""), unique=FALSE)
    
 1 1
 2 3
> 
> 
> 
> cleanEx()
> nameEx("do.call")
> ### * do.call
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: do.call
> ### Title: Execute a Function Call
> ### Aliases: do.call
> ### Keywords: programming
> 
> ### ** Examples
> 
> do.call("complex", list(imag = 1:3))
[1] 0+1i 0+2i 0+3i
> 
> ## if we already have a list (e.g., a data frame)
> ## we need c() to add further arguments
> tmp <- expand.grid(letters[1:2], 1:3, c("+", "-"))
> do.call("paste", c(tmp, sep = ""))
 [1] "a1+" "b1+" "a2+" "b2+" "a3+" "b3+" "a1-" "b1-" "a2-" "b2-" "a3-" "b3-"
> 
> do.call(paste, list(as.name("A"), as.name("B")), quote = TRUE)
[1] "A B"
> 
> ## examples of where objects will be found.
> A <- 2
> f <- function(x) print(x^2)
> env <- new.env()
> assign("A", 10, envir = env)
> assign("f", f, envir = env)
> f <- function(x) print(x)
> f(A)                                      # 2
[1] 2
> do.call("f", list(A))                     # 2
[1] 2
> do.call("f", list(A), envir = env)        # 4
[1] 4
> do.call( f,  list(A), envir = env)        # 2
[1] 2
> do.call("f", list(quote(A)), envir = env) # 100
[1] 100
> do.call( f,  list(quote(A)), envir = env) # 10
[1] 10
> do.call("f", list(as.name("A")), envir = env) # 100
[1] 100
> 
> eval(call("f", A))                      # 2
[1] 2
> eval(call("f", quote(A)))               # 2
[1] 2
> eval(call("f", A), envir = env)         # 4
[1] 4
> eval(call("f", quote(A)), envir = env)  # 100
[1] 100
> 
> 
> 
> cleanEx()
> nameEx("dots")
> ### * dots
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dots
> ### Title: ..., '..1', etc used in Functions
> ### Aliases: dots ... ..1 ..2 ...elt ...length
> ### Keywords: programming documentation
> 
> ### ** Examples
> 
> tst <- function(n, ...) ...elt(n)
> tst(1, pi=pi*0:1, 2:4) ## [1] 0.000000 3.141593
[1] 0.000000 3.141593
> tst(2, pi=pi*0:1, 2:4) ## [1] 2 3 4
[1] 2 3 4
> try(tst(1)) # -> Error about '...' not containing an element.
Error in tst(1) : the ... list contains fewer than 1 element
> 
> tst.dl <- function(x, ...) ...length()
> tst.dl(1:10)    # 0  (because the first argument is 'x')
[1] 0
> tst.dl(4, 5)    # 1
[1] 1
> tst.dl(4, 5, 6) # 2  namely '5, 6'
[1] 2
> tst.dl(4, 5, 6, 7, sin(1:10), "foo"/"bar") # 5.  Note: no evaluation!
[1] 5
> 
> 
> 
> cleanEx()
> nameEx("double")
> ### * double
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: double
> ### Title: Double-Precision Vectors
> ### Aliases: double as.double is.double single as.single as.single.default
> ### Keywords: classes
> 
> ### ** Examples
> 
> is.double(1)
[1] TRUE
> all(double(3) == 0)
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("dput")
> ### * dput
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dput
> ### Title: Write an Object to a File or Recreate it
> ### Aliases: dput dget
> ### Keywords: file programming connection
> 
> ### ** Examples
> 
> fil <- tempfile()
> ## Write an ASCII version of the 'base' function mean() to our temp file, ..
> dput(base::mean, fil)
> ## ... read it back into 'bar' and confirm it is the same
> bar <- dget(fil)
> stopifnot(all.equal(bar, base::mean))
> 
> ## Create a function with comments
> baz <- function(x) {
+   # Subtract from one
+   1-x
+ }
> ## and display it
> dput(baz)
function (x) 
{
    1 - x
}
> ## and now display the saved source
> dput(baz, control = "useSource")
function (x) 
{
    1 - x
}
> 
> ## Numeric values:
> xx <- pi^(1:3)
> dput(xx)
c(3.14159265358979, 9.86960440108936, 31.0062766802998)
> dput(xx, control = "digits17")
c(3.1415926535897931, 9.869604401089358, 31.006276680299816)
> dput(xx, control = "hexNumeric")
c(0x1.921fb54442d18p+1, 0x1.3bd3cc9be45dep+3, 0x1.f019b59389d7bp+4
)
> dput(xx, fil); dget(fil) - xx # slight rounding on all platforms
[1] -3.108624e-15  1.776357e-15 -1.776357e-14
> dput(xx, fil, control = "digits17")
> dget(fil) - xx # slight rounding on some platforms
[1] 0 0 0
> dput(xx, fil, control = "hexNumeric"); dget(fil) - xx
[1] 0 0 0
> unlink(fil)
> 
> xn <- setNames(xx, paste0("pi^",1:3))
> dput(xn) # nicer, now "niceNames" being part of default 'control'
c(`pi^1` = 3.14159265358979, `pi^2` = 9.86960440108936, `pi^3` = 31.0062766802998
)
> dput(xn, control = "S_compat") # no names
c(3.14159265358979, 9.86960440108936, 31.0062766802998)
> ## explicitly asking for output as in R < 3.5.0:
> dput(xn, control = c("keepNA", "keepInteger", "showAttributes"))
structure(c(3.14159265358979, 9.86960440108936, 31.0062766802998
), .Names = c("pi^1", "pi^2", "pi^3"))
> 
> 
> 
> cleanEx()
> nameEx("drop")
> ### * drop
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: drop
> ### Title: Drop Redundant Extent Information
> ### Aliases: drop
> ### Keywords: array
> 
> ### ** Examples
> 
> dim(drop(array(1:12, dim = c(1,3,1,1,2,1,2)))) # = 3 2 2
[1] 3 2 2
> drop(1:3 %*% 2:4)  # scalar product
[1] 20
> 
> 
> 
> cleanEx()
> nameEx("droplevels")
> ### * droplevels
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: droplevels
> ### Title: Drop Unused Levels from Factors
> ### Aliases: droplevels droplevels.factor droplevels.data.frame
> ### Keywords: category NA
> 
> ### ** Examples
> 
> aq <- transform(airquality, Month = factor(Month, labels = month.abb[5:9]))
> aq <- subset(aq, Month != "Jul")
> table(           aq $Month)

May Jun Jul Aug Sep 
 31  30   0  31  30 
> table(droplevels(aq)$Month)

May Jun Aug Sep 
 31  30  31  30 
> 
> 
> 
> cleanEx()
> nameEx("dump")
> ### * dump
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dump
> ### Title: Text Representations of R Objects
> ### Aliases: dump
> ### Keywords: file connection
> 
> ### ** Examples
> 
> x <- 1; y <- 1:10
> fil <- tempfile(fileext=".Rdmped")
> dump(ls(pattern = '^[xyz]'), fil)
> print(.Last.value)
[1] "x" "y"
> unlink(fil)
> 
> 
> 
> cleanEx()
> nameEx("duplicated")
> ### * duplicated
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: duplicated
> ### Title: Determine Duplicate Elements
> ### Aliases: duplicated duplicated.default duplicated.data.frame
> ###   duplicated.matrix duplicated.array anyDuplicated
> ###   anyDuplicated.default anyDuplicated.array anyDuplicated.matrix
> ###   anyDuplicated.data.frame
> ### Keywords: logic manip
> 
> ### ** Examples
> 
> x <- c(9:20, 1:5, 3:7, 0:8)
> ## extract unique elements
> (xu <- x[!duplicated(x)])
 [1]  9 10 11 12 13 14 15 16 17 18 19 20  1  2  3  4  5  6  7  0  8
> ## similar, same elements but different order:
> (xu2 <- x[!duplicated(x, fromLast = TRUE)])
 [1]  9 10 11 12 13 14 15 16 17 18 19 20  0  1  2  3  4  5  6  7  8
> 
> ## xu == unique(x) but unique(x) is more efficient
> stopifnot(identical(xu,  unique(x)),
+           identical(xu2, unique(x, fromLast = TRUE)))
> 
> duplicated(iris)[140:143]
[1] FALSE FALSE FALSE  TRUE
> 
> duplicated(iris3, MARGIN = c(1, 3))
      Setosa Versicolor Virginica
 [1,]  FALSE      FALSE     FALSE
 [2,]  FALSE      FALSE     FALSE
 [3,]  FALSE      FALSE     FALSE
 [4,]  FALSE      FALSE     FALSE
 [5,]  FALSE      FALSE     FALSE
 [6,]  FALSE      FALSE     FALSE
 [7,]  FALSE      FALSE     FALSE
 [8,]  FALSE      FALSE     FALSE
 [9,]  FALSE      FALSE     FALSE
[10,]  FALSE      FALSE     FALSE
[11,]  FALSE      FALSE     FALSE
[12,]  FALSE      FALSE     FALSE
[13,]  FALSE      FALSE     FALSE
[14,]  FALSE      FALSE     FALSE
[15,]  FALSE      FALSE     FALSE
[16,]  FALSE      FALSE     FALSE
[17,]  FALSE      FALSE     FALSE
[18,]  FALSE      FALSE     FALSE
[19,]  FALSE      FALSE     FALSE
[20,]  FALSE      FALSE     FALSE
[21,]  FALSE      FALSE     FALSE
[22,]  FALSE      FALSE     FALSE
[23,]  FALSE      FALSE     FALSE
[24,]  FALSE      FALSE     FALSE
[25,]  FALSE      FALSE     FALSE
[26,]  FALSE      FALSE     FALSE
[27,]  FALSE      FALSE     FALSE
[28,]  FALSE      FALSE     FALSE
[29,]  FALSE      FALSE     FALSE
[30,]  FALSE      FALSE     FALSE
[31,]  FALSE      FALSE     FALSE
[32,]  FALSE      FALSE     FALSE
[33,]  FALSE      FALSE     FALSE
[34,]  FALSE      FALSE     FALSE
[35,]  FALSE      FALSE     FALSE
[36,]  FALSE      FALSE     FALSE
[37,]  FALSE      FALSE     FALSE
[38,]  FALSE      FALSE     FALSE
[39,]  FALSE      FALSE     FALSE
[40,]  FALSE      FALSE     FALSE
[41,]  FALSE      FALSE     FALSE
[42,]  FALSE      FALSE     FALSE
[43,]  FALSE      FALSE      TRUE
[44,]  FALSE      FALSE     FALSE
[45,]  FALSE      FALSE     FALSE
[46,]  FALSE      FALSE     FALSE
[47,]  FALSE      FALSE     FALSE
[48,]  FALSE      FALSE     FALSE
[49,]  FALSE      FALSE     FALSE
[50,]  FALSE      FALSE     FALSE
> anyDuplicated(iris) ## 143
[1] 143
> ## Don't show: 
> stopifnot(identical(anyDuplicated(iris), 143L),
+           identical(anyDuplicated(iris3, MARGIN = c(1, 3)), 143L))
> ## End(Don't show)
> anyDuplicated(x)
[1] 18
> anyDuplicated(x, fromLast = TRUE)
[1] 22
> 
> 
> 
> cleanEx()
> nameEx("dynload")
> ### * dynload
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dyn.load
> ### Title: Foreign Function Interface
> ### Aliases: dyn.load dyn.unload is.loaded R_MAX_NUM_DLLS
> ### Keywords: interface
> 
> ### ** Examples
> 
> ## expect all of these to be false in R >= 3.0.0.
> is.loaded("supsmu") # Fortran entry point in stats
[1] FALSE
> is.loaded("supsmu", "stats", "Fortran")
[1] FALSE
> is.loaded("PDF", type = "External") # pdf() device in grDevices
[1] FALSE
> 
> 
> 
> cleanEx()
> nameEx("eapply")
> ### * eapply
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: eapply
> ### Title: Apply a Function Over Values in an Environment
> ### Aliases: eapply
> ### Keywords: iteration environment list
> 
> ### ** Examples
> 
> require(stats)
> 
> env <- new.env(hash = FALSE) # so the order is fixed
> env$a <- 1:10
> env$beta <- exp(-3:3)
> env$logic <- c(TRUE, FALSE, FALSE, TRUE)
> # what have we there?
> utils::ls.str(env)
a :  int [1:10] 1 2 3 4 5 6 7 8 9 10
beta :  num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
logic :  logi [1:4] TRUE FALSE FALSE TRUE
> 
> # compute the mean for each list element
>        eapply(env, mean)
$logic
[1] 0.5

$beta
[1] 4.535125

$a
[1] 5.5

> unlist(eapply(env, mean, USE.NAMES = FALSE))
[1] 0.500000 4.535125 5.500000
> 
> # median and quartiles for each element (making use of "..." passing):
> eapply(env, quantile, probs = 1:3/4)
$logic
25% 50% 75% 
0.0 0.5 1.0 

$beta
      25%       50%       75% 
0.2516074 1.0000000 5.0536690 

$a
 25%  50%  75% 
3.25 5.50 7.75 

> eapply(env, quantile)
$logic
  0%  25%  50%  75% 100% 
 0.0  0.0  0.5  1.0  1.0 

$beta
         0%         25%         50%         75%        100% 
 0.04978707  0.25160736  1.00000000  5.05366896 20.08553692 

$a
   0%   25%   50%   75%  100% 
 1.00  3.25  5.50  7.75 10.00 

> 
> 
> 
> cleanEx()
> nameEx("eigen")
> ### * eigen
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: eigen
> ### Title: Spectral Decomposition of a Matrix
> ### Aliases: eigen print.eigen
> ### Keywords: algebra array
> 
> ### ** Examples
> 
> eigen(cbind(c(1,-1), c(-1,1)))
eigen() decomposition
$values
[1] 2 0

$vectors
           [,1]       [,2]
[1,] -0.7071068 -0.7071068
[2,]  0.7071068 -0.7071068

> eigen(cbind(c(1,-1), c(-1,1)), symmetric = FALSE)
eigen() decomposition
$values
[1] 2 0

$vectors
           [,1]      [,2]
[1,]  0.7071068 0.7071068
[2,] -0.7071068 0.7071068

> # same (different algorithm).
> 
> eigen(cbind(1, c(1,-1)), only.values = TRUE)
$values
[1]  1.414214 -1.414214

$vectors
NULL

> eigen(cbind(-1, 2:1)) # complex values
eigen() decomposition
$values
[1] 0+1i 0-1i

$vectors
                     [,1]                 [,2]
[1,] 0.8164966+0.0000000i 0.8164966+0.0000000i
[2,] 0.4082483+0.4082483i 0.4082483-0.4082483i

> eigen(print(cbind(c(0, 1i), c(-1i, 0)))) # Hermite ==> real Eigenvalues
     [,1] [,2]
[1,] 0+0i 0-1i
[2,] 0+1i 0+0i
eigen() decomposition
$values
[1]  1 -1

$vectors
                      [,1]                  [,2]
[1,] -0.7071068+0.0000000i -0.7071068+0.0000000i
[2,]  0.0000000-0.7071068i  0.0000000+0.7071068i

> ## 3 x 3:
> eigen(cbind( 1, 3:1, 1:3))
eigen() decomposition
$values
[1]  5.000000e+00  1.000000e+00 -4.440892e-16

$vectors
          [,1]       [,2]       [,3]
[1,] 0.5773503 -0.8451543 -0.9428090
[2,] 0.5773503 -0.1690309  0.2357023
[3,] 0.5773503  0.5070926  0.2357023

> eigen(cbind(-1, c(1:2,0), 0:2)) # complex values
eigen() decomposition
$values
[1]  1.8846462+0.589743i  1.8846462-0.589743i -0.7692924+0.000000i

$vectors
                     [,1]                 [,2]         [,3]
[1,] 0.2777976-0.0567935i 0.2777976+0.0567935i 0.9191652+0i
[2,] 0.8348414+0.0000000i 0.8348414+0.0000000i 0.2120584+0i
[3,] 0.1814955+0.4355482i 0.1814955-0.4355482i 0.3319134+0i

> 
> 
> 
> 
> cleanEx()
> nameEx("encodeString")
> ### * encodeString
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: encodeString
> ### Title: Encode Character Vector as for Printing
> ### Aliases: encodeString
> ### Keywords: utilities
> 
> ### ** Examples
> 
> x <- "ab\bc\ndef"
> print(x)
[1] "ab\bc\ndef"
> cat(x) # interprets escapes
abc
def> cat(encodeString(x), "\n", sep = "") # similar to print()
ab\bc\ndef
> 
> factor(x) # makes use of this to print the levels
[1] ab\bc\ndef
Levels: ab\bc\ndef
> 
> x <- c("a", "ab", "abcde")
> encodeString(x) # width = 0: use as little as possible
[1] "a"     "ab"    "abcde"
> encodeString(x, 2) # use two or more (left justified)
[1] "a "    "ab"    "abcde"
> encodeString(x, width = NA) # left justification
[1] "a    " "ab   " "abcde"
> encodeString(x, width = NA, justify = "c")
[1] "  a  " " ab  " "abcde"
> encodeString(x, width = NA, justify = "r")
[1] "    a" "   ab" "abcde"
> encodeString(x, width = NA, quote = "'", justify = "r")
[1] "    'a'" "   'ab'" "'abcde'"
> 
> 
> 
> cleanEx()
> nameEx("environment")
> ### * environment
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: environment
> ### Title: Environment Access
> ### Aliases: environment environment<- .GlobalEnv globalenv emptyenv
> ###   baseenv is.environment new.env parent.env parent.env<-
> ###   .BaseNamespaceEnv environmentName env.profile enclosure
> ### Keywords: data programming
> 
> ### ** Examples
> 
> f <- function() "top level function"
> 
> ##-- all three give the same:
> environment()
<environment: R_GlobalEnv>
> environment(f)
<environment: R_GlobalEnv>
> .GlobalEnv
<environment: R_GlobalEnv>
> 
> ls(envir = environment(stats::approxfun(1:2, 1:2, method = "const")))
[1] "f"      "method" "na.rm"  "x"      "y"      "yleft"  "yright"
> 
> is.environment(.GlobalEnv) # TRUE
[1] TRUE
> 
> e1 <- new.env(parent = baseenv())  # this one has enclosure package:base.
> e2 <- new.env(parent = e1)
> assign("a", 3, envir = e1)
> ls(e1)
[1] "a"
> ls(e2)
character(0)
> exists("a", envir = e2)   # this succeeds by inheritance
[1] TRUE
> exists("a", envir = e2, inherits = FALSE)
[1] FALSE
> exists("+", envir = e2)   # this succeeds by inheritance
[1] TRUE
> 
> eh <- new.env(hash = TRUE, size = NA)
> with(env.profile(eh), stopifnot(size == length(counts)))
> 
> 
> 
> cleanEx()
> nameEx("eval")
> ### * eval
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: eval
> ### Title: Evaluate an (Unevaluated) Expression
> ### Aliases: eval evalq eval.parent local
> ### Keywords: data programming
> 
> ### ** Examples
> 
> eval(2 ^ 2 ^ 3)
[1] 256
> mEx <- expression(2^2^3); mEx; 1 + eval(mEx)
expression(2^2^3)
[1] 257
> eval({ xx <- pi; xx^2}) ; xx
[1] 9.869604
[1] 3.141593
> 
> a <- 3 ; aa <- 4 ; evalq(evalq(a+b+aa, list(a = 1)), list(b = 5)) # == 10
[1] 10
> a <- 3 ; aa <- 4 ; evalq(evalq(a+b+aa, -1), list(b = 5))        # == 12
[1] 12
> 
> ev <- function() {
+    e1 <- parent.frame()
+    ## Evaluate a in e1
+    aa <- eval(expression(a), e1)
+    ## evaluate the expression bound to a in e1
+    a <- expression(x+y)
+    list(aa = aa, eval = eval(a, e1))
+ }
> tst.ev <- function(a = 7) { x <- pi; y <- 1; ev() }
> tst.ev()  #-> aa : 7,  eval : 4.14
$aa
[1] 7

$eval
[1] 4.141593

> 
> a <- list(a = 3, b = 4)
> with(a, a <- 5) # alters the copy of a from the list, discarded.
> 
> ##
> ## Example of evalq()
> ##
> 
> N <- 3
> env <- new.env()
> assign("N", 27, envir = env)
> ## this version changes the visible copy of N only, since the argument
> ## passed to eval is '4'.
> eval(N <- 4, env)
[1] 4
> N
[1] 4
> get("N", envir = env)
[1] 27
> ## this version does the assignment in env, and changes N only there.
> evalq(N <- 5, env)
> N
[1] 4
> get("N", envir = env)
[1] 5
> 
> 
> ##
> ## Uses of local()
> ##
> 
> # Mutually recursive.
> # gg gets value of last assignment, an anonymous version of f.
> 
> gg <- local({
+     k <- function(y)f(y)
+     f <- function(x) if(x) x*k(x-1) else 1
+ })
> gg(10)
[1] 3628800
> sapply(1:5, gg)
[1]   1   2   6  24 120
> 
> # Nesting locals: a is private storage accessible to k
> gg <- local({
+     k <- local({
+         a <- 1
+         function(y){print(a <<- a+1);f(y)}
+     })
+     f <- function(x) if(x) x*k(x-1) else 1
+ })
> sapply(1:5, gg)
[1] 2
[1] 3
[1] 4
[1] 5
[1] 6
[1] 7
[1] 8
[1] 9
[1] 10
[1] 11
[1] 12
[1] 13
[1] 14
[1] 15
[1] 16
[1]   1   2   6  24 120
> 
> ls(envir = environment(gg))
[1] "f" "k"
> ls(envir = environment(get("k", envir = environment(gg))))
[1] "a"
> 
> 
> 
> cleanEx()
> nameEx("exists")
> ### * exists
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: exists
> ### Title: Is an Object Defined?
> ### Aliases: exists get0
> ### Keywords: data
> 
> ### ** Examples
> 
> ##  Define a substitute function if necessary:
> if(!exists("some.fun", mode = "function"))
+   some.fun <- function(x) { cat("some.fun(x)\n"); x }
> search()
 [1] ".GlobalEnv"        "CheckExEnv"        "package:stats"    
 [4] "package:graphics"  "package:grDevices" "package:utils"    
 [7] "package:datasets"  "package:methods"   "Autoloads"        
[10] "package:base"     
> exists("ls", 2) # true even though ls is in pos = 3
[1] TRUE
> exists("ls", 2, inherits = FALSE) # false
[1] FALSE
> 
> ## These are true (in most circumstances):
> identical(ls,   get0("ls"))
[1] TRUE
> identical(NULL, get0(".foo.bar.")) # default ifnotfound = NULL (!)
[1] TRUE
> ## Don't show: 
> stopifnot(identical(ls, get0("ls")),
+           is.null(get0(".foo.bar.")))
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("expand.grid")
> ### * expand.grid
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: expand.grid
> ### Title: Create a Data Frame from All Combinations of Factor Variables
> ### Aliases: expand.grid
> ### Keywords: models array
> 
> ### ** Examples
> 
> require(utils)
> 
> expand.grid(height = seq(60, 80, 5), weight = seq(100, 300, 50),
+             sex = c("Male","Female"))
   height weight    sex
1      60    100   Male
2      65    100   Male
3      70    100   Male
4      75    100   Male
5      80    100   Male
6      60    150   Male
7      65    150   Male
8      70    150   Male
9      75    150   Male
10     80    150   Male
11     60    200   Male
12     65    200   Male
13     70    200   Male
14     75    200   Male
15     80    200   Male
16     60    250   Male
17     65    250   Male
18     70    250   Male
19     75    250   Male
20     80    250   Male
21     60    300   Male
22     65    300   Male
23     70    300   Male
24     75    300   Male
25     80    300   Male
26     60    100 Female
27     65    100 Female
28     70    100 Female
29     75    100 Female
30     80    100 Female
31     60    150 Female
32     65    150 Female
33     70    150 Female
34     75    150 Female
35     80    150 Female
36     60    200 Female
37     65    200 Female
38     70    200 Female
39     75    200 Female
40     80    200 Female
41     60    250 Female
42     65    250 Female
43     70    250 Female
44     75    250 Female
45     80    250 Female
46     60    300 Female
47     65    300 Female
48     70    300 Female
49     75    300 Female
50     80    300 Female
> 
> x <- seq(0, 10, length.out = 100)
> y <- seq(-1, 1, length.out = 20)
> d1 <- expand.grid(x = x, y = y)
> d2 <- expand.grid(x = x, y = y, KEEP.OUT.ATTRS = FALSE)
> object.size(d1) - object.size(d2)
9904 bytes
> ##-> 5992 or 8832 (on 32- / 64-bit platform)
> ## Don't show: 
> stopifnot(object.size(d1) > object.size(d2))
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("expression")
> ### * expression
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: expression
> ### Title: Unevaluated Expressions
> ### Aliases: expression is.expression as.expression as.expression.default
> ### Keywords: programming dplot
> 
> ### ** Examples
> 
> length(ex1 <- expression(1 + 0:9)) # 1
[1] 1
> ex1
expression(1 + 0:9)
> eval(ex1) # 1:10
 [1]  1  2  3  4  5  6  7  8  9 10
> 
> length(ex3 <- expression(u, 2, u + 0:9)) # 3
[1] 3
> mode(ex3 [3])   # expression
[1] "expression"
> mode(ex3[[3]])  # call
[1] "call"
> ## but not all components are 'call's :
> sapply(ex3, mode  ) #  name  numeric  call
[1] "name"    "numeric" "call"   
> sapply(ex3, typeof) # symbol  double  language
[1] "symbol"   "double"   "language"
> rm(ex3)
> 
> 
> 
> cleanEx()
> nameEx("extSoftVersion")
> ### * extSoftVersion
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: extSoftVersion
> ### Title: Report Versions of Third-Party Software
> ### Aliases: extSoftVersion
> 
> ### ** Examples
> 
> extSoftVersion()
                                                               zlib 
                                                           "1.2.11" 
                                                              bzlib 
                                               "1.0.8, 13-Jul-2019" 
                                                                 xz 
                                                            "5.2.4" 
                                                               PCRE 
                                                 "10.34 2019-11-21" 
                                                                ICU 
                                                             "66.1" 
                                                                TRE 
                                          "TRE 0.8.0 R_fixes (BSD)" 
                                                              iconv 
                                                       "glibc 2.31" 
                                                           readline 
                                                              "8.0" 
                                                               BLAS 
"/usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.8.so" 
> ## the PCRE version
> sub(" .*", "", extSoftVersion()["PCRE"])
   PCRE 
"10.34" 
> 
> 
> 
> cleanEx()
> nameEx("factor")
> ### * factor
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: factor
> ### Title: Factors
> ### Aliases: factor ordered is.factor is.ordered as.factor as.ordered
> ###   is.na<-.factor Math.factor Ops.factor Summary.factor Ops.ordered
> ###   Summary.ordered addNA .valid.factor
> ### Keywords: category NA
> 
> ### ** Examples
> 
> (ff <- factor(substring("statistics", 1:10, 1:10), levels = letters))
 [1] s t a t i s t i c s
Levels: a b c d e f g h i j k l m n o p q r s t u v w x y z
> as.integer(ff)      # the internal codes
 [1] 19 20  1 20  9 19 20  9  3 19
> (f. <- factor(ff))  # drops the levels that do not occur
 [1] s t a t i s t i c s
Levels: a c i s t
> ff[, drop = TRUE]   # the same, more transparently
 [1] s t a t i s t i c s
Levels: a c i s t
> 
> factor(letters[1:20], labels = "letter")
 [1] letter1  letter2  letter3  letter4  letter5  letter6  letter7  letter8 
 [9] letter9  letter10 letter11 letter12 letter13 letter14 letter15 letter16
[17] letter17 letter18 letter19 letter20
20 Levels: letter1 letter2 letter3 letter4 letter5 letter6 letter7 ... letter20
> 
> class(ordered(4:1)) # "ordered", inheriting from "factor"
[1] "ordered" "factor" 
> z <- factor(LETTERS[3:1], ordered = TRUE)
> ## and "relational" methods work:
> stopifnot(sort(z)[c(1,3)] == range(z), min(z) < max(z))
> ## Don't show: 
> of <- ordered(ff)
> stopifnot(identical(range(of, rev(of)), of[3:2]),
+ 	  identical(max(of), of[2]))
> ## End(Don't show)
> 
> ## suppose you want "NA" as a level, and to allow missing values.
> (x <- factor(c(1, 2, NA), exclude = NULL))
[1] 1    2    <NA>
Levels: 1 2 <NA>
> is.na(x)[2] <- TRUE
> x  # [1] 1    <NA> <NA>
[1] 1    <NA> <NA>
Levels: 1 2 <NA>
> is.na(x)
[1] FALSE  TRUE FALSE
> # [1] FALSE  TRUE FALSE
> 
> ## More rational, since R 3.4.0 :
> factor(c(1:2, NA), exclude =  "" ) # keeps <NA> , as
[1] 1    2    <NA>
Levels: 1 2 <NA>
> factor(c(1:2, NA), exclude = NULL) # always did
[1] 1    2    <NA>
Levels: 1 2 <NA>
> ## exclude = <character>
> z # ordered levels 'A < B < C'
[1] C B A
Levels: A < B < C
> factor(z, exclude = "C") # does exclude
[1] <NA> B    A   
Levels: A < B
> factor(z, exclude = "B") # ditto
[1] C    <NA> A   
Levels: A < C
> 
> ## Now, labels maybe duplicated:
> ## factor() with duplicated labels allowing to "merge levels"
> x <- c("Man", "Male", "Man", "Lady", "Female")
> ## Map from 4 different values to only two levels:
> (xf <- factor(x, levels = c("Male", "Man" , "Lady",   "Female"),
+                  labels = c("Male", "Male", "Female", "Female")))
[1] Male   Male   Male   Female Female
Levels: Male Female
> #> [1] Male   Male   Male   Female Female
> #> Levels: Male Female
> 
> ## Using addNA()
> Month <- airquality$Month
> table(addNA(Month))

   5    6    7    8    9 <NA> 
  31   30   31   31   30    0 
> table(addNA(Month, ifany = TRUE))

 5  6  7  8  9 
31 30 31 31 30 
> 
> 
> 
> cleanEx()
> nameEx("file.access")
> ### * file.access
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: file.access
> ### Title: Ascertain File Accessibility
> ### Aliases: file.access
> ### Keywords: file
> 
> ### ** Examples
> 
> fa <- file.access(dir("."))
> table(fa) # count successes & failures
fa
0 
4 
> 
> 
> cleanEx()
> nameEx("file.info")
> ### * file.info
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: file.info
> ### Title: Extract File Information
> ### Aliases: file.info file.mode file.mtime file.size
> ### Keywords: file
> 
> ### ** Examples
> 
> ncol(finf <- file.info(dir()))  # at least six
[1] 10
> ## Those that are more than 100 days old :
> finf <- file.info(dir(), extra_cols = FALSE)
> finf[difftime(Sys.time(), finf[,"mtime"], units = "days") > 100 , 1:4]
[1] size  isdir mode  mtime
<0 rows> (or 0-length row.names)
> 
> file.info("no-such-file-exists")
                    size isdir mode mtime ctime atime uid gid uname grname
no-such-file-exists   NA    NA <NA>  <NA>  <NA>  <NA>  NA  NA  <NA>   <NA>
> 
> 
> 
> cleanEx()
> nameEx("file.show")
> ### * file.show
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: file.show
> ### Title: Display One or More Text Files
> ### Aliases: file.show
> ### Keywords: file
> 
> ### ** Examples
> 
> file.show(file.path(R.home("doc"), "COPYRIGHTS"))

COPYRIGHT STATUS

The bulk of this code is copyright by members of or all of the R Core
Team.  ('The R Core Team' in copyright statements in individual files
refers to some or all of the team.)

See the file COPYING for the exact conditions under which you may
redistribute it.  R as a whole is distributed under GPL version 2 or
3: most source files contain a copyright statement allowing use of
that file under GPL version 2 or later: the main exceptions are the
included versions of packages 'MASS', 'class', 'nnet', 'rpart' and
'spatial' (GPL-2 or GPL-3).  (The auxiliary file m4/openmp.m4 is under
GPL-3, but its incorporation into 'configure' is not.)

The status of files used only in the Windows port is in file
src/gnuwin32/COPYRIGHTS.win, which is appended to this file in binary
Windows distributions.

Note that almost all the code *is* copyright and may only be
reproduced if the copyright notice (that in the file or this notice)
is preserved.  The status of the included LINPACK routines is unclear:
they are said to be in the public domain in the USA.

	---------------------------------------------------

Some (but not all) of the public header files are distributed under
the more permissive terms of version 2.1 or later of the LGPL: see
files R_HOME/share/licenses/LGPL-2.1 and R_HOME/share/licenses/LGPL-3.
This applies only to the header files

src/include/R.h
src/include/Rdefines.h
src/include/Rgraphics.h
src/include/Rinternals.h
src/include/Rmath.h
src/include/S.h
src/include/R_ext/*.h

Note that it does not apply to the header files such as Rembedded.h
and Rinterface.h used for third-party front ends.

From the announcement of the change (2001-Feb-05)

    It came to our attention that some projects are interpreting GPL to
    mean that compiling against the header files or linking against a
    Windows import library brings the compiled code under the scope of
    GPL.  This would mean it would be impossible to distribute binary
    versions of non-GPL packages with compiled code which called entry
    points in the R executable or DLL, of which there are many on CRAN.

    We encourage packages to be distributed under Open Source conditions,
    but accept that this is not possible for some contributions.  Our
    intention is that export files and import libraries be 'accessors'
    under clause 5 of the LGPL, so that in most cases no (additional)
    restrictions are imposed by compiling a package using the LGPL-ed
    components of R.

    To avoid any anomalies, the versions of the same files in R versions
    1.0.0 to 1.2.1 may also be used under LGPL or GPL.

Import libraries are no longer used under Windows.

Some contributed files are also covered by the Library General Public License.
These include (see also below)

src/library/stats/R/embed.R
src/library/stats/src/PPsum.c

	---------------------------------------------------




Some of the code contains different copyright statements.  It is used
here in accordance with the copyright conditions in that code.  A
not-necessarily-complete list of such files is:

src/library/grDevices/inst/afm/*___.afm

	Copyright (c) 1984 to 1992 Adobe Systems Incorporated.

src/library/grDevices/inst/afm/MustRead.html
src/library/grDevices/inst/afm/Courier*.afm
src/library/grDevices/inst/afm/Helvetica*.afm
src/library/grDevices/inst/afm/Times*.afm
src/library/grDevices/inst/afm/Symbol.afm
src/library/grDevices/inst/afm/ZapfDingbats.afm

	Copyright (c) 1985, 1987, 1989, 1990, 1993, 1997 Adobe Systems
	Incorporated.  All Rights Reserved.

src/library/grDevices/inst/afm/*l.afm

	Copyright 1999 by (URW)++ Design & Development

src/library/grDevices/inst/afm/CM_*.afm
src/library/grDevices/inst/afm/cm*.afm

	are derived from afms which are copyright by the American
	Mathematical Society, but 'the AMS does require that the
	AMS copyright notice be removed from any derivative versions
	of the fonts which have been altered in any way'.

doc/manual/R-intro.texi

in part

	Copyright (C) 1990 W. N. Venables
	Copyright (C) 1992 W. N. Venables & D. M. Smith
	Copyright (C) 1997 R. Gentleman & R. Ihaka
	Copyright (C) 1997, 1998 M. Maechler

share/licenses/*

	See the individual files.

share/texmf/bibtex/bst/jss.bst

	Copyright 1994-2007 Patrick W Daly

share/texmf/tex/latex/jss.cls

	Copyright: (C) Achim Zeileis

src/library/graphics/R/mosaicplot.R

	Original code copyright (C) 1998 John W. Emerson

src/library/graphics/R/pairs.R

	In part, Copyright 1999 Dr. Jens Oehlschlaegel-Akiyoshi

src/library/graphics/R/polygon.R

	Copyright (C) 2001 by Kevin Buhr <buhr@stat.wisc.edu>

src/library/splines/R/splineClasses.R

	Copyright (C) 1998 Douglas M. Bates and William N. Venables.

src/library/datasets/man/austres.Rd
src/library/datasets/man/beavers.Rd
src/library/datasets/man/lh.Rd
src/library/datasets/man/npk.Rd
src/library/datasets/man/rock.Rd
src/library/datasets/man/UKLungDeaths.Rd
src/library/datasets/man/USAccDeaths.Rd
src/library/stats/R/add.R
src/library/stats/R/bandwidths.R
src/library/stats/R/confint.R
src/library/stats/R/cpgram.R
src/library/stats/R/spectrum.R
src/library/stats/R/vcov.R
src/library/stats/src//bandwidths.c
src/appl/maxcol.c

	Copyright (C) various dates W. N. Venables and B. D. Ripley


src/appl/interv.c : moved to API from code originally in
		    src/library/stats/src/bvalue.f, see
		    src/library/stats/COPYRIGHTS.modreg

src/library/stats:

	See the files src/library/stats/COPYRIGHTS.modreg and
	src/library/stats/COPYRIGHTS.portsrc for further details


src/library/stats/R/diffinv.R
src/library/stats/R/embed.R
src/library/stats/R/kernel.R
src/library/stats/src/PPsum.c

	Copyright (C) 1997-1999	 Adrian Trapletti


src/library/stats/R/nls.R

	In part, Copyright 1999-1999 Saikat DebRoy


src/library/stats/R/nlsFunc.R
src/library/stats/R/selfStart.R
src/library/stats/R/zzModels.R

	Copyright 1997,1999 Jose C. Pinheiro, Douglas M. Bates

src/library/stats/R/runmed.R
src/library/stats/src/Trunmed.c

	In part Copyright (C) 1995 Berwin A. Turlach

src/library/stats/src/loessc.c
src/library/stats/src/loessf.f

	In part Copyright (c) 1989, 1992 by AT&T

src/library/stats/R/spline.R

	In part, Copyright (C) 2002 Simon N. Wood

src/library/tcltk/exec/{hierarchy,util*,widget}.tcl

	Copyright (c) various dates Jeffrey Hobbs


src/modules/X11/rotated.[ch]

	Copyright (c) 1993 Alan Richardson


src/appl/loglin.c
src/library/stats/src/chisqsim.c
src/library/stats/src/nscor.c
src/library/stats/src/prho.c
src/library/stats/src/swilk.c
src/library/stats/src/kmns.f
src/library/stats/src/starma.c
src/nmath/pnbeta.c
src/nmath/pnchisq.c
src/nmath/pnt.c
src/nmath/qbeta.c
src/nmath/qgamma.c
src/nmath/qnorm.c
src/nmath/qtukey.c
  are based in whole or in part on Applied Statistics algorithms
  (C) Royal Statistical Society

src/nmath/stirlerr.c
src/nmath/dbinom.c
src/nmath/dpois.c
  are partly based on Catherine/Clive Loader's (1999) work,
  (C) 1999-2000 Lucent Technologies, Bell Laboratories.


src/main/RNG.c

  The Mersenne-Twister part is
  Copyright (C) 1997, 1999 Makoto Matsumoto and Takuji Nishimura.


src/main/xspline.c

 * Copyright (c) 1985-1988 by Supoj Sutanthavibul
 * Parts Copyright (c) 1989-2002 by Brian V. Smith
 * Parts Copyright (c) 1991 by Paul King
 * Parts Copyright (c) 1992 by James Tough
 * Parts Copyright (c) 1998 by Georg Stemmer
 * Parts Copyright (c) 1995 by C. Blanc and C. Schlick
  
 * Any party obtaining a copy of these files is granted, free of charge, a
 * full and unrestricted irrevocable, world-wide, paid up, royalty-free,
 * nonexclusive right and license to deal in this software and
 * documentation files (the "Software"), including without limitation the
 * rights to use, copy, modify, merge, publish and/or distribute copies of
 * the Software, and to permit persons who receive copies from any such 
 * party to do so, with the only requirement being that this copyright 
 * notice remain intact.


src/modules/nano{ftp,http}.c

 Copyright (C) 1998-2001 Daniel Veillard.  All Rights Reserved.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is fur-
nished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FIT-
NESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.


src/modules/lapack/dlapack.f, cmplx.f, dlamc.f

  Extracted from
  *  -- LAPACK computational routine (version 3.9.0) --
  *  -- LAPACK is a software package provided by Univ. of Tennessee,    --
  *  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
  *     November 2017

  where the version number, providers and date vary by subroutine.
  For version 3.7.0, many of the copyright dates were updated
  even for routines which have not been changed for years.

  LAPACK 3.9.0 contains a LICENSE file, copied to src/modules/lapack
  (but many of these routines were originally copied from earlier
  versions of LAPACK).  For binary distributions it is reproduced here:

  --- src/modules/lapack/LICENSE ---
  Copyright (c) 1992-2017 The University of Tennessee and The University
                          of Tennessee Research Foundation.  All rights
                          reserved.
  Copyright (c) 2000-2017 The University of California Berkeley. All
                          rights reserved.
  Copyright (c) 2006-2017 The University of Colorado Denver.  All rights
                          reserved.

  $COPYRIGHT$

  Additional copyrights may follow

  $HEADER$

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are
  met:

  - Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

  - Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer listed
    in this license in the documentation and/or other materials
    provided with the distribution.

  - Neither the name of the copyright holders nor the names of its
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

  The copyright holders provide no reassurances that the source code
  provided does not infringe any patent, copyright, or any other
  intellectual property rights of third parties.  The copyright holders
  disclaim any liability to any recipient for claims brought against
  recipient by any third party for infringement of that parties
  intellectual property rights.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  --- end of src/modules/lapack/LICENSE ---

src/extra/xdr/*

	Copyright (undated) Sun Microsystems, Inc.

	See the file src/extra/xdr/copyrght.txt

src/main/connections.c, src/main/gzio.h

  Contain code derived from the zlib 1.2.3 distribution
  (C) 1995-2005 Jean-loup Gailly and Mark Adler

src/main/dounzip.c, unzip.h

  Contain code Copyright (C) 1998-2010 Gilles Vollant from contrib/minizip
  in the zlib 1.2.3 distribution with updates taken from 1.2.5.


src/main/valid_utf8.h

   Copyright (c) 1997-2012 University of Cambridge

For binary builds of R that requires us to include

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

      * Redistributions of source code must retain the above copyright
	notice, this list of conditions and the following disclaimer.

      * Redistributions in binary form must reproduce the above
	copyright notice, this list of conditions and the following
	disclaimer in the documentation and/or other materials
	provided with the distribution.

      * Neither the name of the University of Cambridge nor the name
	of Google Inc. nor the names of their contributors may be used
	to endorse or promote products derived from this software
	without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.


src/extra/tre/LICENSE
src/extra/tre/*.[ch]

Copyright (c) 2001-2009 Ville Laurikari <vl@iki.fi>
All rights reserved.

From tre-0.8.0 (https://laurikari.net/tre/).  See file
src/extra/tre/LICENSE.  For binary builds of R that requires us to
include

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright notice,
      this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

    * Neither the name of the University of Cambridge nor the name of Google
      Inc. nor the names of their contributors may be used to endorse or
      promote products derived from this software without specific prior
      written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.

src/extra/tzone/strftime.c
/*
  Based on code from tzcode, which is turn said to be
  'Based on the UCB version with the copyright notice appearing below.'

** Copyright (c) 1989 The Regents of the University of California.
** All rights reserved.
**
** Redistribution and use in source and binary forms are permitted
** provided that the above copyright notice and this paragraph are
** duplicated in all such forms and that any documentation,
** advertising materials, and other materials related to such
** distribution and use acknowledge that the software was developed
** by the University of California, Berkeley. The name of the
** University may not be used to endorse or promote products derived
** from this software without specific prior written permission.
** THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
** IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
** WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/


src/library/tools/src/md5.[ch]

    Copyright (C) 1995, 1996, 2001 Free Software Foundation, Inc.


src/extra/intl/*

Based on gettextize from gettext 0.17
   Copyright (C) various dates Free Software Foundation, Inc.
   Distributed under the GNU Library General Public License
   version 2 or later.

src/include/vg/memcheck.h
src/include/vg/valgrind.h

From valgrind 3.10.1,

   Copyright (C) 2000-2013 Julian Seward.  All rights reserved.


src/main/mkdtemp.c

From glibc via
http://lists.gnu.org/archive/html/bug-gnulib/2003-02/msg00019.html

   Copyright (C) 1999, 2001-2003 Free Software Foundation, Inc.
   Distributed under the GNU Library General Public License
   version 2 or later.

src/main/Rstrptime.h

   Copyright (C) 1996, 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
   Distributed under the GNU Library General Public License
   version 2 or later.

src/library/*/po/*.po

   Some of the translations are (C) the translator as marked in the files.

COPYING
doc/COPYING
doc/COPYING.LIB
m4/codeset.m4
m4/gettext.m4
m4/gettext-lib.m4
share/licenses/GPL-2
share/licenses/GPL-3
share/licenses/LGPL-2
share/licenses/LGPL-2.1
share/licenses/LGPL-3
src/main/strdup.c
tools/config.rpath
tools/help2man.pl
tools/ltmain.sh
tools/mdate-sh
tools/missing

   Copyright various dates Free Software Foundation

m4/openmp.m4
  Copyright (C) 2001-2012 Free Software Foundation, Inc.
  Copyright (C) 2015-2016 R Core Team

  Under GPL-3 with the Autoconf Configure Script Exception, version 3.0.

tools/config.quess
tools/config.sub

   Copyright 1992-2019 Free Software Foundation.  
   The Exception to GPL-3 applies.

tools/install-sh

   Copyright (C) 1994 X Consortium

m4/cxx_11.m4
#   Copyright (c) 2008 Benjamin Kosnik <bkoz@redhat.com>
#   Copyright (c) 2012 Zack Weinberg <zackw@panix.com>
#   Copyright (c) 2013 Roy Stogner <roystgnr@ices.utexas.edu>

m4/stat-time.m4

From GNU coreutils 8.12
# Copyright (C) 1998-1999, 2001, 2003, 2005-2007, 2009-2011 Free Software
# Foundation, Inc.

# This file is free software; the Free Software Foundation
# gives unlimited permission to copy and/or distribute it,
# with or without modifications, as long as this notice is preserved.

src/main/gram.y
src/main/gram.c

Portions of these files are based on the parser package,

   Copyright (C) 2009--2011  Romain Francois
   

Some of the files in src/appl were originally taken from the Netlib
archive now at www.netlib.org and do not clearly state their
copyright status.

src/appl/{dchdc,dpfa,dpbsl,dpoco,dpodi,dpofa,dposl,dqrdc,
          dqrsl,dsvdc,dtrco,dtrsl}.f 

are part of LINPACK, with authors J.J. Dongarra, Cleve Moler and
G.W. Stewart

src/appl/dqrdc2.f is based on dqrdc.f by G.W. Stewart.

src/appl/lbfgsb.c is based on the work of Zhu, Byrd, Lu-Chen and
Nocedal, which does not state any copyright.

src/main/radixsort.c is largely based on code from the data.table package,

   Copyright (C) 2006--2015  Matt Dowle and Arun Srinivasan

doc/html/Rlogo.svg
doc/html/Rlogo.pdf
doc/html/logo.jpg
doc/html/favicon.ico
src/modules/X11/rlogo_icon.h
src/gnuwin32/front-ends/R.ico
src/gnuwin32/installer/R.bmp

   Copyright (C) 2015-2016 The R Foundation
   
   You can distribute the logo under the terms of the Creative
   Commons Attribution-ShareAlike 4.0 International license (CC-BY-SA
   4.0) or (at your option) the GNU General Public License version 2
   (GPL-2).

   The design of the current logo is based on the previous logo that
   was included in the R source from 1998 to 2016.

	---------------------------------------------------

Binary distributions of R may include compiled code from the PCRE2
library whose licence is:

THE BASIC LIBRARY FUNCTIONS
---------------------------

Written by:       Philip Hazel
Email local part: ph10
Email domain:     cam.ac.uk

University of Cambridge Computing Service,
Cambridge, England.

Copyright (c) 1997-2020 University of Cambridge
All rights reserved.


PCRE2 JUST-IN-TIME COMPILATION SUPPORT
--------------------------------------

Written by:       Zoltan Herczeg
Email local part: hzmester
Email domain:     freemail.hu

Copyright(c) 2010-2020 Zoltan Herczeg
All rights reserved.


STACK-LESS JUST-IN-TIME COMPILER
--------------------------------

Written by:       Zoltan Herczeg
Email local part: hzmester
Email domain:     freemail.hu

Copyright(c) 2009-2020 Zoltan Herczeg
All rights reserved.

THE "BSD" LICENCE
-----------------

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright notices,
      this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above copyright
      notices, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

    * Neither the name of the University of Cambridge nor the names of any
      contributors may be used to endorse or promote products derived from this
      software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.


EXEMPTION FOR BINARY LIBRARY-LIKE PACKAGES
------------------------------------------

The second condition in the BSD licence (covering binary redistributions) does
not apply all the way down a chain of software. If binary package A includes
PCRE2, it must respect the condition, but if package B is software that
includes package A, the condition is not imposed on package B unless it uses
PCRE2 independently.


Or they may include compiled code from the PCRE library whose licence
is:

  THE BASIC LIBRARY FUNCTIONS
  ---------------------------
  Written by:       Philip Hazel
  Email local part: ph10
  Email domain:     cam.ac.uk

  University of Cambridge Computing Service, Cambridge, England.

  Copyright (c) 1997-2015 University of Cambridge
  All rights reserved.

  PCRE JUST-IN-TIME COMPILATION SUPPORT
  -------------------------------------
  Written by:       Zoltan Herczeg
  Email local part: hzmester
  Emain domain:     freemail.hu

  Copyright(c) 2010-2015 Zoltan Herczeg
  All rights reserved.

  STACK-LESS JUST-IN-TIME COMPILER
  --------------------------------
  Written by:       Zoltan Herczeg
  Email local part: hzmester
  Emain domain:     freemail.hu

  Copyright(c) 2009-2015 Zoltan Herczeg
  All rights reserved.

  THE C++ WRAPPER FUNCTIONS
  -------------------------
  Contributed by:   Google Inc.

  Copyright (c) 2007-2012, Google Inc.
  All rights reserved.


  THE "BSD" LICENCE
  -----------------

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

      * Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.

      * Redistributions in binary form must reproduce the above
        copyright notice, this list of conditions and the following
        disclaimer in the documentation and/or other materials
        provided with the distribution.

      * Neither the name of the University of Cambridge nor the name
        of Google Inc. nor the names of their contributors may be used
        to endorse or promote products derived from this software
        without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.

	---------------------------------------------------

> 
> 
> 
> cleanEx()
> nameEx("files")
> ### * files
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: files
> ### Title: File Manipulation
> ### Aliases: files file.append file.copy file.create file.exists
> ###   file.remove file.rename file.symlink file.link
> ### Keywords: file
> 
> ### ** Examples
> 
> ## Don't show: 
> oldwd <- setwd(tempdir())
> ## End(Don't show)
> cat("file A\n", file = "A")
> cat("file B\n", file = "B")
> file.append("A", "B")
[1] TRUE
> file.create("A") # (trashing previous)
[1] TRUE
> file.append("A", rep("B", 10))
 [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
> if(interactive()) file.show("A") # -> the 10 lines from 'B'
> file.copy("A", "C")
[1] TRUE
> dir.create("tmp")
> file.copy(c("A", "B"), "tmp")
[1] TRUE TRUE
> list.files("tmp") # -> "A" and "B"
[1] "A" "B"
> setwd("tmp")
> file.remove("A") # the tmp/A file
[1] TRUE
> file.symlink(file.path("..", c("A", "B")), ".")
Warning in file.symlink(file.path("..", c("A", "B")), ".") :
  cannot symlink '../B' to './B', reason 'File exists'
[1]  TRUE FALSE
>                      # |--> (TRUE,FALSE) : ok for A but not B as it exists already
> setwd("..")
> unlink("tmp", recursive = TRUE)
> file.remove("A", "B", "C")
[1] TRUE TRUE TRUE
> ## Don't show: 
> setwd(oldwd)
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("files2")
> ### * files2
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: files2
> ### Title: Manipulation of Directories and File Permissions
> ### Aliases: dir.create dir.exists Sys.chmod Sys.umask umask
> ### Keywords: file
> 
> ### ** Examples
> ## Not run: 
> ##D ## Fix up maximal allowed permissions in a file tree
> ##D Sys.chmod(list.dirs("."), "777")
> ##D f <- list.files(".", all.files = TRUE, full.names = TRUE, recursive = TRUE)
> ##D Sys.chmod(f, (file.info(f)$mode | "664"))
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("find.package")
> ### * find.package
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: find.package
> ### Title: Find Packages
> ### Aliases: find.package path.package packageNotFoundError
> ### Keywords: files
> 
> ### ** Examples
> 
> try(find.package("knitr"))
[1] "/usr/local/lib/R/site-library/knitr"
> ## will not give an error, maybe a warning about *all* locations it is found:
> find.package("kitty", quiet=TRUE, verbose=TRUE)
character(0)
> 
> ## Find all .libPaths() entries a package is found:
> findPkgAll <- function(pkg)
+   unlist(lapply(.libPaths(), function(lib)
+            find.package(pkg, lib, quiet=TRUE, verbose=FALSE)))
> 
> findPkgAll("MASS")
[1] "/usr/local/lib/R/library/MASS"
> findPkgAll("knitr")
[1] "/usr/local/lib/R/site-library/knitr"
> 
> 
> 
> cleanEx()
> nameEx("findInterval")
> ### * findInterval
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: findInterval
> ### Title: Find Interval Numbers or Indices
> ### Aliases: findInterval
> ### Keywords: arith utilities
> 
> ### ** Examples
> 
> x <- 2:18
> v <- c(5, 10, 15) # create two bins [5,10) and [10,15)
> cbind(x, findInterval(x, v))
       x  
 [1,]  2 0
 [2,]  3 0
 [3,]  4 0
 [4,]  5 1
 [5,]  6 1
 [6,]  7 1
 [7,]  8 1
 [8,]  9 1
 [9,] 10 2
[10,] 11 2
[11,] 12 2
[12,] 13 2
[13,] 14 2
[14,] 15 3
[15,] 16 3
[16,] 17 3
[17,] 18 3
> 
> N <- 100
> X <- sort(round(stats::rt(N, df = 2), 2))
> tt <- c(-100, seq(-2, 2, len = 201), +100)
> it <- findInterval(tt, X)
> tt[it < 1 | it >= N] # only first and last are outside range(X)
[1] -100  100
> 
> ##  'left.open = TRUE' means  "mirroring" :
> N <- length(v)
> stopifnot(identical(
+                   findInterval( x,  v,  left.open=TRUE) ,
+               N - findInterval(-x, -v[N:1])))
> 
> 
> 
> cleanEx()
> nameEx("force")
> ### * force
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: force
> ### Title: Force Evaluation of an Argument
> ### Aliases: force
> ### Keywords: data programming
> 
> ### ** Examples
> 
> f <- function(y) function() y
> lf <- vector("list", 5)
> for (i in seq_along(lf)) lf[[i]] <- f(i)
> lf[[1]]()  # returns 5
[1] 5
> 
> g <- function(y) { force(y); function() y }
> lg <- vector("list", 5)
> for (i in seq_along(lg)) lg[[i]] <- g(i)
> lg[[1]]()  # returns 1
[1] 1
> 
> ## This is identical to
> g <- function(y) { y; function() y }
> 
> 
> 
> cleanEx()
> nameEx("formals")
> ### * formals
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: formals
> ### Title: Access to and Manipulation of the Formal Arguments
> ### Aliases: formals formals<-
> ### Keywords: programming
> 
> ### ** Examples
> 
> require(stats)
> formals(lm)
$formula


$data


$subset


$weights


$na.action


$method
[1] "qr"

$model
[1] TRUE

$x
[1] FALSE

$y
[1] FALSE

$qr
[1] TRUE

$singular.ok
[1] TRUE

$contrasts
NULL

$offset


$...


> 
> ## If you just want the names of the arguments, use formalArgs instead.
> names(formals(lm))
 [1] "formula"     "data"        "subset"      "weights"     "na.action"  
 [6] "method"      "model"       "x"           "y"           "qr"         
[11] "singular.ok" "contrasts"   "offset"      "..."        
> methods:: formalArgs(lm)     # same
 [1] "formula"     "data"        "subset"      "weights"     "na.action"  
 [6] "method"      "model"       "x"           "y"           "qr"         
[11] "singular.ok" "contrasts"   "offset"      "..."        
> 
> ## formals returns a pairlist. Arguments with no default have type symbol (aka name).
> str(formals(lm))
Dotted pair list of 14
 $ formula    : symbol 
 $ data       : symbol 
 $ subset     : symbol 
 $ weights    : symbol 
 $ na.action  : symbol 
 $ method     : chr "qr"
 $ model      : logi TRUE
 $ x          : logi FALSE
 $ y          : logi FALSE
 $ qr         : logi TRUE
 $ singular.ok: logi TRUE
 $ contrasts  : NULL
 $ offset     : symbol 
 $ ...        : symbol 
> 
> ## formals returns NULL for primitive functions.  Use it in combination with
> ## args for this case.
> is.primitive(`+`)
[1] TRUE
> formals(`+`)
NULL
> formals(args(`+`))
$e1


$e2


> 
> ## You can overwrite the formal arguments of a function (though this is
> ## advanced, dangerous coding).
> f <- function(x) a + b
> formals(f) <- alist(a = , b = 3)
> f    # function(a, b = 3) a + b
function (a, b = 3) 
a + b
> f(2) # result = 5
[1] 5
> 
> 
> 
> cleanEx()
> nameEx("format")
> ### * format
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: format
> ### Title: Encode in a Common Format
> ### Aliases: format format.AsIs format.data.frame format.default
> ###   format.factor
> ### Keywords: character print
> 
> ### ** Examples
> 
> format(1:10)
 [1] " 1" " 2" " 3" " 4" " 5" " 6" " 7" " 8" " 9" "10"
> format(1:10, trim = TRUE)
 [1] "1"  "2"  "3"  "4"  "5"  "6"  "7"  "8"  "9"  "10"
> 
> zz <- data.frame("(row names)"= c("aaaaa", "b"), check.names = FALSE)
> format(zz)
  (row names)
1       aaaaa
2           b
> format(zz, justify = "left")
  (row names)
1       aaaaa
2       b    
> 
> ## use of nsmall
> format(13.7)
[1] "13.7"
> format(13.7, nsmall = 3)
[1] "13.700"
> format(c(6.0, 13.1), digits = 2)
[1] " 6" "13"
> format(c(6.0, 13.1), digits = 2, nsmall = 1)
[1] " 6.0" "13.1"
> 
> ## use of scientific
> format(2^31-1)
[1] "2147483647"
> format(2^31-1, scientific = TRUE)
[1] "2.147484e+09"
> 
> ## a list
> z <- list(a = letters[1:3], b = (-pi+0i)^((-2:2)/2), c = c(1,10,100,1000),
+           d = c("a", "longer", "character", "string"),
+           q = quote( a + b ), e = expression(1+x))
> ## can you find the "2" small differences?
> (f1 <- format(z, digits = 2))
                                                             a 
                                                     "a, b, c" 
                                                             b 
"-0.32+0.00i, 0.00-0.56i, 1.00+0.00i, 0.00+1.77i, -3.14+0.00i" 
                                                             c 
                                            "1, 10, 100, 1000" 
                                                             d 
                  "a        , longer   , character, string   " 
                                                             q 
                                                       "a + b" 
                                                             e 
                                           "expression(1 + x)" 
> (f2 <- format(z, digits = 2, justify = "left", trim = FALSE))
                                                                a 
                                                        "a, b, c" 
                                                                b 
"-0.32+0.00i,  0.00-0.56i,  1.00+0.00i,  0.00+1.77i, -3.14+0.00i" 
                                                                c 
                                         "   1,   10,  100, 1000" 
                                                                d 
                     "a        , longer   , character, string   " 
                                                                q 
                                                          "a + b" 
                                                                e 
                                              "expression(1 + x)" 
> f1 == f2 ## 2 FALSE, 4 TRUE
    a     b     c     d     q     e 
 TRUE FALSE FALSE  TRUE  TRUE  TRUE 
> 
> ## A "minimal" format() for S4 objects without their own format() method:
> cc <- methods::getClassDef("standardGeneric")
> format(cc) ## "<S4 class ......>"
[1] "<S4 class ‘classRepresentation’ [package “methods”] with 11 slots>"
> 
> 
> 
> cleanEx()
> nameEx("format.info")
> ### * format.info
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: format.info
> ### Title: format(.) Information
> ### Aliases: format.info
> ### Keywords: character print programming
> 
> ### ** Examples
> 
> dd <- options("digits") ; options(digits = 7) #-- for the following
> format.info(123)   # 3 0 0
[1] 3 0 0
> format.info(pi)    # 8 6 0
[1] 8 6 0
> format.info(1e8)   # 5 0 1 - exponential "1e+08"
[1] 5 0 1
> format.info(1e222) # 6 0 2 - exponential "1e+222"
[1] 6 0 2
> 
> x <- pi*10^c(-10,-2,0:2,8,20)
> names(x) <- formatC(x, width = 1, digits = 3, format = "g")
> cbind(sapply(x, format))
         [,1]          
3.14e-10 "3.141593e-10"
0.0314   "0.03141593"  
3.14     "3.141593"    
31.4     "31.41593"    
314      "314.1593"    
3.14e+08 "314159265"   
3.14e+20 "3.141593e+20"
> t(sapply(x, format.info))
         [,1] [,2] [,3]
3.14e-10   12    6    1
0.0314     10    8    0
3.14        8    6    0
31.4        8    5    0
314         8    4    0
3.14e+08    9    0    0
3.14e+20   12    6    1
> 
> ## using at least 8 digits right of "."
> t(sapply(x, format.info, nsmall = 8))
         [,1] [,2] [,3]
3.14e-10   12    6    1
0.0314     10    8    0
3.14       10    8    0
31.4       11    8    0
314        12    8    0
3.14e+08   18    8    0
3.14e+20   12    6    1
> 
> # Reset old options:
> options(dd)
> 
> 
> 
> cleanEx()
> nameEx("format.pval")
> ### * format.pval
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: format.pval
> ### Title: Format P Values
> ### Aliases: format.pval
> ### Keywords: print
> 
> ### ** Examples
> 
> format.pval(c(stats::runif(5), pi^-100, NA))
[1] "0.26551" "0.37212" "0.57285" "0.90821" "0.20168" "< 2e-16" "NA"     
> format.pval(c(0.1, 0.0001, 1e-27))
[1] "1e-01"  "1e-04"  "<2e-16"
> 
> 
> 
> cleanEx()
> nameEx("formatDL")
> ### * formatDL
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: formatDL
> ### Title: Format Description Lists
> ### Aliases: formatDL
> ### Keywords: print
> 
> ### ** Examples
> 
> ## Provide a nice summary of the numerical characteristics of the
> ## machine R is running on:
> writeLines(formatDL(unlist(.Machine)))
double.eps              2.22044604925031e-16
double.neg.eps          1.11022302462516e-16
double.xmin             2.2250738585072e-308
double.xmax             1.79769313486232e+308
double.base             2
double.digits           53
double.rounding         5
double.guard            0
double.ulp.digits       -52
double.neg.ulp.digits   -53
double.exponent         11
double.min.exp          -1022
double.max.exp          1024
integer.max             2147483647
sizeof.long             8
sizeof.longlong         8
sizeof.longdouble       16
sizeof.pointer          8
longdouble.eps          1.0842021724855e-19
longdouble.neg.eps      5.42101086242752e-20
longdouble.digits       64
longdouble.rounding     5
longdouble.guard        0
longdouble.ulp.digits   -63
longdouble.neg.ulp.digits
                        -64
longdouble.exponent     15
longdouble.min.exp      -16382
longdouble.max.exp      16384
> ## Inspect Sys.getenv() results in "list" style (by default, these are
> ## printed in "table" style):
> writeLines(formatDL(Sys.getenv(), style = "list"))
A+C: 123
BIBINPUTS:
        .:.:/usr/local/lib/R/share/texmf/bibtex/bib::/usr/local/lib/R/share/texmf/bibtex/bib:
BSTINPUTS:
        .:.:/usr/local/lib/R/share/texmf/bibtex/bst::/usr/local/lib/R/share/texmf/bibtex/bst:
CRAN: https://packagemanager.rstudio.com/all/__linux__/focal/latest
EDITOR: vi
HOME: /root
HOSTNAME: 8d9262e4ff0b
LANG: en_US.UTF-8
LC_ALL: en_US.UTF-8
LD_LIBRARY_PATH:
        /usr/local/lib/R/lib:/usr/local/lib:/usr/lib/x86_64-linux-gnu:/usr/lib/jvm/java-11-openjdk-amd64/lib/server:/usr/local/lib/R/lib:/usr/local/lib:/usr/lib/x86_64-linux-gnu:/usr/lib/jvm/java-11-openjdk-amd64/lib/server:/usr/local/lib/R/lib:/usr/local/lib:/usr/lib/x86_64-linux-gnu:/usr/lib/jvm/java-11-openjdk-amd64/lib/server:/usr/local/lib/R/lib:/usr/local/lib:/usr/lib/x86_64-linux-gnu:/usr/lib/jvm/java-11-openjdk-amd64/lib/server:/usr/local/lib/R/lib:/usr/local/lib:/usr/lib/x86_64-linux-gnu:/usr/lib/jvm/java-11-openjdk-amd64/lib/server
LN_S: ln -s
MAKE: make
PAGER: /usr/bin/pager
PATH: /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
PWD: /home/val/outputs/base
R_ARCH:
R_BROWSER: xdg-open
R_BZIPCMD: /usr/bin/bzip2
R_CMD: /usr/local/lib/R/bin/Rcmd
R_DOC_DIR: /usr/local/lib/R/doc
R_ENVIRON:
R_ENVIRON_USER:
R_GZIPCMD: /usr/bin/gzip
R_HOME: /usr/local/lib/R
R_INCLUDE_DIR: /usr/local/lib/R/include
R_LIBS:
R_LIBS_SITE:
R_LIBS_USER: ~/R/x86_64-pc-linux-gnu-library/4.0
R_OSTYPE: unix
R_PAPERSIZE: letter
R_PAPERSIZE_USER: letter
R_PDFVIEWER: /usr/bin/xdg-open
R_PLATFORM: x86_64-pc-linux-gnu
R_PRINTCMD: /usr/bin/lpr
R_PROFILE:
R_PROFILE_USER:
R_RD4PDF: times,inconsolata,hyper
R_SESSION_TMPDIR: /tmp/Rtmptzw2rA
R_SHARE_DIR: /usr/local/lib/R/share
R_STRIP_SHARED_LIB: strip --strip-unneeded
R_STRIP_STATIC_LIB: strip --strip-debug
R_SYSTEM_ABI: linux,gcc,gxx,gfortran,gfortran
R_TEXI2DVICMD: /usr/bin/texi2dvi
R_UNZIPCMD: /usr/bin/unzip
R_VERSION: 4.0.3
R_ZIPCMD: /usr/bin/zip
SED: /usr/bin/sed
SHLVL: 0
TAR: /usr/bin/tar
TERM: xterm
TEXINPUTS:
        .:.:/usr/local/lib/R/share/texmf/tex/latex::/usr/local/lib/R/share/texmf/tex/latex:
TZ: Etc/UTC
> 
> 
> 
> cleanEx()
> nameEx("formatc")
> ### * formatc
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: formatC
> ### Title: Formatting Using C-style Formats
> ### Aliases: formatC prettyNum .format.zeros
> ### Keywords: character print
> 
> ### ** Examples
> 
> xx <- pi * 10^(-5:4)
> cbind(format(xx, digits = 4), formatC(xx))
      [,1]        [,2]       
 [1,] "3.142e-05" "3.142e-05"
 [2,] "3.142e-04" "0.0003142"
 [3,] "3.142e-03" "0.003142" 
 [4,] "3.142e-02" "0.03142"  
 [5,] "3.142e-01" "0.3142"   
 [6,] "3.142e+00" "3.142"    
 [7,] "3.142e+01" "31.42"    
 [8,] "3.142e+02" "314.2"    
 [9,] "3.142e+03" "3142"     
[10,] "3.142e+04" "3.142e+04"
> cbind(formatC(xx, width = 9, flag = "-"))
      [,1]       
 [1,] "3.142e-05"
 [2,] "0.0003142"
 [3,] "0.003142 "
 [4,] "0.03142  "
 [5,] "0.3142   "
 [6,] "3.142    "
 [7,] "31.42    "
 [8,] "314.2    "
 [9,] "3142     "
[10,] "3.142e+04"
> cbind(formatC(xx, digits = 5, width = 8, format = "f", flag = "0"))
      [,1]         
 [1,] "00.00003"   
 [2,] "00.00031"   
 [3,] "00.00314"   
 [4,] "00.03142"   
 [5,] "00.31416"   
 [6,] "03.14159"   
 [7,] "31.41593"   
 [8,] "314.15927"  
 [9,] "3141.59265" 
[10,] "31415.92654"
> cbind(format(xx, digits = 4), formatC(xx, digits = 4, format = "fg"))
      [,1]        [,2]        
 [1,] "3.142e-05" "0.00003142"
 [2,] "3.142e-04" "0.0003142" 
 [3,] "3.142e-03" "0.003142"  
 [4,] "3.142e-02" "0.03142"   
 [5,] "3.142e-01" "0.3142"    
 [6,] "3.142e+00" "3.142"     
 [7,] "3.142e+01" "31.42"     
 [8,] "3.142e+02" "314.2"     
 [9,] "3.142e+03" " 3142"     
[10,] "3.142e+04" "31416"     
> 
> f <- (-2:4); f <- f*16^f
> # Default ("g") format:
> formatC(pi*f)
[1] "-0.02454"  "-0.1963"   "0"         "50.27"     "1608"      "3.86e+04" 
[7] "8.235e+05"
> # Fixed ("f") format, more than one flag ('width' partly "enlarged"):
> cbind(formatC(pi*f, digits = 3, width=9, format = "f", flag = "0+"))
     [,1]         
[1,] "-0000.025"  
[2,] "-0000.196"  
[3,] "+0000.000"  
[4,] "+0050.265"  
[5,] "+1608.495"  
[6,] "+38603.891" 
[7,] "+823549.665"
> 
> formatC(    c("a", "Abc", "no way"), width = -7)  # <=> flag = "-"
[1] "a      " "Abc    " "no way "
> formatC(c((-1:1)/0,c(1,100)*pi), width = 8, digits = 1)
[1] "    -Inf" "     NaN" "     Inf" "       3" "   3e+02"
> 
> ## note that some of the results here depend on the implementation
> ## of long-double arithmetic, which is platform-specific.
> xx <- c(1e-12,-3.98765e-10,1.45645e-69,1e-70,pi*1e37,3.44e4)
> ##       1        2             3        4      5       6
> formatC(xx)
[1] "1e-12"      "-3.988e-10" "1.456e-69"  "1e-70"      "3.142e+37" 
[6] "3.44e+04"  
> formatC(xx, format = "fg")       # special "fixed" format.
[1] "0.000000000001"                                                            
[2] "-0.0000000003988"                                                          
[3] "0.000000000000000000000000000000000000000000000000000000000000000000001456"
[4] "0.0000000000000000000000000000000000000000000000000000000000000000000001"  
[5] "31415926535897927981986333033020522496"                                    
[6] "34400"                                                                     
> formatC(xx[1:4], format = "f", digits = 75) #>> even longer strings
[1] "0.000000000000999999999999999979886647629255615367252843506129522666014963761" 
[2] "-0.000000000398765000000000018320637518040800220675556886362755903974175453186"
[3] "0.000000000000000000000000000000000000000000000000000000000000000000001456450" 
[4] "0.000000000000000000000000000000000000000000000000000000000000000000000100000" 
> 
> formatC(c(3.24, 2.3e-6), format = "f", digits = 11)
[1] "3.24000000000" "0.00000230000"
> formatC(c(3.24, 2.3e-6), format = "f", digits = 11, drop0trailing = TRUE)
[1] "3.24"      "0.0000023"
> 
> r <- c("76491283764.97430", "29.12345678901", "-7.1234", "-100.1","1123")
> ## American:
> prettyNum(r, big.mark = ",")
[1] "76,491,283,764.97430" "      29.12345678901" "             -7.1234"
[4] "              -100.1" "               1,123"
> ## Some Europeans:
> prettyNum(r, big.mark = "'", decimal.mark = ",")
[1] "76'491'283'764.97'430" "    29.12'345'678'901" "             -7.1'234"
[4] "               -100.1" "                1'123"
> 
> (dd <- sapply(1:10, function(i) paste((9:0)[1:i], collapse = "")))
 [1] "9"          "98"         "987"        "9876"       "98765"     
 [6] "987654"     "9876543"    "98765432"   "987654321"  "9876543210"
> prettyNum(dd, big.mark = "'")
 [1] "            9" "           98" "          987" "        9'876"
 [5] "       98'765" "      987'654" "    9'876'543" "   98'765'432"
 [9] "  987'654'321" "9'876'543'210"
> 
> ## examples of 'small.mark'
> pN <- stats::pnorm(1:7, lower.tail = FALSE)
> cbind(format (pN, small.mark = " ", digits = 15))
     [,1]                    
[1,] "1.58655 25393 1457e-01"
[2,] "2.27501 31948 1792e-02"
[3,] "1.34989 80316 3009e-03"
[4,] "3.16712 41833 1199e-05"
[5,] "2.86651 57187 9194e-07"
[6,] "9.86587 64503 7698e-10"
[7,] "1.27981 25438 8584e-12"
> cbind(formatC(pN, small.mark = " ", digits = 17, format = "f"))
     [,1]                    
[1,] "0.15865 52539 31457 05"
[2,] "0.02275 01319 48179 21"
[3,] "0.00134 98980 31630 09"
[4,] "0.00003 16712 41833 12"
[5,] "0.00000 02866 51571 88"
[6,] "0.00000 00009 86587 65"
[7,] "0.00000 00000 01279 81"
> 
> cbind(ff <- format(1.2345 + 10^(0:5), width = 11, big.mark = "'"))
     [,1]          
[1,] "      2.2345"
[2,] "     11.2345"
[3,] "    101.2345"
[4,] "  1'001.2345"
[5,] " 10'001.2345"
[6,] "100'001.2345"
> ## all with same width (one more than the specified minimum)
> 
> ## individual formatting to common width:
> fc <- formatC(1.234 + 10^(0:8), format = "fg", width = 11, big.mark = "'")
> cbind(fc)
      fc           
 [1,] "      2.234"
 [2,] "      11.23"
 [3,] "      101.2"
 [4,] "      1'001"
 [5,] "     10'001"
 [6,] "    100'001"
 [7,] "  1'000'001"
 [8,] " 10'000'001"
 [9,] "100'000'001"
> ## Powers of two, stored exactly, formatted individually:
> pow.2 <- formatC(2^-(1:32), digits = 24, width = 1, format = "fg")
> ## nicely printed (the last line showing 5^32 exactly):
> noquote(cbind(pow.2))
      pow.2                             
 [1,] 0.5                               
 [2,] 0.25                              
 [3,] 0.125                             
 [4,] 0.0625                            
 [5,] 0.03125                           
 [6,] 0.015625                          
 [7,] 0.0078125                         
 [8,] 0.00390625                        
 [9,] 0.001953125                       
[10,] 0.0009765625                      
[11,] 0.00048828125                     
[12,] 0.000244140625                    
[13,] 0.0001220703125                   
[14,] 0.00006103515625                  
[15,] 0.000030517578125                 
[16,] 0.0000152587890625                
[17,] 0.00000762939453125               
[18,] 0.000003814697265625              
[19,] 0.0000019073486328125             
[20,] 0.00000095367431640625            
[21,] 0.000000476837158203125           
[22,] 0.0000002384185791015625          
[23,] 0.00000011920928955078125         
[24,] 0.000000059604644775390625        
[25,] 0.0000000298023223876953125       
[26,] 0.00000001490116119384765625      
[27,] 0.000000007450580596923828125     
[28,] 0.0000000037252902984619140625    
[29,] 0.00000000186264514923095703125   
[30,] 0.000000000931322574615478515625  
[31,] 0.0000000004656612873077392578125 
[32,] 0.00000000023283064365386962890625
> 
> ## complex numbers:
> r <- 10.0000001; rv <- (r/10)^(1:10)
> (zv <- (rv + 1i*rv))
 [1] 1+1i 1+1i 1+1i 1+1i 1+1i 1+1i 1+1i 1+1i 1+1i 1+1i
> op <- options(digits = 7) ## (system default)
> (pnv <- prettyNum(zv))
 [1] "1+1i" "1+1i" "1+1i" "1+1i" "1+1i" "1+1i" "1+1i" "1+1i" "1+1i" "1+1i"
> stopifnot(pnv == "1+1i", pnv == format(zv),
+           pnv == prettyNum(zv, drop0trailing = TRUE))
> ## more digits change the picture:
> options(digits = 8)
> head(fv <- format(zv), 3)
[1] "1.0000000+1.0000000i" "1.0000000+1.0000000i" "1.0000000+1.0000000i"
> prettyNum(fv)
 [1] "1.0000000+1.0000000i" "1.0000000+1.0000000i" "1.0000000+1.0000000i"
 [4] "1.0000000+1.0000000i" "1.0000001+1.0000001i" "1.0000001+1.0000001i"
 [7] "1.0000001+1.0000001i" "1.0000001+1.0000001i" "1.0000001+1.0000001i"
[10] "1.0000001+1.0000001i"
> prettyNum(fv, drop0trailing = TRUE) # a bit nicer
 [1] "1+1i"                 "1+1i"                 "1+1i"                
 [4] "1+1i"                 "1.0000001+1.0000001i" "1.0000001+1.0000001i"
 [7] "1.0000001+1.0000001i" "1.0000001+1.0000001i" "1.0000001+1.0000001i"
[10] "1.0000001+1.0000001i"
> options(op)
> 
> ## The  '  flag :
> doLC <- FALSE # <= R warns, so change to TRUE manually if you want see the effect
> if(doLC) {
+   oldLC <- Sys.getlocale("LC_NUMERIC")
+            Sys.setlocale("LC_NUMERIC", "de_CH.UTF-8") }
> formatC(1.234 + 10^(0:4), format = "fg", width = 11, flag = "'")
[1] "      2.234" "      11.23" "      101.2" "       1001" "      10001"
> ## -->  .....  "      1'001" "     10'001"   on supported platforms
> if(doLC) ## revert, typically to  "C"  :
+   Sys.setlocale("LC_NUMERIC", oldLC)
> 
> 
> 
> cleanEx()
> nameEx("function")
> ### * function
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: function
> ### Title: Function Definition
> ### Aliases: function return closure
> ### Keywords: programming
> 
> ### ** Examples
> 
> norm <- function(x) sqrt(x%*%x)
> norm(1:4)
         [,1]
[1,] 5.477226
> 
> ## An anonymous function:
> (function(x, y){ z <- x^2 + y^2; x+y+z })(0:7, 1)
[1]  2  4  8 14 22 32 44 58
> 
> 
> 
> cleanEx()
> nameEx("funprog")
> ### * funprog
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: funprog
> ### Title: Common Higher-Order Functions in Functional Programming
> ###   Languages
> ### Aliases: Filter Find Map Negate Reduce Position
> ### Keywords: programming
> 
> ### ** Examples
> 
> ## A general-purpose adder:
> add <- function(x) Reduce("+", x)
> add(list(1, 2, 3))
[1] 6
> ## Like sum(), but can also used for adding matrices etc., as it will
> ## use the appropriate '+' method in each reduction step.
> ## More generally, many generics meant to work on arbitrarily many
> ## arguments can be defined via reduction:
> FOO <- function(...) Reduce(FOO2, list(...))
> FOO2 <- function(x, y) UseMethod("FOO2")
> ## FOO() methods can then be provided via FOO2() methods.
> 
> ## A general-purpose cumulative adder:
> cadd <- function(x) Reduce("+", x, accumulate = TRUE)
> cadd(seq_len(7))
[1]  1  3  6 10 15 21 28
> 
> ## A simple function to compute continued fractions:
> cfrac <- function(x) Reduce(function(u, v) u + 1 / v, x, right = TRUE)
> ## Continued fraction approximation for pi:
> cfrac(c(3, 7, 15, 1, 292))
[1] 3.141593
> ## Continued fraction approximation for Euler's number (e):
> cfrac(c(2, 1, 2, 1, 1, 4, 1, 1, 6, 1, 1, 8))
[1] 2.718282
> 
> ## Iterative function application:
> Funcall <- function(f, ...) f(...)
> ## Compute log(exp(acos(cos(0))))
> Reduce(Funcall, list(log, exp, acos, cos), 0, right = TRUE)
[1] 0
> ## n-fold iterate of a function, functional style:
> Iterate <- function(f, n = 1)
+     function(x) Reduce(Funcall, rep.int(list(f), n), x, right = TRUE)
> ## Continued fraction approximation to the golden ratio:
> Iterate(function(x) 1 + 1 / x, 30)(1)
[1] 1.618034
> ## which is the same as
> cfrac(rep.int(1, 31))
[1] 1.618034
> ## Computing square root approximations for x as fixed points of the
> ## function t |-> (t + x / t) / 2, as a function of the initial value:
> asqrt <- function(x, n) Iterate(function(t) (t + x / t) / 2, n)
> asqrt(2, 30)(10) # Starting from a positive value => +sqrt(2)
[1] 1.414214
> asqrt(2, 30)(-1) # Starting from a negative value => -sqrt(2)
[1] -1.414214
> 
> ## A list of all functions in the base environment:
> funs <- Filter(is.function, sapply(ls(baseenv()), get, baseenv()))
> ## Functions in base with more than 10 arguments:
> names(Filter(function(f) length(formals(f)) > 10, funs))
[1] "format.default"   "formatC"          "library"          "merge.data.frame"
[5] "prettyNum"        "scan"             "source"           "system2"         
> ## Number of functions in base with a '...' argument:
> length(Filter(function(f)
+               any(names(formals(f)) %in% "..."),
+               funs))
[1] 421
> 
> 
> cleanEx()
> nameEx("gc")
> ### * gc
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: gc
> ### Title: Garbage Collection
> ### Aliases: gc gcinfo
> ### Keywords: environment
> 
> ### ** Examples
> 
> 
> cleanEx()
> nameEx("gc.time")
> ### * gc.time
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: gc.time
> ### Title: Report Time Spent in Garbage Collection
> ### Aliases: gc.time
> ### Keywords: utilities
> 
> ### ** Examples
> 
> gc.time()
[1] 0 0 0 0 0
> 
> 
> 
> cleanEx()
> nameEx("get")
> ### * get
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: get
> ### Title: Return the Value of a Named Object
> ### Aliases: get mget dynGet
> ### Keywords: data
> 
> ### ** Examples
> 
> get("%o%")
function (X, Y) 
outer(X, Y)
<bytecode: 0x55b7589923f0>
<environment: namespace:base>
> 
> ## test mget
> e1 <- new.env()
> mget(letters, e1, ifnotfound = as.list(LETTERS))
$a
[1] "A"

$b
[1] "B"

$c
[1] "C"

$d
[1] "D"

$e
[1] "E"

$f
[1] "F"

$g
[1] "G"

$h
[1] "H"

$i
[1] "I"

$j
[1] "J"

$k
[1] "K"

$l
[1] "L"

$m
[1] "M"

$n
[1] "N"

$o
[1] "O"

$p
[1] "P"

$q
[1] "Q"

$r
[1] "R"

$s
[1] "S"

$t
[1] "T"

$u
[1] "U"

$v
[1] "V"

$w
[1] "W"

$x
[1] "X"

$y
[1] "Y"

$z
[1] "Z"

> 
> 
> 
> cleanEx()
> nameEx("getCallingDLL")
> ### * getCallingDLL
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: getCallingDLL
> ### Title: Compute DLL for Native Interface Call
> ### Aliases: getCallingDLL getCallingDLLe
> ### Keywords: internal
> 
> ### ** Examples
> 
> if(exists("ansari.test"))
+    getCallingDLL(ansari.test)
DLL name: stats
Filename: /usr/local/lib/R/library/stats/libs/stats.so
Dynamic lookup: FALSE
> 
> 
> 
> cleanEx()
> nameEx("getDLLRegisteredRoutines")
> ### * getDLLRegisteredRoutines
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: getDLLRegisteredRoutines
> ### Title: Reflectance Information for C/Fortran routines in a DLL
> ### Aliases: getDLLRegisteredRoutines getDLLRegisteredRoutines.character
> ###   getDLLRegisteredRoutines.DLLInfo print.NativeRoutineList
> ###   print.DLLRegisteredRoutines
> ### Keywords: interface
> 
> ### ** Examples
> 
> dlls <- getLoadedDLLs()
> getDLLRegisteredRoutines(dlls[["base"]])
                   .Call .Call.numParameters .Fortran .Fortran.numParameters
1      R_addTaskCallback                   4    dqrcf                      8
2 R_getTaskCallbackNames                   0   dqrdc2                      9
3   R_removeTaskCallback                   1   dqrqty                      7
4                                               dqrqy                      7
5                                              dqrrsd                      7
6                                               dqrxb                      7
7                                               dtrco                      6
> 
> getDLLRegisteredRoutines("stats")
                 .C .C.numParameters               .Call .Call.numParameters
1         loess_raw               24              cutree                   2
2        loess_dfit               13              isoreg                   1
3      loess_dfitse               16            monoFC_m                   2
4        loess_ifit                8       numeric_deriv                   4
5         loess_ise               15            nls_iter                   3
6        multi_burg               11        setup_starma                   8
7          multi_yw               10         free_starma                   1
8       HoltWinters               17           set_trans                   2
9      kmeans_Lloyd                9             arma0fa                   2
10  kmeans_MacQueen                9              get_s2                   1
11           rcont2                8           get_resid                   1
12                                               Dotrans                   2
13                                           arma0_kfore                   4
14                                         Starma_method                   2
15                                              Invtrans                   2
16                                             Gradtrans                   2
17                                              ARMAtoMA                   3
18                                            KalmanLike                   5
19                                            KalmanFore                   3
20                                          KalmanSmooth                   3
21                                        ARIMA_undoPars                   2
22                                       ARIMA_transPars                   3
23                                        ARIMA_Invtrans                   2
24                                       ARIMA_Gradtrans                   2
25                                            ARIMA_Like                   4
26                                             ARIMA_CSS                   6
27                                                TSconv                   2
28                                                 getQ0                   2
29                                              getQ0bis                   3
30                                            port_ivset                   3
31                                           port_nlminb                   9
32                                             port_nlsb                   7
33                                            logit_link                   1
34                                         logit_linkinv                   1
35                                          logit_mu_eta                   1
36                                   binomial_dev_resids                   3
37                                              rWishart                   3
38                                                Cdqrls                   4
39                                                 Cdist                   4
40                                                   cor                   4
41                                                   cov                   4
42                                            updateform                   2
43                                                   fft                   2
44                                                 mvfft                   2
45                                                 nextn                   2
46                                              r2dtable                   3
47                                               cfilter                   4
48                                               rfilter                   3
49                                                lowess                   5
50                                          DoubleCentre                   1
51                                               BinDist                   5
52                                                   Rsm                   3
53                                             tukeyline                   4
54                                                runmed                   6
55                                             influence                   3
56                                            pSmirnov2x                   3
57                                         pKolmogorov2x                   2
58                                                  pKS2                   2
59                                               ksmooth                   5
60                                            SplineCoef                   3
61                                            SplineEval                   2
62                                                Approx                   8
63                                            ApproxTest                   5
64                                                LogLin                   7
65                                               pAnsari                   3
66                                               qAnsari                   3
67                                              pKendall                   2
68                                                  pRho                   3
69                                                 SWilk                   1
70                                                bw_den                   2
71                                         bw_den_binned                   1
72                                                bw_ucv                   4
73                                                bw_bcv                   4
74                                               bw_phi4                   4
75                                               bw_phi6                   4
76                                                   acf                   3
77                                                 pacf1                   2
78                                                 ar2ma                   2
79                                                  Burg                   2
80                                            intgrt_vec                   3
81                                                pp_sum                   2
82                                                Fexact                   4
83                                            Fisher_sim                   3
84                                             chisq_sim                   4
85                                                d2x2xk                   5
86                                                dchisq                   3
87                                                  dexp                   3
88                                                 dgeom                   3
89                                                 dpois                   3
90                                                    dt                   3
91                                             dsignrank                   3
92                                                pchisq                   4
93                                                qchisq                   4
94                                                  pexp                   4
95                                                  qexp                   4
96                                                 pgeom                   4
97                                                 qgeom                   4
98                                                 ppois                   4
99                                                 qpois                   4
100                                                   pt                   4
101                                                   qt                   4
102                                            psignrank                   4
103                                            qsignrank                   4
104                                                dbeta                   4
105                                               dbinom                   4
106                                              dcauchy                   4
107                                                   df                   4
108                                               dgamma                   4
109                                               dlnorm                   4
110                                               dlogis                   4
111                                              dnbinom                   4
112                                           dnbinom_mu                   4
113                                                dnorm                   4
114                                             dweibull                   4
115                                                dunif                   4
116                                                  dnt                   4
117                                              dnchisq                   4
118                                              dwilcox                   4
119                                                pbeta                   5
120                                                qbeta                   5
121                                               pbinom                   5
122                                               qbinom                   5
123                                              pcauchy                   5
124                                              qcauchy                   5
125                                                   pf                   5
126                                                   qf                   5
127                                               pgamma                   5
128                                               qgamma                   5
129                                               plnorm                   5
130                                               qlnorm                   5
131                                               plogis                   5
132                                               qlogis                   5
133                                              pnbinom                   5
134                                              qnbinom                   5
135                                           pnbinom_mu                   5
136                                           qnbinom_mu                   5
137                                                pnorm                   5
138                                                qnorm                   5
139                                             pweibull                   5
140                                             qweibull                   5
141                                                punif                   5
142                                                qunif                   5
143                                                  pnt                   5
144                                                  qnt                   5
145                                              pnchisq                   5
146                                              qnchisq                   5
147                                              pwilcox                   5
148                                              qwilcox                   5
149                                               dhyper                   5
150                                               dnbeta                   5
151                                                  dnf                   5
152                                               phyper                   6
153                                               qhyper                   6
154                                               pnbeta                   6
155                                               qnbeta                   6
156                                                  pnf                   6
157                                                  qnf                   6
158                                               ptukey                   6
159                                               qtukey                   6
160                                               rchisq                   2
161                                                 rexp                   2
162                                                rgeom                   2
163                                                rpois                   2
164                                                   rt                   2
165                                            rsignrank                   2
166                                                rbeta                   3
167                                               rbinom                   3
168                                              rcauchy                   3
169                                                   rf                   3
170                                               rgamma                   3
171                                               rlnorm                   3
172                                               rlogis                   3
173                                              rnbinom                   3
174                                                rnorm                   3
175                                                runif                   3
176                                             rweibull                   3
177                                              rwilcox                   3
178                                              rnchisq                   3
179                                           rnbinom_mu                   3
180                                               rhyper                   4
181                                            rmultinom                   3
    .Fortran .Fortran.numParameters     .External .External.numParameters
1     lowesw                      4     compcases                      -1
2     lowesp                      7           doD                       2
3     setppr                      6         deriv                       5
4      smart                     16    modelframe                       8
5     pppred                      5   modelmatrix                       2
6     setsmu                      1     termsform                       5
7      rbart                     20       do_fmin                       4
8     bvalus                      7           nlm                      11
9     supsmu                     10       zeroin2                       7
10    hclust                     10         optim                       7
11    hcass2                      6     optimhess                       4
12      kmns                     17    call_dqags                       7
13    eureka                      6    call_dqagi                       7
14       stl                     18 signrank_free                       0
15                                    wilcox_free                       0
16                                                                       
17                                                                       
18                                                                       
19                                                                       
20                                                                       
21                                                                       
22                                                                       
23                                                                       
24                                                                       
25                                                                       
26                                                                       
27                                                                       
28                                                                       
29                                                                       
30                                                                       
31                                                                       
32                                                                       
33                                                                       
34                                                                       
35                                                                       
36                                                                       
37                                                                       
38                                                                       
39                                                                       
40                                                                       
41                                                                       
42                                                                       
43                                                                       
44                                                                       
45                                                                       
46                                                                       
47                                                                       
48                                                                       
49                                                                       
50                                                                       
51                                                                       
52                                                                       
53                                                                       
54                                                                       
55                                                                       
56                                                                       
57                                                                       
58                                                                       
59                                                                       
60                                                                       
61                                                                       
62                                                                       
63                                                                       
64                                                                       
65                                                                       
66                                                                       
67                                                                       
68                                                                       
69                                                                       
70                                                                       
71                                                                       
72                                                                       
73                                                                       
74                                                                       
75                                                                       
76                                                                       
77                                                                       
78                                                                       
79                                                                       
80                                                                       
81                                                                       
82                                                                       
83                                                                       
84                                                                       
85                                                                       
86                                                                       
87                                                                       
88                                                                       
89                                                                       
90                                                                       
91                                                                       
92                                                                       
93                                                                       
94                                                                       
95                                                                       
96                                                                       
97                                                                       
98                                                                       
99                                                                       
100                                                                      
101                                                                      
102                                                                      
103                                                                      
104                                                                      
105                                                                      
106                                                                      
107                                                                      
108                                                                      
109                                                                      
110                                                                      
111                                                                      
112                                                                      
113                                                                      
114                                                                      
115                                                                      
116                                                                      
117                                                                      
118                                                                      
119                                                                      
120                                                                      
121                                                                      
122                                                                      
123                                                                      
124                                                                      
125                                                                      
126                                                                      
127                                                                      
128                                                                      
129                                                                      
130                                                                      
131                                                                      
132                                                                      
133                                                                      
134                                                                      
135                                                                      
136                                                                      
137                                                                      
138                                                                      
139                                                                      
140                                                                      
141                                                                      
142                                                                      
143                                                                      
144                                                                      
145                                                                      
146                                                                      
147                                                                      
148                                                                      
149                                                                      
150                                                                      
151                                                                      
152                                                                      
153                                                                      
154                                                                      
155                                                                      
156                                                                      
157                                                                      
158                                                                      
159                                                                      
160                                                                      
161                                                                      
162                                                                      
163                                                                      
164                                                                      
165                                                                      
166                                                                      
167                                                                      
168                                                                      
169                                                                      
170                                                                      
171                                                                      
172                                                                      
173                                                                      
174                                                                      
175                                                                      
176                                                                      
177                                                                      
178                                                                      
179                                                                      
180                                                                      
181                                                                      
> 
> 
> 
> cleanEx()
> nameEx("getLoadedDLLs")
> ### * getLoadedDLLs
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: getLoadedDLLs
> ### Title: Get DLLs Loaded in Current Session
> ### Aliases: getLoadedDLLs print.DLLInfo print.DLLInfoList [.DLLInfoList
> ###   $.DLLInfo DLLInfo DLLInfoList
> ### Keywords: interface
> 
> ### ** Examples
> 
> getLoadedDLLs()
                                                      Filename Dynamic.Lookup
base                                                      base          FALSE
methods       /usr/local/lib/R/library/methods/libs/methods.so          FALSE
utils             /usr/local/lib/R/library/utils/libs/utils.so          FALSE
grDevices /usr/local/lib/R/library/grDevices/libs/grDevices.so          FALSE
graphics    /usr/local/lib/R/library/graphics/libs/graphics.so          FALSE
stats             /usr/local/lib/R/library/stats/libs/stats.so          FALSE
tools             /usr/local/lib/R/library/tools/libs/tools.so          FALSE
lapack                     /usr/local/lib/R/modules//lapack.so           TRUE
splines       /usr/local/lib/R/library/splines/libs/splines.so          FALSE
R_X11                       /usr/local/lib/R/modules//R_X11.so           TRUE
> 
> utils::tail(getLoadedDLLs(), 2) # the last 2 loaded ones, still a DLLInfoList
                                                Filename Dynamic.Lookup
splines /usr/local/lib/R/library/splines/libs/splines.so          FALSE
R_X11                 /usr/local/lib/R/modules//R_X11.so           TRUE
> 
> 
> 
> cleanEx()
> nameEx("gettext")
> ### * gettext
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: gettext
> ### Title: Translate Text Messages
> ### Aliases: gettext ngettext bindtextdomain
> ### Keywords: utilities character
> 
> ### ** Examples
> 
> bindtextdomain("R")  # non-null if and only if NLS is enabled
NULL
> 
> for(n in 0:3)
+     print(sprintf(ngettext(n, "%d variable has missing values",
+                               "%d variables have missing values"),
+                   n))
[1] "0 variables have missing values"
[1] "1 variable has missing values"
[1] "2 variables have missing values"
[1] "3 variables have missing values"
> 
> ## Not run: 
> ##D ## for translation, those strings should appear in R-pkg.pot as
> ##D msgid        "%d variable has missing values"
> ##D msgid_plural "%d variables have missing values"
> ##D msgstr[0] ""
> ##D msgstr[1] ""
> ## End(Not run)
> 
> miss <- c("one", "or", "another")
> cat(ngettext(length(miss), "variable", "variables"),
+     paste(sQuote(miss), collapse = ", "),
+     ngettext(length(miss), "contains", "contain"), "missing values\n")
variables ‘one’, ‘or’, ‘another’ contain missing values
> 
> ## better for translators would be to use
> cat(sprintf(ngettext(length(miss),
+                      "variable %s contains missing values\n",
+                      "variables %s contain missing values\n"),
+             paste(sQuote(miss), collapse = ", ")))
variables ‘one’, ‘or’, ‘another’ contain missing values
> 
> 
> 
> cleanEx()
> nameEx("getwd")
> ### * getwd
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: getwd
> ### Title: Get or Set Working Directory
> ### Aliases: getwd setwd
> ### Keywords: utilities
> 
> ### ** Examples
> 
> (WD <- getwd())
[1] "/home/val/outputs/base"
> if (!is.null(WD)) setwd(WD)
> 
> 
> 
> cleanEx()
> nameEx("gl")
> ### * gl
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: gl
> ### Title: Generate Factor Levels
> ### Aliases: gl
> ### Keywords: category arith
> 
> ### ** Examples
> 
> ## First control, then treatment:
> gl(2, 8, labels = c("Control", "Treat"))
 [1] Control Control Control Control Control Control Control Control Treat  
[10] Treat   Treat   Treat   Treat   Treat   Treat   Treat  
Levels: Control Treat
> ## 20 alternating 1s and 2s
> gl(2, 1, 20)
 [1] 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2
Levels: 1 2
> ## alternating pairs of 1s and 2s
> gl(2, 2, 20)
 [1] 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2
Levels: 1 2
> 
> 
> 
> cleanEx()
> nameEx("grep")
> ### * grep
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: grep
> ### Title: Pattern Matching and Replacement
> ### Aliases: grep grepl sub gsub regexpr gregexpr regexec
> ### Keywords: character utilities
> 
> ### ** Examples
> 
> grep("[a-z]", letters)
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
[26] 26
> 
> txt <- c("arm","foot","lefroo", "bafoobar")
> if(length(i <- grep("foo", txt)))
+    cat("'foo' appears at least once in\n\t", txt, "\n")
'foo' appears at least once in
	 arm foot lefroo bafoobar 
> i # 2 and 4
[1] 2 4
> txt[i]
[1] "foot"     "bafoobar"
> 
> ## Double all 'a' or 'b's;  "\" must be escaped, i.e., 'doubled'
> gsub("([ab])", "\\1_\\1_", "abc and ABC")
[1] "a_a_b_b_c a_a_nd ABC"
> 
> txt <- c("The", "licenses", "for", "most", "software", "are",
+   "designed", "to", "take", "away", "your", "freedom",
+   "to", "share", "and", "change", "it.",
+   "", "By", "contrast,", "the", "GNU", "General", "Public", "License",
+   "is", "intended", "to", "guarantee", "your", "freedom", "to",
+   "share", "and", "change", "free", "software", "--",
+   "to", "make", "sure", "the", "software", "is",
+   "free", "for", "all", "its", "users")
> ( i <- grep("[gu]", txt) ) # indices
[1]  7 11 16 24 29 30 35 41 49
> stopifnot( txt[i] == grep("[gu]", txt, value = TRUE) )
> 
> ## Note that for some implementations character ranges are
> ## locale-dependent (but not currently).  Then [b-e] in locales such as
> ## en_US may include B as the collation order is aAbBcCdDe ...
> (ot <- sub("[b-e]",".", txt))
 [1] "Th."       "li.enses"  "for"       "most"      "softwar."  "ar."      
 [7] ".esigned"  "to"        "tak."      "away"      "your"      "fr.edom"  
[13] "to"        "shar."     "an."       ".hange"    "it."       ""         
[19] "By"        ".ontrast," "th."       "GNU"       "G.neral"   "Pu.lic"   
[25] "Li.ense"   "is"        "int.nded"  "to"        "guarant.e" "your"     
[31] "fr.edom"   "to"        "shar."     "an."       ".hange"    "fr.e"     
[37] "softwar."  "--"        "to"        "mak."      "sur."      "th."      
[43] "softwar."  "is"        "fr.e"      "for"       "all"       "its"      
[49] "us.rs"    
> txt[ot != gsub("[b-e]",".", txt)]#- gsub does "global" substitution
 [1] "licenses"  "designed"  "freedom"   "change"    "General"   "Public"   
 [7] "License"   "intended"  "guarantee" "freedom"   "change"    "free"     
[13] "free"     
> ## In caseless matching, ranges include both cases:
> a <- grep("[b-e]", txt, value = TRUE)
> b <- grep("[b-e]", txt, ignore.case = TRUE, value = TRUE)
> setdiff(b, a)
[1] "By"
> 
> txt[gsub("g","#", txt) !=
+     gsub("g","#", txt, ignore.case = TRUE)] # the "G" words
[1] "GNU"     "General"
> 
> regexpr("en", txt)
 [1] -1  4 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1  2 -1  4
[26] -1  4 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1
attr(,"match.length")
 [1] -1  2 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1  2 -1  2
[26] -1  2 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1
attr(,"index.type")
[1] "chars"
attr(,"useBytes")
[1] TRUE
> 
> gregexpr("e", txt)
[[1]]
[1] 3
attr(,"match.length")
[1] 1
attr(,"index.type")
[1] "chars"
attr(,"useBytes")
[1] TRUE

[[2]]
[1] 4 7
attr(,"match.length")
[1] 1 1
attr(,"index.type")
[1] "chars"
attr(,"useBytes")
[1] TRUE

[[3]]
[1] -1
attr(,"match.length")
[1] -1
attr(,"index.type")
[1] "chars"
attr(,"useBytes")
[1] TRUE

[[4]]
[1] -1
attr(,"match.length")
[1] -1
attr(,"index.type")
[1] "chars"
attr(,"useBytes")
[1] TRUE

[[5]]
[1] 8
attr(,"match.length")
[1] 1
attr(,"index.type")
[1] "chars"
attr(,"useBytes")
[1] TRUE

[[6]]
[1] 3
attr(,"match.length")
[1] 1
attr(,"index.type")
[1] "chars"
attr(,"useBytes")
[1] TRUE

[[7]]
[1] 2 7
attr(,"match.length")
[1] 1 1
attr(,"index.type")
[1] "chars"
attr(,"useBytes")
[1] TRUE

[[8]]
[1] -1
attr(,"match.length")
[1] -1
attr(,"index.type")
[1] "chars"
attr(,"useBytes")
[1] TRUE

[[9]]
[1] 4
attr(,"match.length")
[1] 1
attr(,"index.type")
[1] "chars"
attr(,"useBytes")
[1] TRUE

[[10]]
[1] -1
attr(,"match.length")
[1] -1
attr(,"index.type")
[1] "chars"
attr(,"useBytes")
[1] TRUE

[[11]]
[1] -1
attr(,"match.length")
[1] -1
attr(,"index.type")
[1] "chars"
attr(,"useBytes")
[1] TRUE

[[12]]
[1] 3 4
attr(,"match.length")
[1] 1 1
attr(,"index.type")
[1] "chars"
attr(,"useBytes")
[1] TRUE

[[13]]
[1] -1
attr(,"match.length")
[1] -1
attr(,"index.type")
[1] "chars"
attr(,"useBytes")
[1] TRUE

[[14]]
[1] 5
attr(,"match.length")
[1] 1
attr(,"index.type")
[1] "chars"
attr(,"useBytes")
[1] TRUE

[[15]]
[1] -1
attr(,"match.length")
[1] -1
attr(,"index.type")
[1] "chars"
attr(,"useBytes")
[1] TRUE

[[16]]
[1] 6
attr(,"match.length")
[1] 1
attr(,"index.type")
[1] "chars"
attr(,"useBytes")
[1] TRUE

[[17]]
[1] -1
attr(,"match.length")
[1] -1
attr(,"index.type")
[1] "chars"
attr(,"useBytes")
[1] TRUE

[[18]]
[1] -1
attr(,"match.length")
[1] -1
attr(,"index.type")
[1] "chars"
attr(,"useBytes")
[1] TRUE

[[19]]
[1] -1
attr(,"match.length")
[1] -1
attr(,"index.type")
[1] "chars"
attr(,"useBytes")
[1] TRUE

[[20]]
[1] -1
attr(,"match.length")
[1] -1
attr(,"index.type")
[1] "chars"
attr(,"useBytes")
[1] TRUE

[[21]]
[1] 3
attr(,"match.length")
[1] 1
attr(,"index.type")
[1] "chars"
attr(,"useBytes")
[1] TRUE

[[22]]
[1] -1
attr(,"match.length")
[1] -1
attr(,"index.type")
[1] "chars"
attr(,"useBytes")
[1] TRUE

[[23]]
[1] 2 4
attr(,"match.length")
[1] 1 1
attr(,"index.type")
[1] "chars"
attr(,"useBytes")
[1] TRUE

[[24]]
[1] -1
attr(,"match.length")
[1] -1
attr(,"index.type")
[1] "chars"
attr(,"useBytes")
[1] TRUE

[[25]]
[1] 4 7
attr(,"match.length")
[1] 1 1
attr(,"index.type")
[1] "chars"
attr(,"useBytes")
[1] TRUE

[[26]]
[1] -1
attr(,"match.length")
[1] -1
attr(,"index.type")
[1] "chars"
attr(,"useBytes")
[1] TRUE

[[27]]
[1] 4 7
attr(,"match.length")
[1] 1 1
attr(,"index.type")
[1] "chars"
attr(,"useBytes")
[1] TRUE

[[28]]
[1] -1
attr(,"match.length")
[1] -1
attr(,"index.type")
[1] "chars"
attr(,"useBytes")
[1] TRUE

[[29]]
[1] 8 9
attr(,"match.length")
[1] 1 1
attr(,"index.type")
[1] "chars"
attr(,"useBytes")
[1] TRUE

[[30]]
[1] -1
attr(,"match.length")
[1] -1
attr(,"index.type")
[1] "chars"
attr(,"useBytes")
[1] TRUE

[[31]]
[1] 3 4
attr(,"match.length")
[1] 1 1
attr(,"index.type")
[1] "chars"
attr(,"useBytes")
[1] TRUE

[[32]]
[1] -1
attr(,"match.length")
[1] -1
attr(,"index.type")
[1] "chars"
attr(,"useBytes")
[1] TRUE

[[33]]
[1] 5
attr(,"match.length")
[1] 1
attr(,"index.type")
[1] "chars"
attr(,"useBytes")
[1] TRUE

[[34]]
[1] -1
attr(,"match.length")
[1] -1
attr(,"index.type")
[1] "chars"
attr(,"useBytes")
[1] TRUE

[[35]]
[1] 6
attr(,"match.length")
[1] 1
attr(,"index.type")
[1] "chars"
attr(,"useBytes")
[1] TRUE

[[36]]
[1] 3 4
attr(,"match.length")
[1] 1 1
attr(,"index.type")
[1] "chars"
attr(,"useBytes")
[1] TRUE

[[37]]
[1] 8
attr(,"match.length")
[1] 1
attr(,"index.type")
[1] "chars"
attr(,"useBytes")
[1] TRUE

[[38]]
[1] -1
attr(,"match.length")
[1] -1
attr(,"index.type")
[1] "chars"
attr(,"useBytes")
[1] TRUE

[[39]]
[1] -1
attr(,"match.length")
[1] -1
attr(,"index.type")
[1] "chars"
attr(,"useBytes")
[1] TRUE

[[40]]
[1] 4
attr(,"match.length")
[1] 1
attr(,"index.type")
[1] "chars"
attr(,"useBytes")
[1] TRUE

[[41]]
[1] 4
attr(,"match.length")
[1] 1
attr(,"index.type")
[1] "chars"
attr(,"useBytes")
[1] TRUE

[[42]]
[1] 3
attr(,"match.length")
[1] 1
attr(,"index.type")
[1] "chars"
attr(,"useBytes")
[1] TRUE

[[43]]
[1] 8
attr(,"match.length")
[1] 1
attr(,"index.type")
[1] "chars"
attr(,"useBytes")
[1] TRUE

[[44]]
[1] -1
attr(,"match.length")
[1] -1
attr(,"index.type")
[1] "chars"
attr(,"useBytes")
[1] TRUE

[[45]]
[1] 3 4
attr(,"match.length")
[1] 1 1
attr(,"index.type")
[1] "chars"
attr(,"useBytes")
[1] TRUE

[[46]]
[1] -1
attr(,"match.length")
[1] -1
attr(,"index.type")
[1] "chars"
attr(,"useBytes")
[1] TRUE

[[47]]
[1] -1
attr(,"match.length")
[1] -1
attr(,"index.type")
[1] "chars"
attr(,"useBytes")
[1] TRUE

[[48]]
[1] -1
attr(,"match.length")
[1] -1
attr(,"index.type")
[1] "chars"
attr(,"useBytes")
[1] TRUE

[[49]]
[1] 3
attr(,"match.length")
[1] 1
attr(,"index.type")
[1] "chars"
attr(,"useBytes")
[1] TRUE

> 
> ## Using grepl() for filtering
> ## Find functions with argument names matching "warn":
> findArgs <- function(env, pattern) {
+   nms <- ls(envir = as.environment(env))
+   nms <- nms[is.na(match(nms, c("F","T")))] # <-- work around "checking hack"
+   aa <- sapply(nms, function(.) { o <- get(.)
+                if(is.function(o)) names(formals(o)) })
+   iw <- sapply(aa, function(a) any(grepl(pattern, a, ignore.case=TRUE)))
+   aa[iw]
+ }
> findArgs("package:base", "warn")
$attach
[1] "what"           "pos"            "name"           "warn.conflicts"

$dir.create
[1] "path"         "showWarnings" "recursive"    "mode"        

$file.create
[1] "..."          "showWarnings"

$library
 [1] "package"         "help"            "pos"             "lib.loc"        
 [5] "character.only"  "logical.return"  "warn.conflicts"  "quietly"        
 [9] "verbose"         "mask.ok"         "exclude"         "include.only"   
[13] "attach.required"

$readLines
[1] "con"      "n"        "ok"       "warn"     "encoding" "skipNul" 

$require
[1] "package"         "lib.loc"         "quietly"         "warn.conflicts" 
[5] "character.only"  "mask.ok"         "exclude"         "include.only"   
[9] "attach.required"

> 
> ## trim trailing white space
> str <- "Now is the time      "
> sub(" +$", "", str)  ## spaces only
[1] "Now is the time"
> ## what is considered 'white space' depends on the locale.
> sub("[[:space:]]+$", "", str) ## white space, POSIX-style
[1] "Now is the time"
> ## what PCRE considered white space changed in version 8.34: see ?regex
> sub("\\s+$", "", str, perl = TRUE) ## PCRE-style white space
[1] "Now is the time"
> 
> ## capitalizing
> txt <- "a test of capitalizing"
> gsub("(\\w)(\\w*)", "\\U\\1\\L\\2", txt, perl=TRUE)
[1] "A Test Of Capitalizing"
> gsub("\\b(\\w)",    "\\U\\1",       txt, perl=TRUE)
[1] "A Test Of Capitalizing"
> 
> txt2 <- "useRs may fly into JFK or laGuardia"
> gsub("(\\w)(\\w*)(\\w)", "\\U\\1\\E\\2\\U\\3", txt2, perl=TRUE)
[1] "UseRS MaY FlY IntO JFK OR LaGuardiA"
>  sub("(\\w)(\\w*)(\\w)", "\\U\\1\\E\\2\\U\\3", txt2, perl=TRUE)
[1] "UseRS may fly into JFK or laGuardia"
> 
> ## named capture
> notables <- c("  Ben Franklin and Jefferson Davis",
+               "\tMillard Fillmore")
> # name groups 'first' and 'last'
> name.rex <- "(?<first>[[:upper:]][[:lower:]]+) (?<last>[[:upper:]][[:lower:]]+)"
> (parsed <- regexpr(name.rex, notables, perl = TRUE))
[1] 3 2
attr(,"match.length")
[1] 12 16
attr(,"index.type")
[1] "chars"
attr(,"useBytes")
[1] TRUE
attr(,"capture.start")
     first last
[1,]     3    7
[2,]     2   10
attr(,"capture.length")
     first last
[1,]     3    8
[2,]     7    8
attr(,"capture.names")
[1] "first" "last" 
> gregexpr(name.rex, notables, perl = TRUE)[[2]]
[1] 2
attr(,"match.length")
[1] 16
attr(,"index.type")
[1] "chars"
attr(,"useBytes")
[1] TRUE
attr(,"capture.start")
     first last
[1,]     2   10
attr(,"capture.length")
     first last
[1,]     7    8
attr(,"capture.names")
[1] "first" "last" 
> parse.one <- function(res, result) {
+   m <- do.call(rbind, lapply(seq_along(res), function(i) {
+     if(result[i] == -1) return("")
+     st <- attr(result, "capture.start")[i, ]
+     substring(res[i], st, st + attr(result, "capture.length")[i, ] - 1)
+   }))
+   colnames(m) <- attr(result, "capture.names")
+   m
+ }
> parse.one(notables, parsed)
     first     last      
[1,] "Ben"     "Franklin"
[2,] "Millard" "Fillmore"
> 
> ## Decompose a URL into its components.
> ## Example by LT (http://www.cs.uiowa.edu/~luke/R/regexp.html).
> x <- "http://stat.umn.edu:80/xyz"
> m <- regexec("^(([^:]+)://)?([^:/]+)(:([0-9]+))?(/.*)", x)
> m
[[1]]
[1]  1  1  1  8 20 21 23
attr(,"match.length")
[1] 26  7  4 12  3  2  4
attr(,"index.type")
[1] "chars"
attr(,"useBytes")
[1] TRUE

> regmatches(x, m)
[[1]]
[1] "http://stat.umn.edu:80/xyz" "http://"                   
[3] "http"                       "stat.umn.edu"              
[5] ":80"                        "80"                        
[7] "/xyz"                      

> ## Element 3 is the protocol, 4 is the host, 6 is the port, and 7
> ## is the path.  We can use this to make a function for extracting the
> ## parts of a URL:
> URL_parts <- function(x) {
+     m <- regexec("^(([^:]+)://)?([^:/]+)(:([0-9]+))?(/.*)", x)
+     parts <- do.call(rbind,
+                      lapply(regmatches(x, m), `[`, c(3L, 4L, 6L, 7L)))
+     colnames(parts) <- c("protocol","host","port","path")
+     parts
+ }
> URL_parts(x)
     protocol host           port path  
[1,] "http"   "stat.umn.edu" "80" "/xyz"
> 
> ## There is no gregexec() yet, but one can emulate it by running
> ## regexec() on the regmatches obtained via gregexpr().  E.g.:
> pattern <- "([[:alpha:]]+)([[:digit:]]+)"
> s <- "Test: A1 BC23 DEF456"
> lapply(regmatches(s, gregexpr(pattern, s)),
+        function(e) regmatches(e, regexec(pattern, e)))
[[1]]
[[1]][[1]]
[1] "A1" "A"  "1" 

[[1]][[2]]
[1] "BC23" "BC"   "23"  

[[1]][[3]]
[1] "DEF456" "DEF"    "456"   


> 
> 
> 
> cleanEx()
> nameEx("grepRaw")
> ### * grepRaw
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: grepRaw
> ### Title: Pattern Matching for Raw Vectors
> ### Aliases: grepRaw
> ### Keywords: utilities
> 
> ### ** Examples
> 
> grepRaw("no match", "textText")  # integer(0): no match
integer(0)
> grepRaw("adf", "adadfadfdfadadf") # 3 - the first match
[1] 3
> grepRaw("adf", "adadfadfdfadadf", all=TRUE, fixed=TRUE)
[1]  3  6 13
> ## [1]  3  6 13 -- three matches
> 
> 
> 
> cleanEx()
> nameEx("groupGeneric")
> ### * groupGeneric
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: groupGeneric
> ### Title: S3 Group Generic Functions
> ### Aliases: S3groupGeneric groupGeneric .Group Math Math.data.frame Ops
> ###   Ops.data.frame Summary Summary.data.frame Complex 'group generic'
> ### Keywords: methods
> 
> ### ** Examples
> 
> require(utils)
> 
> d.fr <- data.frame(x = 1:9, y = stats::rnorm(9))
> class(1 + d.fr) == "data.frame" ##-- add to d.f. ...
[1] TRUE
> 
> methods("Math")
[1] Math,nonStructure-method Math,structure-method    Math.data.frame         
[4] Math.Date                Math.difftime            Math.factor             
[7] Math.POSIXt             
see '?methods' for accessing help and source code
> methods("Ops")
 [1] Ops,array,array-method               Ops,array,structure-method          
 [3] Ops,nonStructure,nonStructure-method Ops,nonStructure,vector-method      
 [5] Ops,structure,array-method           Ops,structure,structure-method      
 [7] Ops,structure,vector-method          Ops,vector,nonStructure-method      
 [9] Ops,vector,structure-method          Ops.data.frame                      
[11] Ops.Date                             Ops.difftime                        
[13] Ops.factor                           Ops.numeric_version                 
[15] Ops.ordered                          Ops.POSIXt                          
[17] Ops.raster*                          Ops.roman*                          
[19] Ops.ts*                             
see '?methods' for accessing help and source code
> methods("Summary")
[1] Summary.data.frame      Summary.Date            Summary.difftime       
[4] Summary.factor          Summary.numeric_version Summary.ordered        
[7] Summary.POSIXct         Summary.POSIXlt         Summary.roman*         
see '?methods' for accessing help and source code
> methods("Complex")  # none in base R
no methods found
> 
> 
> 
> cleanEx()
> nameEx("grouping")
> ### * grouping
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: grouping
> ### Title: Grouping Permutation
> ### Aliases: grouping
> ### Keywords: manip
> 
> ### ** Examples
> 
> (ii <- grouping(x <- c(1, 1, 3:1, 1:4, 3), y <- c(9, 9:1), z <- c(2, 1:9)))
 [1]  6  5  2  1  7  4 10  8  3  9
attr(,"ends")
 [1]  1  2  3  4  5  6  7  8  9 10
attr(,"maxgrpn")
[1] 1
attr(,"class")
[1] "grouping" "integer" 
> ## 6  5  2  1  7  4 10  8  3  9
> rbind(x, y, z)[, ii]
  [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
x    1    1    1    1    2    2    3    3    3     4
y    5    6    9    9    4    7    1    3    8     2
z    5    4    1    2    6    3    9    7    2     8
> 
> 
> 
> cleanEx()
> nameEx("gzcon")
> ### * gzcon
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: gzcon
> ### Title: (De)compress I/O Through Connections
> ### Aliases: gzcon
> ### Keywords: file connection
> 
> ### ** Examples
> 
> 
> ## gzfile and gzcon can inter-work.
> ## Of course here one would use gzfile, but file() can be replaced by
> ## any other connection generator.
> zzfil <- tempfile(fileext = ".gz")
> zz <- gzfile(zzfil, "w")
> cat("TITLE extra line", "2 3 5 7", "", "11 13 17", file = zz, sep = "\n")
> close(zz)
> readLines(zz <- gzcon(file(zzfil, "rb")))
[1] "TITLE extra line" "2 3 5 7"          ""                 "11 13 17"        
> close(zz)
> unlink(zzfil)
> 
> zzfil2 <- tempfile(fileext = ".gz")
> zz <- gzcon(file(zzfil2, "wb"))
> cat("TITLE extra line", "2 3 5 7", "", "11 13 17", file = zz, sep = "\n")
> close(zz)
> readLines(zz <- gzfile(zzfil2))
[1] "TITLE extra line" "2 3 5 7"          ""                 "11 13 17"        
> close(zz)
> unlink(zzfil2)
> 
> 
> 
> cleanEx()
> nameEx("hexmode")
> ### * hexmode
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: hexmode
> ### Title: Display Numbers in Hexadecimal
> ### Aliases: as.hexmode format.hexmode print.hexmode as.character.hexmode
> ###   [.hexmode !.hexmode |.hexmode &.hexmode hexmode
> ### Keywords: utilities print
> 
> ### ** Examples
> 
> i <- as.hexmode("7fffffff")
> i; class(i)
[1] "7fffffff"
[1] "hexmode"
> identical(as.integer(i), .Machine$integer.max)
[1] TRUE
> 
> hm <- as.hexmode(c(NA, 1)); hm
[1] NA  "1"
> as.integer(hm)
[1] NA  1
> 
> 
> 
> cleanEx()
> nameEx("iconv")
> ### * iconv
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: iconv
> ### Title: Convert Character Vector between Encodings
> ### Aliases: iconv iconvlist
> ### Keywords: character utilities
> 
> ### ** Examples
> 
> ## In principle, as not all systems have iconvlist
> try(utils::head(iconvlist(), n = 50))
 [1] "1026"             "1046"             "1047"             "10646-1:1993"    
 [5] "437"              "500"              "500V1"            "850"             
 [9] "851"              "852"              "855"              "856"             
[13] "857"              "858"              "860"              "861"             
[17] "862"              "863"              "864"              "865"             
[21] "866"              "866NAV"           "869"              "874"             
[25] "8859_1"           "8859_2"           "8859_3"           "8859_4"          
[29] "8859_5"           "8859_6"           "8859_7"           "8859_8"          
[33] "8859_9"           "904"              "ANSI_X3.110"      "ANSI_X3.110-1983"
[37] "ANSI_X3.4"        "ANSI_X3.4-1968"   "ANSI_X3.4-1986"   "ARABIC"          
[41] "ARABIC7"          "ARMSCII-8"        "ARMSCII8"         "ASCII"           
[45] "ASMO_449"         "ASMO-708"         "BALTIC"           "BIG-5"           
[49] "BIG-FIVE"         "BIG5"            
> 
> ## Not run: 
> ##D ## convert from Latin-2 to UTF-8: two of the glibc iconv variants.
> ##D iconv(x, "ISO_8859-2", "UTF-8")
> ##D iconv(x, "LATIN2", "UTF-8")
> ## End(Not run)
> 
> ## Both x below are in latin1 and will only display correctly in a
> ## locale that can represent and display latin1.
> x <- "fa\xE7ile"
> Encoding(x) <- "latin1"
> x
[1] "façile"
> charToRaw(xx <- iconv(x, "latin1", "UTF-8"))
[1] 66 61 c3 a7 69 6c 65
> xx
[1] "façile"
> 
> iconv(x, "latin1", "ASCII")          #   NA
[1] NA
> iconv(x, "latin1", "ASCII", "?")     # "fa?ile"
[1] "fa?ile"
> iconv(x, "latin1", "ASCII", "")      # "faile"
[1] "faile"
> iconv(x, "latin1", "ASCII", "byte")  # "fa<e7>ile"
[1] "fa<e7>ile"
> iconv(xx, "UTF-8", "ASCII", "Unicode") # "fa<U+00E7>ile"
[1] "fa<U+00E7>ile"
> 
> ## Extracts from old R help files (they are nowadays in UTF-8)
> x <- c("Ekstr\xf8m", "J\xf6reskog", "bi\xdfchen Z\xfcrcher")
> Encoding(x) <- "latin1"
> x
[1] "Ekstrøm"         "Jöreskog"        "bißchen Zürcher"
> try(iconv(x, "latin1", "ASCII//TRANSLIT"))  # platform-dependent
[1] "Ekstrom"          "Joreskog"         "bisschen Zurcher"
> iconv(x, "latin1", "ASCII", sub = "byte")
[1] "Ekstr<f8>m"            "J<f6>reskog"           "bi<df>chen Z<fc>rcher"
> ## and for Windows' 'Unicode'
> str(xx <- iconv(x, "latin1", "UTF-16LE", toRaw = TRUE))
List of 3
 $ : raw [1:14] 45 00 6b 00 ...
 $ : raw [1:16] 4a 00 f6 00 ...
 $ : raw [1:30] 62 00 69 00 ...
> iconv(xx, "UTF-16LE", "UTF-8")
[1] "Ekstrøm"         "Jöreskog"        "bißchen Zürcher"
> 
> 
> 
> cleanEx()
> nameEx("icuSetCollate")
> ### * icuSetCollate
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: icuSetCollate
> ### Title: Setup Collation by ICU
> ### Aliases: icuSetCollate icuGetCollate R_ICU_LOCALE
> ### Keywords: utilities
> 
> ### ** Examples
> 
> 
> cleanEx()
> nameEx("identical")
> ### * identical
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: identical
> ### Title: Test Objects for Exact Equality
> ### Aliases: identical
> ### Keywords: programming logic iteration
> 
> ### ** Examples
> 
> identical(1, NULL) ## FALSE -- don't try this with ==
[1] FALSE
> identical(1, 1.)   ## TRUE in R (both are stored as doubles)
[1] TRUE
> identical(1, as.integer(1)) ## FALSE, stored as different types
[1] FALSE
> 
> x <- 1.0; y <- 0.99999999999
> ## how to test for object equality allowing for numeric fuzz :
> (E <- all.equal(x, y))
[1] TRUE
> isTRUE(E) # which is simply defined to just use
[1] TRUE
> identical(TRUE, E)
[1] TRUE
> ## If all.equal thinks the objects are different, it returns a
> ## character string, and the above expression evaluates to FALSE
> 
> ## even for unusual R objects :
> identical(.GlobalEnv, environment())
[1] TRUE
> 
> ### ------- Pickyness Flags : -----------------------------
> 
> ## the infamous example:
> identical(0., -0.) # TRUE, i.e. not differentiated
[1] TRUE
> identical(0., -0., num.eq = FALSE)
[1] FALSE
> ## similar:
> identical(NaN, -NaN) # TRUE
[1] TRUE
> identical(NaN, -NaN, single.NA = FALSE) # differ on bit-level
[1] FALSE
> 
> ### For functions ("closure"s): ----------------------------------------------
> ###     ~~~~~~~~~
> f <- function(x) x
> f
function (x) 
x
> g <- compiler::cmpfun(f)
> g
function (x) 
x
<bytecode: 0x55b757862d90>
> identical(f, g)                        # TRUE, as bytecode is ignored by default
[1] TRUE
> identical(f, g, ignore.bytecode=FALSE) # FALSE: bytecode differs
[1] FALSE
> 
> ## GLM families contain several functions, some of which share an environment:
> p1 <- poisson() ; p2 <- poisson()
> identical(p1, p2)                          # FALSE
[1] FALSE
> identical(p1, p2, ignore.environment=TRUE) # TRUE
[1] TRUE
> 
> ## in interactive use, the 'keep.source' option is typically true:
> op <- options(keep.source = TRUE) # and so, these have differing "srcref" :
> f1 <- function() {}
> f2 <- function() {}
> identical(f1,f2)# ignore.srcref= TRUE : TRUE
[1] TRUE
> identical(f1,f2,  ignore.srcref=FALSE)# FALSE
[1] FALSE
> options(op) # revert to previous state
> 
> ## Don't show: 
> m0 <- m <- structure(cbind(I = 1, a = 1:3), foo = "bar", class = "matrix")
> attributes(m0) <- rev(attributes(m))
> names(attributes(m0)) # 'dim' remains first, interestingly...
[1] "dim"      "class"    "foo"      "dimnames"
> 
> stopifnot(identical(0, -0),     !identical(0, -0, num.eq = FALSE),
+           identical(NaN, -NaN), !identical(NaN, -NaN, single.NA = FALSE),
+           identical(m, m0),     !identical(m, m0, attrib.as.set = FALSE) )
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("ifelse")
> ### * ifelse
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ifelse
> ### Title: Conditional Element Selection
> ### Aliases: ifelse
> ### Keywords: logic programming
> 
> ### ** Examples
> 
> x <- c(6:-4)
> sqrt(x)  #- gives warning
Warning in sqrt(x) : NaNs produced
 [1] 2.449490 2.236068 2.000000 1.732051 1.414214 1.000000 0.000000      NaN
 [9]      NaN      NaN      NaN
> sqrt(ifelse(x >= 0, x, NA))  # no warning
 [1] 2.449490 2.236068 2.000000 1.732051 1.414214 1.000000 0.000000       NA
 [9]       NA       NA       NA
> 
> ## Note: the following also gives the warning !
> ifelse(x >= 0, sqrt(x), NA)
Warning in sqrt(x) : NaNs produced
 [1] 2.449490 2.236068 2.000000 1.732051 1.414214 1.000000 0.000000       NA
 [9]       NA       NA       NA
> 
> 
> ## ifelse() strips attributes
> ## This is important when working with Dates and factors
> x <- seq(as.Date("2000-02-29"), as.Date("2004-10-04"), by = "1 month")
> ## has many "yyyy-mm-29", but a few "yyyy-03-01" in the non-leap years
> y <- ifelse(as.POSIXlt(x)$mday == 29, x, NA)
> head(y) # not what you expected ... ==> need restore the class attribute:
[1] 11016 11045 11076 11106 11137 11167
> class(y) <- class(x)
> y
 [1] "2000-02-29" "2000-03-29" "2000-04-29" "2000-05-29" "2000-06-29"
 [6] "2000-07-29" "2000-08-29" "2000-09-29" "2000-10-29" "2000-11-29"
[11] "2000-12-29" "2001-01-29" NA           "2001-03-29" "2001-04-29"
[16] "2001-05-29" "2001-06-29" "2001-07-29" "2001-08-29" "2001-09-29"
[21] "2001-10-29" "2001-11-29" "2001-12-29" "2002-01-29" NA          
[26] "2002-03-29" "2002-04-29" "2002-05-29" "2002-06-29" "2002-07-29"
[31] "2002-08-29" "2002-09-29" "2002-10-29" "2002-11-29" "2002-12-29"
[36] "2003-01-29" NA           "2003-03-29" "2003-04-29" "2003-05-29"
[41] "2003-06-29" "2003-07-29" "2003-08-29" "2003-09-29" "2003-10-29"
[46] "2003-11-29" "2003-12-29" "2004-01-29" "2004-02-29" "2004-03-29"
[51] "2004-04-29" "2004-05-29" "2004-06-29" "2004-07-29" "2004-08-29"
[56] "2004-09-29"
> ## This is a (not atypical) case where it is better *not* to use ifelse(),
> ## but rather the more efficient and still clear:
> y2 <- x
> y2[as.POSIXlt(x)$mday != 29] <- NA
> ## which gives the same as ifelse()+class() hack:
> stopifnot(identical(y2, y))
> 
> 
> ## example of different return modes (and 'test' alone determining length):
> yes <- 1:3
> no  <- pi^(1:4)
> utils::str( ifelse(NA,    yes, no) ) # logical, length 1
 logi NA
> utils::str( ifelse(TRUE,  yes, no) ) # integer, length 1
 int 1
> utils::str( ifelse(FALSE, yes, no) ) # double,  length 1
 num 3.14
> 
> 
> 
> cleanEx()
> nameEx("integer")
> ### * integer
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: integer
> ### Title: Integer Vectors
> ### Aliases: integer as.integer is.integer
> ### Keywords: classes
> 
> ### ** Examples
> 
> ## as.integer() truncates:
> x <- pi * c(-1:1, 10)
> as.integer(x)
[1] -3  0  3 31
> 
> is.integer(1) # is FALSE !
[1] FALSE
> 
> is.wholenumber <-
+     function(x, tol = .Machine$double.eps^0.5)  abs(x - round(x)) < tol
> is.wholenumber(1) # is TRUE
[1] TRUE
> (x <- seq(1, 5, by = 0.5) )
[1] 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0
> is.wholenumber( x ) #-->  TRUE FALSE TRUE ...
[1]  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE
> 
> 
> 
> cleanEx()
> nameEx("interaction")
> ### * interaction
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: interaction
> ### Title: Compute Factor Interactions
> ### Aliases: interaction
> ### Keywords: category
> 
> ### ** Examples
> 
> a <- gl(2, 4, 8)
> b <- gl(2, 2, 8, labels = c("ctrl", "treat"))
> s <- gl(2, 1, 8, labels = c("M", "F"))
> interaction(a, b)
[1] 1.ctrl  1.ctrl  1.treat 1.treat 2.ctrl  2.ctrl  2.treat 2.treat
Levels: 1.ctrl 2.ctrl 1.treat 2.treat
> interaction(a, b, s, sep = ":")
[1] 1:ctrl:M  1:ctrl:F  1:treat:M 1:treat:F 2:ctrl:M  2:ctrl:F  2:treat:M
[8] 2:treat:F
8 Levels: 1:ctrl:M 2:ctrl:M 1:treat:M 2:treat:M 1:ctrl:F ... 2:treat:F
> stopifnot(identical(a:s,
+                     interaction(a, s, sep = ":", lex.order = TRUE)),
+           identical(a:s:b,
+                     interaction(a, s, b, sep = ":", lex.order = TRUE)))
> 
> 
> 
> cleanEx()
> nameEx("interactive")
> ### * interactive
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: interactive
> ### Title: Is R Running Interactively?
> ### Aliases: interactive
> ### Keywords: environment programming
> 
> ### ** Examples
> 
>  .First <- function() if(interactive()) x11()
> 
> 
> 
> cleanEx()
> nameEx("invisible")
> ### * invisible
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: invisible
> ### Title: Change the Print Mode to Invisible
> ### Aliases: invisible
> ### Keywords: programming
> 
> ### ** Examples
> 
> # These functions both return their argument
> f1 <- function(x) x
> f2 <- function(x) invisible(x)
> f1(1)  # prints
[1] 1
> f2(1)  # does not
> 
> 
> 
> cleanEx()
> nameEx("is.finite")
> ### * is.finite
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: is.finite
> ### Title: Finite, Infinite and NaN Numbers
> ### Aliases: is.finite is.infinite Inf NaN is.nan finite infinite
> ### Keywords: programming math
> 
> ### ** Examples
> 
> pi / 0 ## = Inf a non-zero number divided by zero creates infinity
[1] Inf
> 0 / 0  ## =  NaN
[1] NaN
> 
> 1/0 + 1/0 # Inf
[1] Inf
> 1/0 - 1/0 # NaN
[1] NaN
> 
> stopifnot(
+     1/0 == Inf,
+     1/Inf == 0
+ )
> sin(Inf)
Warning in sin(Inf) : NaNs produced
[1] NaN
> cos(Inf)
Warning in cos(Inf) : NaNs produced
[1] NaN
> tan(Inf)
Warning in tan(Inf) : NaNs produced
[1] NaN
> 
> 
> 
> cleanEx()
> nameEx("is.function")
> ### * is.function
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: is.function
> ### Title: Is an Object of Type (Primitive) Function?
> ### Aliases: is.function is.primitive
> ### Keywords: programming
> 
> ### ** Examples
> 
> is.function(1) # FALSE
[1] FALSE
> is.function (is.primitive) # TRUE: it is a function, but ..
[1] TRUE
> is.primitive(is.primitive) # FALSE: it's not a primitive one, whereas
[1] FALSE
> is.primitive(is.function)  # TRUE: that one *is*
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("is.language")
> ### * is.language
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: is.language
> ### Title: Is an Object a Language Object?
> ### Aliases: is.language language 'language object' 'language objects'
> ### Keywords: programming
> 
> ### ** Examples
> 
> ll <- list(a = expression(x^2 - 2*x + 1), b = as.name("Jim"),
+            c = as.expression(exp(1)), d = call("sin", pi))
> sapply(ll, typeof)
           a            b            c            d 
"expression"     "symbol" "expression"   "language" 
> sapply(ll, mode)
           a            b            c            d 
"expression"       "name" "expression"       "call" 
> stopifnot(sapply(ll, is.language))
> 
> 
> 
> cleanEx()
> nameEx("is.object")
> ### * is.object
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: is.object
> ### Title: Is an Object 'internally classed'?
> ### Aliases: is.object
> ### Keywords: methods classes
> 
> ### ** Examples
> 
> is.object(1) # FALSE
[1] FALSE
> is.object(as.factor(1:3)) # TRUE
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("is.recursive")
> ### * is.recursive
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: is.recursive
> ### Title: Is an Object Atomic or Recursive?
> ### Aliases: is.atomic is.recursive
> ### Keywords: programming classes
> 
> ### ** Examples
> 
> require(stats)
> 
> is.a.r <- function(x) c(is.atomic(x), is.recursive(x))
> 
> is.a.r(c(a = 1, b = 3)) # TRUE FALSE
[1]  TRUE FALSE
> is.a.r(list())          # FALSE TRUE - a list is a list
[1] FALSE  TRUE
> is.a.r(list(2))         # FALSE TRUE
[1] FALSE  TRUE
> is.a.r(lm)              # FALSE TRUE
[1] FALSE  TRUE
> is.a.r(y ~ x)           # FALSE TRUE
[1] FALSE  TRUE
> is.a.r(expression(x+1)) # FALSE TRUE
[1] FALSE  TRUE
> is.a.r(quote(exp))      # FALSE FALSE
[1] FALSE FALSE
> 
> 
> 
> cleanEx()
> nameEx("isR")
> ### * isR
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: is.R
> ### Title: Are we using R, rather than S?
> ### Aliases: is.R
> ### Keywords: environment utilities
> 
> ### ** Examples
> 
> x <- stats::runif(20); small <- x < 0.4
> ## In the early years of R, 'which()' only existed in R:
> if(is.R()) which(small) else seq(along = small)[small]
[1]  1  2  5 10 11 12 14 19
> 
> 
> 
> cleanEx()
> nameEx("isS4")
> ### * isS4
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: isS4
> ### Title: Test for an S4 object
> ### Aliases: isS4 asS4 S4 asS3
> ### Keywords: programming
> 
> ### ** Examples
> 
> ## Don't show: 
> require(methods)
> ## End(Don't show)
> isS4(pi) # FALSE
[1] FALSE
> isS4(getClass("MethodDefinition")) # TRUE
[1] TRUE
> ## Don't show: 
> stopifnot(isS4(asS4(Sys.time())))
> ## Following is a correction of previous behavior. See note in the
> ## value section above
> stopifnot(isS4(asS4(getClass("MethodDefinition"), FALSE, 2)))
> stopifnot(!isS4(asS4(getClass("MethodDefinition"), FALSE, 0)))
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("isSymmetric")
> ### * isSymmetric
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: isSymmetric
> ### Title: Test if a Matrix or other Object is Symmetric (Hermitian)
> ### Aliases: isSymmetric isSymmetric.matrix
> ### Keywords: array utilities
> 
> ### ** Examples
> 
> isSymmetric(D3 <- diag(3)) # -> TRUE
[1] TRUE
> 
> D3[2, 1] <- 1e-100
> D3
       [,1] [,2] [,3]
[1,]  1e+00    0    0
[2,] 1e-100    1    0
[3,]  0e+00    0    1
> isSymmetric(D3) # TRUE
[1] TRUE
> isSymmetric(D3, tol = 0) # FALSE for zero-tolerance
[1] FALSE
> 
> ## Complex Matrices - Hermitian or not
> Z <- sqrt(matrix(-1:2 + 0i, 2)); Z <- t(Conj(Z)) %*% Z
> Z
     [,1] [,2]
[1,] 1+0i 0-1i
[2,] 0+1i 3+0i
> isSymmetric(Z)      # TRUE
[1] TRUE
> isSymmetric(Z + 1)  # TRUE
[1] TRUE
> isSymmetric(Z + 1i) # FALSE -- a Hermitian matrix has a *real* diagonal
[1] FALSE
> 
> colnames(D3) <- c("X", "Y", "Z")
> isSymmetric(D3)                         # FALSE (as row and column names differ)
[1] FALSE
> isSymmetric(D3, check.attributes=FALSE) # TRUE  (as names are not checked)
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("jitter")
> ### * jitter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: jitter
> ### Title: 'Jitter' (Add Noise) to Numbers
> ### Aliases: jitter
> ### Keywords: dplot utilities
> 
> ### ** Examples
> 
> round(jitter(c(rep(1, 3), rep(1.2, 4), rep(3, 3))), 3)
 [1] 0.981 0.990 1.006 1.233 1.176 1.232 1.236 3.013 3.010 2.965
> ## These two 'fail' with S-plus 3.x:
> jitter(rep(0, 7))
[1] -1.176102e-02 -1.293773e-02  7.480914e-03 -4.635851e-03  1.079366e-02
[6] -9.203032e-05  8.704740e-03
> jitter(rep(10000, 5))
[1] 10196.762  9952.014 10110.978 10173.882  9884.857
> 
> 
> 
> cleanEx()
> nameEx("kappa")
> ### * kappa
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: kappa
> ### Title: Compute or Estimate the Condition Number of a Matrix
> ### Aliases: rcond kappa kappa.default kappa.lm kappa.qr .kappa_tri
> ### Keywords: math
> 
> ### ** Examples
> 
> kappa(x1 <- cbind(1, 1:10)) # 15.71
[1] 15.7059
> kappa(x1, exact = TRUE)        # 13.68
[1] 13.67903
> kappa(x2 <- cbind(x1, 2:11)) # high! [x2 is singular!]
[1] 3.98138e+16
> 
> hilbert <- function(n) { i <- 1:n; 1 / outer(i - 1, i, "+") }
> sv9 <- svd(h9 <- hilbert(9))$ d
> kappa(h9)  # pretty high!
[1] 728288858878
> kappa(h9, exact = TRUE) == max(sv9) / min(sv9)
[1] FALSE
> kappa(h9, exact = TRUE) / kappa(h9)  # 0.677 (i.e., rel.error = 32%)
[1] 0.6771397
> 
> 
> 
> cleanEx()
> nameEx("kronecker")
> ### * kronecker
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: kronecker
> ### Title: Kronecker Products on Arrays
> ### Aliases: kronecker .kronecker %x%
> ### Keywords: array
> 
> ### ** Examples
> 
> # simple scalar multiplication
> ( M <- matrix(1:6, ncol = 2) )
     [,1] [,2]
[1,]    1    4
[2,]    2    5
[3,]    3    6
> kronecker(4, M)
     [,1] [,2]
[1,]    4   16
[2,]    8   20
[3,]   12   24
> # Block diagonal matrix:
> kronecker(diag(1, 3), M)
      [,1] [,2] [,3] [,4] [,5] [,6]
 [1,]    1    4    0    0    0    0
 [2,]    2    5    0    0    0    0
 [3,]    3    6    0    0    0    0
 [4,]    0    0    1    4    0    0
 [5,]    0    0    2    5    0    0
 [6,]    0    0    3    6    0    0
 [7,]    0    0    0    0    1    4
 [8,]    0    0    0    0    2    5
 [9,]    0    0    0    0    3    6
> 
> # ask for dimnames
> 
> fred <- matrix(1:12, 3, 4, dimnames = list(LETTERS[1:3], LETTERS[4:7]))
> bill <- c("happy" = 100, "sad" = 1000)
> kronecker(fred, bill, make.dimnames = TRUE)
          D:   E:   F:    G:
A:happy  100  400  700  1000
A:sad   1000 4000 7000 10000
B:happy  200  500  800  1100
B:sad   2000 5000 8000 11000
C:happy  300  600  900  1200
C:sad   3000 6000 9000 12000
> 
> bill <- outer(bill, c("cat" = 3, "dog" = 4))
> kronecker(fred, bill, make.dimnames = TRUE)
        D:cat D:dog E:cat E:dog F:cat F:dog G:cat G:dog
A:happy   300   400  1200  1600  2100  2800  3000  4000
A:sad    3000  4000 12000 16000 21000 28000 30000 40000
B:happy   600   800  1500  2000  2400  3200  3300  4400
B:sad    6000  8000 15000 20000 24000 32000 33000 44000
C:happy   900  1200  1800  2400  2700  3600  3600  4800
C:sad    9000 12000 18000 24000 27000 36000 36000 48000
> 
> 
> 
> cleanEx()
> nameEx("l10n_info")
> ### * l10n_info
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: l10n_info
> ### Title: Localization Information
> ### Aliases: l10n_info
> ### Keywords: utilities
> 
> ### ** Examples
> 
> l10n_info()
$MBCS
[1] TRUE

$`UTF-8`
[1] TRUE

$`Latin-1`
[1] FALSE

> 
> 
> 
> cleanEx()
> nameEx("lapply")
> ### * lapply
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: lapply
> ### Title: Apply a Function over a List or Vector
> ### Aliases: lapply sapply vapply replicate simplify2array
> ### Keywords: iteration list
> 
> ### ** Examples
> 
> require(stats); require(graphics)
> 
> x <- list(a = 1:10, beta = exp(-3:3), logic = c(TRUE,FALSE,FALSE,TRUE))
> # compute the list mean for each list element
> lapply(x, mean)
$a
[1] 5.5

$beta
[1] 4.535125

$logic
[1] 0.5

> # median and quartiles for each list element
> lapply(x, quantile, probs = 1:3/4)
$a
 25%  50%  75% 
3.25 5.50 7.75 

$beta
      25%       50%       75% 
0.2516074 1.0000000 5.0536690 

$logic
25% 50% 75% 
0.0 0.5 1.0 

> sapply(x, quantile)
         a        beta logic
0%    1.00  0.04978707   0.0
25%   3.25  0.25160736   0.0
50%   5.50  1.00000000   0.5
75%   7.75  5.05366896   1.0
100% 10.00 20.08553692   1.0
> i39 <- sapply(3:9, seq) # list of vectors
> sapply(i39, fivenum)
     [,1] [,2] [,3] [,4] [,5] [,6] [,7]
[1,]  1.0  1.0    1  1.0  1.0  1.0    1
[2,]  1.5  1.5    2  2.0  2.5  2.5    3
[3,]  2.0  2.5    3  3.5  4.0  4.5    5
[4,]  2.5  3.5    4  5.0  5.5  6.5    7
[5,]  3.0  4.0    5  6.0  7.0  8.0    9
> vapply(i39, fivenum,
+        c(Min. = 0, "1st Qu." = 0, Median = 0, "3rd Qu." = 0, Max. = 0))
        [,1] [,2] [,3] [,4] [,5] [,6] [,7]
Min.     1.0  1.0    1  1.0  1.0  1.0    1
1st Qu.  1.5  1.5    2  2.0  2.5  2.5    3
Median   2.0  2.5    3  3.5  4.0  4.5    5
3rd Qu.  2.5  3.5    4  5.0  5.5  6.5    7
Max.     3.0  4.0    5  6.0  7.0  8.0    9
> 
> ## sapply(*, "array") -- artificial example
> (v <- structure(10*(5:8), names = LETTERS[1:4]))
 A  B  C  D 
50 60 70 80 
> f2 <- function(x, y) outer(rep(x, length.out = 3), y)
> (a2 <- sapply(v, f2, y = 2*(1:5), simplify = "array"))
, , A

     [,1] [,2] [,3] [,4] [,5]
[1,]  100  200  300  400  500
[2,]  100  200  300  400  500
[3,]  100  200  300  400  500

, , B

     [,1] [,2] [,3] [,4] [,5]
[1,]  120  240  360  480  600
[2,]  120  240  360  480  600
[3,]  120  240  360  480  600

, , C

     [,1] [,2] [,3] [,4] [,5]
[1,]  140  280  420  560  700
[2,]  140  280  420  560  700
[3,]  140  280  420  560  700

, , D

     [,1] [,2] [,3] [,4] [,5]
[1,]  160  320  480  640  800
[2,]  160  320  480  640  800
[3,]  160  320  480  640  800

> a.2 <- vapply(v, f2, outer(1:3, 1:5), y = 2*(1:5))
> stopifnot(dim(a2) == c(3,5,4), all.equal(a2, a.2),
+           identical(dimnames(a2), list(NULL,NULL,LETTERS[1:4])))
> 
> hist(replicate(100, mean(rexp(10))))
> 
> ## use of replicate() with parameters:
> foo <- function(x = 1, y = 2) c(x, y)
> # does not work: bar <- function(n, ...) replicate(n, foo(...))
> bar <- function(n, x) replicate(n, foo(x = x))
> bar(5, x = 3)
     [,1] [,2] [,3] [,4] [,5]
[1,]    3    3    3    3    3
[2,]    2    2    2    2    2
> 
> 
> 
> cleanEx()
> nameEx("length")
> ### * length
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: length
> ### Title: Length of an Object
> ### Aliases: length length<- length<-.factor
> ### Keywords: attribute
> 
> ### ** Examples
> 
> length(diag(4))  # = 16 (4 x 4)
[1] 16
> length(options())  # 12 or more
[1] 67
> length(y ~ x1 + x2 + x3)  # 3
[1] 3
> length(expression(x, {y <- x^2; y+2}, x^y))  # 3
[1] 3
> 
> ## from example(warpbreaks)
> require(stats)
> 
> fm1 <- lm(breaks ~ wool * tension, data = warpbreaks)
> length(fm1$call)      # 3, lm() and two arguments.
[1] 3
> length(formula(fm1))  # 3, ~ lhs rhs
[1] 3
> 
> 
> 
> cleanEx()
> nameEx("lengths")
> ### * lengths
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: lengths
> ### Title: Lengths of List or Vector Elements
> ### Aliases: lengths
> ### Keywords: attribute
> 
> ### ** Examples
> 
> require(stats)
> ## summarize by month
> l <- split(airquality$Ozone, airquality$Month)
> avgOz <- lapply(l, mean, na.rm=TRUE)
> ## merge result
> airquality$avgOz <- rep(unlist(avgOz, use.names=FALSE), lengths(l))
> ## but this is safer and cleaner, but can be slower
> airquality$avgOz <- unsplit(avgOz, airquality$Month)
> 
> ## should always be true, except when a length does not fit in 32 bits
> stopifnot(identical(lengths(l), vapply(l, length, integer(1L))))
> 
> ## empty lists are not a problem
> x <- list()
> stopifnot(identical(lengths(x), integer()))
> 
> ## nor are "list-like" expressions:
> lengths(expression(u, v, 1+ 0:9))
[1] 1 1 3
> 
> ## and we should dispatch to length methods
> f <- c(rep(1, 3), rep(2, 6), 3)
> dates <- split(as.POSIXlt(Sys.time() + 1:10), f)
> stopifnot(identical(lengths(dates), vapply(dates, length, integer(1L))))
> 
> 
> 
> cleanEx()
> nameEx("levels")
> ### * levels
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: levels
> ### Title: Levels Attributes
> ### Aliases: levels levels.default levels<- levels<-.factor
> ### Keywords: category
> 
> ### ** Examples
> 
> ## assign individual levels
> x <- gl(2, 4, 8)
> levels(x)[1] <- "low"
> levels(x)[2] <- "high"
> x
[1] low  low  low  low  high high high high
Levels: low high
> 
> ## or as a group
> y <- gl(2, 4, 8)
> levels(y) <- c("low", "high")
> y
[1] low  low  low  low  high high high high
Levels: low high
> 
> ## combine some levels
> z <- gl(3, 2, 12, labels = c("apple", "salad", "orange"))
> z
 [1] apple  apple  salad  salad  orange orange apple  apple  salad  salad 
[11] orange orange
Levels: apple salad orange
> levels(z) <- c("fruit", "veg", "fruit")
> z
 [1] fruit fruit veg   veg   fruit fruit fruit fruit veg   veg   fruit fruit
Levels: fruit veg
> 
> ## same, using a named list
> z <- gl(3, 2, 12, labels = c("apple", "salad", "orange"))
> z
 [1] apple  apple  salad  salad  orange orange apple  apple  salad  salad 
[11] orange orange
Levels: apple salad orange
> levels(z) <- list("fruit" = c("apple","orange"),
+                   "veg"   = "salad")
> z
 [1] fruit fruit veg   veg   fruit fruit fruit fruit veg   veg   fruit fruit
Levels: fruit veg
> 
> ## we can add levels this way:
> f <- factor(c("a","b"))
> levels(f) <- c("c", "a", "b")
> f
[1] c a
Levels: c a b
> 
> f <- factor(c("a","b"))
> levels(f) <- list(C = "C", A = "a", B = "b")
> f
[1] A B
Levels: C A B
> 
> 
> 
> cleanEx()
> nameEx("libPaths")
> ### * libPaths
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: libPaths
> ### Title: Search Paths for Packages
> ### Aliases: .Library .Library.site .libPaths R_LIBS R_LIBS_SITE
> ###   R_LIBS_USER .expand_R_libs_env_var
> ### Keywords: data
> 
> ### ** Examples
> 
> .libPaths()                 # all library trees R knows about
[1] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"     
> 
> 
> 
> cleanEx()
> nameEx("libcurlVersion")
> ### * libcurlVersion
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: libcurlVersion
> ### Title: Report Version of libcurl
> ### Aliases: libcurlVersion
> 
> ### ** Examples
> 
> libcurlVersion()
[1] "7.68.0"
attr(,"ssl_version")
[1] "OpenSSL/1.1.1f"
attr(,"libssh_version")
[1] "libssh/0.9.3/openssl/zlib"
attr(,"protocols")
 [1] "dict"   "file"   "ftp"    "ftps"   "gopher" "http"   "https"  "imap"  
 [9] "imaps"  "ldap"   "ldaps"  "pop3"   "pop3s"  "rtmp"   "rtsp"   "scp"   
[17] "sftp"   "smb"    "smbs"   "smtp"   "smtps"  "telnet" "tftp"  
> 
> 
> 
> cleanEx()
> nameEx("library")
> ### * library
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: library
> ### Title: Loading/Attaching and Listing of Packages
> ### Aliases: library require conflictRules .noGenerics format.libraryIQR
> ###   print.libraryIQR format.packageInfo print.packageInfo
> ### Keywords: data
> 
> ### ** Examples
> 
> library()                   # list all available packages
Packages in library ‘/usr/local/lib/R/site-library’:

base64enc               Tools for base64 encoding
cli                     Helpers for Developing Command Line Interfaces
crayon                  Colored Terminal Output
digest                  Create Compact Hash Digests of R Objects
dplyr                   A Grammar of Data Manipulation
ellipsis                Tools for Working with ...
evaluate                Parsing and Evaluation Tools that Provide More
                        Details than the Default
fansi                   ANSI Control Sequence Aware String Functions
fastmap                 Fast Data Structures
generics                Common S3 Generics not Provided by Base R
                        Methods Related to Model Fitting
glue                    Interpreted String Literals
highr                   Syntax Highlighting for R Source Code
htmltools               Tools for HTML
jsonlite                A Simple and Robust JSON Parser and Generator
                        for R
knitr                   A General-Purpose Package for Dynamic Report
                        Generation in R
lifecycle               Manage the Life Cycle of your Package Functions
magrittr                A Forward-Pipe Operator for R
markdown                Render Markdown with the C Library 'Sundown'
mime                    Map Filenames to MIME Types
pillar                  Coloured Formatting for Columns
pkgconfig               Private Configuration for 'R' Packages
purrr                   Functional Programming Tools
R6                      Encapsulated Classes with Reference Semantics
rlang                   Functions for Base Types and Core R and
                        'Tidyverse' Features
rmarkdown               Dynamic Documents for R
stringi                 Character String Processing Facilities
stringr                 Simple, Consistent Wrappers for Common String
                        Operations
tibble                  Simple Data Frames
tidyselect              Select from a Set of Strings
tinytex                 Helper Functions to Install and Maintain TeX
                        Live, and Compile LaTeX Documents
utf8                    Unicode Text Processing
vctrs                   Vector Helpers
xfun                    Supporting Functions for Packages Maintained by
                        'Yihui Xie'
yaml                    Methods to Convert R Data to YAML and Back

Packages in library ‘/usr/local/lib/R/library’:

base                    The R Base Package
boot                    Bootstrap Functions (Originally by Angelo Canty
                        for S)
class                   Functions for Classification
cluster                 "Finding Groups in Data": Cluster Analysis
                        Extended Rousseeuw et al.
codetools               Code Analysis Tools for R
compiler                The R Compiler Package
datasets                The R Datasets Package
foreign                 Read Data Stored by 'Minitab', 'S', 'SAS',
                        'SPSS', 'Stata', 'Systat', 'Weka', 'dBase', ...
graphics                The R Graphics Package
grDevices               The R Graphics Devices and Support for Colours
                        and Fonts
grid                    The Grid Graphics Package
KernSmooth              Functions for Kernel Smoothing Supporting Wand
                        & Jones (1995)
lattice                 Trellis Graphics for R
MASS                    Support Functions and Datasets for Venables and
                        Ripley's MASS
Matrix                  Sparse and Dense Matrix Classes and Methods
methods                 Formal Methods and Classes
mgcv                    Mixed GAM Computation Vehicle with Automatic
                        Smoothness Estimation
nlme                    Linear and Nonlinear Mixed Effects Models
nnet                    Feed-Forward Neural Networks and Multinomial
                        Log-Linear Models
parallel                Support for Parallel computation in R
rpart                   Recursive Partitioning and Regression Trees
spatial                 Functions for Kriging and Point Pattern
                        Analysis
splines                 Regression Spline Functions and Classes
stats                   The R Stats Package
stats4                  Statistical Functions using S4 Classes
survival                Survival Analysis
tcltk                   Tcl/Tk Interface
tools                   Tools for Package Development
utils                   The R Utils Package

> library(lib.loc = .Library) # list all packages in the default library
Packages in library ‘/usr/local/lib/R/library’:

base                    The R Base Package
boot                    Bootstrap Functions (Originally by Angelo Canty
                        for S)
class                   Functions for Classification
cluster                 "Finding Groups in Data": Cluster Analysis
                        Extended Rousseeuw et al.
codetools               Code Analysis Tools for R
compiler                The R Compiler Package
datasets                The R Datasets Package
foreign                 Read Data Stored by 'Minitab', 'S', 'SAS',
                        'SPSS', 'Stata', 'Systat', 'Weka', 'dBase', ...
graphics                The R Graphics Package
grDevices               The R Graphics Devices and Support for Colours
                        and Fonts
grid                    The Grid Graphics Package
KernSmooth              Functions for Kernel Smoothing Supporting Wand
                        & Jones (1995)
lattice                 Trellis Graphics for R
MASS                    Support Functions and Datasets for Venables and
                        Ripley's MASS
Matrix                  Sparse and Dense Matrix Classes and Methods
methods                 Formal Methods and Classes
mgcv                    Mixed GAM Computation Vehicle with Automatic
                        Smoothness Estimation
nlme                    Linear and Nonlinear Mixed Effects Models
nnet                    Feed-Forward Neural Networks and Multinomial
                        Log-Linear Models
parallel                Support for Parallel computation in R
rpart                   Recursive Partitioning and Regression Trees
spatial                 Functions for Kriging and Point Pattern
                        Analysis
splines                 Regression Spline Functions and Classes
stats                   The R Stats Package
stats4                  Statistical Functions using S4 Classes
survival                Survival Analysis
tcltk                   Tcl/Tk Interface
tools                   Tools for Package Development
utils                   The R Utils Package

> library(splines)            # attach package 'splines'
> require(splines)            # the same
> search()                    # "splines", too
 [1] ".GlobalEnv"        "package:splines"   "CheckExEnv"       
 [4] "package:stats"     "package:graphics"  "package:grDevices"
 [7] "package:utils"     "package:datasets"  "package:methods"  
[10] "Autoloads"         "package:base"     
> detach("package:splines")
> 
> # if the package name is in a character vector, use
> pkg <- "splines"
> library(pkg, character.only = TRUE)
> detach(pos = match(paste("package", pkg, sep = ":"), search()))
> 
> require(pkg, character.only = TRUE)
Loading required package: splines
> detach(pos = match(paste("package", pkg, sep = ":"), search()))
> 
> require(nonexistent)        # FALSE
Loading required package: nonexistent
Warning in library(package, lib.loc = lib.loc, character.only = TRUE, logical.return = TRUE,  :
  there is no package called ‘nonexistent’
> ## Not run: 
> ##D ## if you want to mask as little as possible, use
> ##D library(mypkg, pos = "package:base")
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("library.dynam")
> ### * library.dynam
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: library.dynam
> ### Title: Loading DLLs from Packages
> ### Aliases: library.dynam library.dynam.unload .dynLibs
> ### Keywords: data
> 
> ### ** Examples
> 
> ## Which DLLs were dynamically loaded by packages?
> library.dynam()
                                              Filename Dynamic.Lookup
1     /usr/local/lib/R/library/methods/libs/methods.so          FALSE
2         /usr/local/lib/R/library/utils/libs/utils.so          FALSE
3 /usr/local/lib/R/library/grDevices/libs/grDevices.so          FALSE
4   /usr/local/lib/R/library/graphics/libs/graphics.so          FALSE
5         /usr/local/lib/R/library/stats/libs/stats.so          FALSE
6         /usr/local/lib/R/library/tools/libs/tools.so          FALSE
7     /usr/local/lib/R/library/splines/libs/splines.so          FALSE
> 
> ## More on library.dynam.unload() :
> 
> 
> 
> cleanEx()
> nameEx("list")
> ### * list
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: list
> ### Title: Lists - Generic and Dotted Pairs
> ### Aliases: list pairlist alist as.list as.list.default as.list.data.frame
> ###   as.list.environment as.list.factor as.list.function as.pairlist
> ###   is.list is.pairlist
> ### Keywords: list manip
> 
> ### ** Examples
> 
> require(graphics)
> 
> # create a plotting structure
> pts <- list(x = cars[,1], y = cars[,2])
> plot(pts)
> 
> is.pairlist(.Options)  # a user-level pairlist
[1] TRUE
> 
> ## "pre-allocate" an empty list of length 5
> vector("list", 5)
[[1]]
NULL

[[2]]
NULL

[[3]]
NULL

[[4]]
NULL

[[5]]
NULL

> 
> # Argument lists
> f <- function() x
> # Note the specification of a "..." argument:
> formals(f) <- al <- alist(x = , y = 2+3, ... = )
> f
function (x, y = 2 + 3, ...) 
x
> al
$x


$y
2 + 3

$...


> 
> ## environment->list coercion
> 
> e1 <- new.env()
> e1$a <- 10
> e1$b <- 20
> as.list(e1)
$a
[1] 10

$b
[1] 20

> 
> 
> 
> cleanEx()
> nameEx("list.files")
> ### * list.files
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: list.files
> ### Title: List the Files in a Directory/Folder
> ### Aliases: list.files dir list.dirs
> ### Keywords: file
> 
> ### ** Examples
> 
> list.files(R.home())
 [1] "bin"          "COPYING"      "doc"          "etc"          "include"     
 [6] "lib"          "library"      "modules"      "share"        "site-library"
[11] "SVN-REVISION" "tests"       
> ## Only files starting with a-l or r
> ## Note that a-l is locale-dependent, but using case-insensitive
> ## matching makes it unambiguous in English locales
> dir("../..", pattern = "^[a-lr]", full.names = TRUE, ignore.case = TRUE)
[1] "../../Container_Validation.Rmd" "../../results"                 
> 
> list.dirs(R.home("doc"))
[1] "/usr/local/lib/R/doc"               "/usr/local/lib/R/doc/html"         
[3] "/usr/local/lib/R/doc/manual"        "/usr/local/lib/R/doc/manual/images"
> list.dirs(R.home("doc"), full.names = FALSE)
[1] ""              "html"          "manual"        "manual/images"
> 
> 
> 
> cleanEx()
> nameEx("list2DF")
> ### * list2DF
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: list2DF
> ### Title: Create Data Frame From List
> ### Aliases: list2DF
> ### Keywords: classes
> 
> ### ** Examples
> 
> ## Create a data frame holding a list of character vectors and the
> ## corresponding lengths:
> x <- list(character(), "A", c("B", "C"))
> n <- lengths(x)
> list2DF(list(x = x, n = n))
     x n
1      0
2    A 1
3 B, C 2
> 
> ## Create data frames with no variables and the desired number of rows:
> list2DF()
data frame with 0 columns and 0 rows
> list2DF(nrow = 3L)
data frame with 0 columns and 3 rows
> 
> 
> 
> cleanEx()
> nameEx("list2env")
> ### * list2env
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: list2env
> ### Title: From A List, Build or Add To an Environment
> ### Aliases: list2env
> ### Keywords: data
> 
> ### ** Examples
> 
> L <- list(a = 1, b = 2:4, p = pi, ff = gl(3, 4, labels = LETTERS[1:3]))
> e <- list2env(L)
> ls(e)
[1] "a"  "b"  "ff" "p" 
> stopifnot(ls(e) == sort(names(L)),
+           identical(L$b, e$b)) # "$" working for environments as for lists
> 
> ## consistency, when we do the inverse:
> ll <- as.list(e)  # -> dispatching to the as.list.environment() method
> rbind(names(L), names(ll)) # not in the same order, typically,
     [,1] [,2] [,3] [,4]
[1,] "a"  "b"  "p"  "ff"
[2,] "ff" "p"  "b"  "a" 
>                            # but the same content:
> stopifnot(identical(L [sort.list(names(L ))],
+                     ll[sort.list(names(ll))]))
> 
> ## now add to e -- can be seen as a fast "multi-assign":
> list2env(list(abc = LETTERS, note = "just an example",
+               df = data.frame(x = rnorm(20), y = rbinom(20, 1, pr = 0.2))),
+          envir = e)
<environment: 0x55b758b94ea8>
> utils::ls.str(e)
a :  num 1
abc :  chr [1:26] "A" "B" "C" "D" "E" "F" "G" "H" "I" "J" "K" "L" "M" "N" "O" "P" ...
b :  int [1:3] 2 3 4
df : 'data.frame':	20 obs. of  2 variables:
 $ x: num  -0.626 0.184 -0.836 1.595 0.33 ...
 $ y: int  1 0 0 0 0 0 0 0 0 0 ...
ff :  Factor w/ 3 levels "A","B","C": 1 1 1 1 2 2 2 2 3 3 ...
note :  chr "just an example"
p :  num 3.14
> 
> 
> 
> cleanEx()
> nameEx("load")
> ### * load
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: load
> ### Title: Reload Saved Datasets
> ### Aliases: load
> ### Keywords: file
> 
> ### ** Examples
> 
> ## Don't show: 
> oldwd <- setwd(tempdir())
> ## End(Don't show)
> 
> ## save all data
> xx <- pi # to ensure there is some data
> save(list = ls(all = TRUE), file= "all.rda")
> rm(xx)
> 
> ## restore the saved values to the current environment
> local({
+    load("all.rda")
+    ls()
+ })
[1] "oldwd" "xx"   
> 
> xx <- exp(1:3)
> ## restore the saved values to the user's workspace
> load("all.rda") ## which is here *equivalent* to
> ## load("all.rda", .GlobalEnv)
> ## This however annihilates all objects in .GlobalEnv with the same names !
> xx # no longer exp(1:3)
[1] 3.141593
> rm(xx)
> attach("all.rda") # safer and will warn about masked objects w/ same name in .GlobalEnv
The following object is masked _by_ .GlobalEnv:

    oldwd

> ls(pos = 2)
[1] "oldwd" "xx"   
> ##  also typically need to cleanup the search path:
> detach("file:all.rda")
> 
> ## clean up (the example):
> unlink("all.rda")
> ## Don't show: 
> setwd(oldwd)
> ## End(Don't show)
> 
> ## Not run: 
> ##D con <- url("http://some.where.net/R/data/example.rda")
> ##D ## print the value to see what objects were created.
> ##D print(load(con))
> ##D close(con) # url() always opens the connection
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("locales")
> ### * locales
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: locales
> ### Title: Query or Set Aspects of the Locale
> ### Aliases: locales Sys.getlocale Sys.setlocale LC_ALL LC_COLLATE LC_CTYPE
> ###   LC_MONETARY LC_NUMERIC LC_TIME LC_MESSAGES LC_PAPER LC_MEASUREMENT
> ### Keywords: utilities
> 
> ### ** Examples
> 
> Sys.getlocale()
[1] "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGES=C;LC_PAPER=en_US.UTF-8;LC_NAME=C;LC_ADDRESS=C;LC_TELEPHONE=C;LC_MEASUREMENT=en_US.UTF-8;LC_IDENTIFICATION=C"
> Sys.getlocale("LC_TIME")
[1] "en_US.UTF-8"
> ## Not run: 
> ##D Sys.setlocale("LC_TIME", "de")     # Solaris: details are OS-dependent
> ##D Sys.setlocale("LC_TIME", "de_DE")  # Many Unix-alikes
> ##D Sys.setlocale("LC_TIME", "de_DE.UTF-8")  # Linux, macOS, other Unix-alikes
> ##D Sys.setlocale("LC_TIME", "de_DE.utf8")   # some Linux versions
> ##D Sys.setlocale("LC_TIME", "German") # Windows
> ## End(Not run)
> Sys.getlocale("LC_PAPER")          # may or may not be set
[1] "en_US.UTF-8"
> 
> ## Not run: 
> ##D Sys.setlocale("LC_COLLATE", "C")   # turn off locale-specific sorting,
> ##D                                    # usually (but not on all platforms)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("lower.tri")
> ### * lower.tri
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: lower.tri
> ### Title: Lower and Upper Triangular Part of a Matrix
> ### Aliases: lower.tri upper.tri
> ### Keywords: array
> 
> ### ** Examples
> 
> (m2 <- matrix(1:20, 4, 5))
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    5    9   13   17
[2,]    2    6   10   14   18
[3,]    3    7   11   15   19
[4,]    4    8   12   16   20
> lower.tri(m2)
      [,1]  [,2]  [,3]  [,4]  [,5]
[1,] FALSE FALSE FALSE FALSE FALSE
[2,]  TRUE FALSE FALSE FALSE FALSE
[3,]  TRUE  TRUE FALSE FALSE FALSE
[4,]  TRUE  TRUE  TRUE FALSE FALSE
> m2[lower.tri(m2)] <- NA
> m2
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    5    9   13   17
[2,]   NA    6   10   14   18
[3,]   NA   NA   11   15   19
[4,]   NA   NA   NA   16   20
> 
> 
> 
> cleanEx()
> nameEx("ls")
> ### * ls
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ls
> ### Title: List Objects
> ### Aliases: ls objects
> ### Keywords: environment
> 
> ### ** Examples
> 
> .Ob <- 1
> ls(pattern = "O")
character(0)
> ls(pattern= "O", all.names = TRUE)    # also shows ".[foo]"
[1] ".Ob"
> 
> # shows an empty list because inside myfunc no variables are defined
> myfunc <- function() {ls()}
> myfunc()
character(0)
> 
> # define a local variable inside myfunc
> myfunc <- function() {y <- 1; ls()}
> myfunc()                # shows "y"
[1] "y"
> 
> 
> 
> cleanEx()
> nameEx("make.names")
> ### * make.names
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: make.names
> ### Title: Make Syntactically Valid Names
> ### Aliases: make.names
> ### Keywords: character
> 
> ### ** Examples
> 
> make.names(c("a and b", "a-and-b"), unique = TRUE)
[1] "a.and.b"   "a.and.b.1"
> # "a.and.b"  "a.and.b.1"
> make.names(c("a and b", "a_and_b"), unique = TRUE)
[1] "a.and.b" "a_and_b"
> # "a.and.b"  "a_and_b"
> make.names(c("a and b", "a_and_b"), unique = TRUE, allow_ = FALSE)
[1] "a.and.b"   "a.and.b.1"
> # "a.and.b"  "a.and.b.1"
> make.names(c("", "X"), unique = TRUE)
[1] "X.1" "X"  
> # "X.1" "X" currently; R up to 3.0.2 gave "X" "X.1"
> 
> state.name[make.names(state.name) != state.name] # those 10 with a space
 [1] "New Hampshire"  "New Jersey"     "New Mexico"     "New York"      
 [5] "North Carolina" "North Dakota"   "Rhode Island"   "South Carolina"
 [9] "South Dakota"   "West Virginia" 
> 
> 
> 
> cleanEx()
> nameEx("make.unique")
> ### * make.unique
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: make.unique
> ### Title: Make Character Strings Unique
> ### Aliases: make.unique
> ### Keywords: character
> 
> ### ** Examples
> 
> make.unique(c("a", "a", "a"))
[1] "a"   "a.1" "a.2"
> make.unique(c(make.unique(c("a", "a")), "a"))
[1] "a"   "a.1" "a.2"
> 
> make.unique(c("a", "a", "a.2", "a"))
[1] "a"   "a.1" "a.2" "a.3"
> make.unique(c(make.unique(c("a", "a")), "a.2", "a"))
[1] "a"   "a.1" "a.2" "a.3"
> 
> ## Now show a bit where this is used :
> trace(make.unique)
> ## Applied in data.frame() constructions:
> (d1 <- data.frame(x = 1, x = 2, x = 3)) # direct
trace: make.unique
  x x.1 x.2
1 1   2   3
>  d2 <- data.frame(data.frame(x = 1, x = 2), x = 3) # pairwise
trace: make.unique
trace: make.unique
> stopifnot(identical(d1, d2),
+           colnames(d1) == c("x", "x.1", "x.2"))
> untrace(make.unique)
> 
> 
> 
> cleanEx()
> nameEx("mapply")
> ### * mapply
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mapply
> ### Title: Apply a Function to Multiple List or Vector Arguments
> ### Aliases: mapply
> ### Keywords: manip utilities
> 
> ### ** Examples
> 
> mapply(rep, 1:4, 4:1)
[[1]]
[1] 1 1 1 1

[[2]]
[1] 2 2 2

[[3]]
[1] 3 3

[[4]]
[1] 4

> 
> mapply(rep, times = 1:4, x = 4:1)
[[1]]
[1] 4

[[2]]
[1] 3 3

[[3]]
[1] 2 2 2

[[4]]
[1] 1 1 1 1

> 
> mapply(rep, times = 1:4, MoreArgs = list(x = 42))
[[1]]
[1] 42

[[2]]
[1] 42 42

[[3]]
[1] 42 42 42

[[4]]
[1] 42 42 42 42

> 
> mapply(function(x, y) seq_len(x) + y,
+        c(a =  1, b = 2, c = 3),  # names from first
+        c(A = 10, B = 0, C = -10))
$a
[1] 11

$b
[1] 1 2

$c
[1] -9 -8 -7

> 
> word <- function(C, k) paste(rep.int(C, k), collapse = "")
> utils::str(mapply(word, LETTERS[1:6], 6:1, SIMPLIFY = FALSE))
List of 6
 $ A: chr "AAAAAA"
 $ B: chr "BBBBB"
 $ C: chr "CCCC"
 $ D: chr "DDD"
 $ E: chr "EE"
 $ F: chr "F"
> 
> 
> 
> cleanEx()
> nameEx("marginSums")
> ### * marginSums
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: marginSums
> ### Title: Compute table margins
> ### Aliases: marginSums margin.table
> ### Keywords: array
> 
> ### ** Examples
> 
> m <- matrix(1:4, 2)
> marginSums(m, 1)
[1] 4 6
> marginSums(m, 2)
[1] 3 7
> 
> 
> DF <- as.data.frame(UCBAdmissions)
> tbl <- xtabs(Freq ~ Gender + Admit, DF)
> 
> marginSums(tbl, "Gender")
Gender
  Male Female 
  2691   1835 
> proportions(tbl, "Gender")
        Admit
Gender    Admitted  Rejected
  Male   0.4451877 0.5548123
  Female 0.3035422 0.6964578
> 
> 
> 
> cleanEx()
> nameEx("mat.or.vec")
> ### * mat.or.vec
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mat.or.vec
> ### Title: Create a Matrix or a Vector
> ### Aliases: mat.or.vec
> ### Keywords: array
> 
> ### ** Examples
> 
> mat.or.vec(3, 1)
[1] 0 0 0
> mat.or.vec(3, 2)
     [,1] [,2]
[1,]    0    0
[2,]    0    0
[3,]    0    0
> 
> 
> 
> cleanEx()
> nameEx("match")
> ### * match
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: match
> ### Title: Value Matching
> ### Aliases: match %in%
> ### Keywords: manip logic
> 
> ### ** Examples
> 
> ## The intersection of two sets can be defined via match():
> ## Simple version:
> ## intersect <- function(x, y) y[match(x, y, nomatch = 0)]
> intersect # the R function in base is slightly more careful
function (x, y) 
{
    y <- as.vector(y)
    unique(y[match(as.vector(x), y, 0L)])
}
<bytecode: 0x55b7589ffd38>
<environment: namespace:base>
> intersect(1:10, 7:20)
[1]  7  8  9 10
> 
> 1:10 %in% c(1,3,5,9)
 [1]  TRUE FALSE  TRUE FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE
> sstr <- c("c","ab","B","bba","c",NA,"@","bla","a","Ba","%")
> sstr[sstr %in% c(letters, LETTERS)]
[1] "c" "B" "c" "a"
> 
> "%w/o%" <- function(x, y) x[!x %in% y] #--  x without y
> (1:10) %w/o% c(3,7,12)
[1]  1  2  4  5  6  8  9 10
> ## Note that setdiff() is very similar and typically makes more sense:
>         c(1:6,7:2) %w/o% c(3,7,12)  # -> keeps duplicates
[1] 1 2 4 5 6 6 5 4 2
> setdiff(c(1:6,7:2),      c(3,7,12)) # -> unique values
[1] 1 2 4 5 6
> 
> ## Illuminating example about NA matching
> r <- c(1, NA, NaN)
> zN <- c(complex(real = NA , imaginary =  r ), complex(real =  r , imaginary = NA ),
+         complex(real =  r , imaginary = NaN), complex(real = NaN, imaginary =  r ))
> zM <- cbind(Re=Re(zN), Im=Im(zN), match = match(zN, zN))
> rownames(zM) <- format(zN)
> zM ##--> many "NA's" (= 1) and the four non-NA's (3 different ones, at 7,9,10)
          Re  Im match
      NA  NA   1     1
      NA  NA  NA     1
      NA  NA NaN     1
      NA   1  NA     1
      NA  NA  NA     1
      NA NaN  NA     1
  1+NaNi   1 NaN     7
      NA  NA NaN     1
NaN+NaNi NaN NaN     9
NaN+  1i NaN   1    10
      NA NaN  NA     1
NaN+NaNi NaN NaN     9
> 
> length(zN) # 12
[1] 12
> unique(zN) # the "NA" and the 3 different non-NA NaN's
[1]       NA   1+NaNi NaN+NaNi NaN+  1i
> stopifnot(identical(unique(zN), zN[c(1, 7,9,10)]))
> 
> ## very strict equality would have 4 duplicates (of 12):
> symnum(outer(zN, zN, Vectorize(identical,c("x","y")),
+                      FALSE,FALSE,FALSE,FALSE))
                             
 [1,] | . . . . . . . . . . .
 [2,] . | . . | . . . . . . .
 [3,] . . | . . . . | . . . .
 [4,] . . . | . . . . . . . .
 [5,] . | . . | . . . . . . .
 [6,] . . . . . | . . . . | .
 [7,] . . . . . . | . . . . .
 [8,] . . | . . . . | . . . .
 [9,] . . . . . . . . | . . |
[10,] . . . . . . . . . | . .
[11,] . . . . . | . . . . | .
[12,] . . . . . . . . | . . |
> ## removing "(very strictly) duplicates",
> i <- c(5,8,11,12)  # we get 8 pairwise non-identicals :
> Ixy <- outer(zN[-i], zN[-i], Vectorize(identical,c("x","y")),
+                      FALSE,FALSE,FALSE,FALSE)
> stopifnot(identical(Ixy, diag(8) == 1))
> 
> 
> 
> cleanEx()
> nameEx("match.arg")
> ### * match.arg
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: match.arg
> ### Title: Argument Verification Using Partial Matching
> ### Aliases: match.arg
> ### Keywords: programming
> 
> ### ** Examples
> 
> require(stats)
> ## Extends the example for 'switch'
> center <- function(x, type = c("mean", "median", "trimmed")) {
+   type <- match.arg(type)
+   switch(type,
+          mean = mean(x),
+          median = median(x),
+          trimmed = mean(x, trim = .1))
+ }
> x <- rcauchy(10)
> center(x, "t")       # Works
[1] -0.3632328
> center(x, "med")     # Works
[1] -0.236111
> try(center(x, "m"))  # Error
Error in match.arg(type) : 
  'arg' should be one of “mean”, “median”, “trimmed”
> stopifnot(identical(center(x),       center(x, "mean")),
+           identical(center(x, NULL), center(x, "mean")) )
> 
> ## Allowing more than one match:
> match.arg(c("gauss", "rect", "ep"),
+           c("gaussian", "epanechnikov", "rectangular", "triangular"),
+           several.ok = TRUE)
[1] "gaussian"     "rectangular"  "epanechnikov"
> 
> 
> 
> cleanEx()
> nameEx("match.call")
> ### * match.call
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: match.call
> ### Title: Argument Matching
> ### Aliases: match.call
> ### Keywords: programming
> 
> ### ** Examples
> 
> match.call(get, call("get", "abc", i = FALSE, p = 3))
get(x = "abc", pos = 3, inherits = FALSE)
> ## -> get(x = "abc", pos = 3, inherits = FALSE)
> fun <- function(x, lower = 0, upper = 1) {
+   structure((x - lower) / (upper - lower), CALL = match.call())
+ }
> fun(4 * atan(1), u = pi)
[1] 1
attr(,"CALL")
fun(x = 4 * atan(1), upper = pi)
> 
> 
> 
> cleanEx()
> nameEx("match.fun")
> ### * match.fun
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: match.fun
> ### Title: Extract a Function Specified by Name
> ### Aliases: match.fun
> ### Keywords: programming
> 
> ### ** Examples
> 
> # Same as get("*"):
> match.fun("*")
function (e1, e2)  .Primitive("*")
> # Overwrite outer with a vector
> outer <- 1:5
> try(match.fun(outer, descend = FALSE)) #-> Error:  not a function
Error in match.fun(outer, descend = FALSE) : 
  c("found non-function '1'", "found non-function '2'", "found non-function '3'", "found non-function '4'", "found non-function '5'")
> match.fun(outer) # finds it anyway
function (X, Y, FUN = "*", ...) 
{
    if (is.array(X)) {
        dX <- dim(X)
        nx <- dimnames(X)
        no.nx <- is.null(nx)
    }
    else {
        dX <- length(X)
        no.nx <- is.null(names(X))
        if (!no.nx) 
            nx <- list(names(X))
    }
    if (is.array(Y)) {
        dY <- dim(Y)
        ny <- dimnames(Y)
        no.ny <- is.null(ny)
    }
    else {
        dY <- length(Y)
        no.ny <- is.null(names(Y))
        if (!no.ny) 
            ny <- list(names(Y))
    }
    robj <- if (is.character(FUN) && FUN == "*") {
        if (!missing(...)) 
            stop("using ... with FUN = \"*\" is an error")
        tcrossprod(as.vector(X), as.vector(Y))
    }
    else {
        FUN <- match.fun(FUN)
        Y <- rep(Y, rep.int(length(X), length(Y)))
        if (length(X)) 
            X <- rep(X, times = ceiling(length(Y)/length(X)))
        FUN(X, Y, ...)
    }
    dim(robj) <- c(dX, dY)
    if (!(no.nx && no.ny)) {
        if (no.nx) 
            nx <- vector("list", length(dX))
        else if (no.ny) 
            ny <- vector("list", length(dY))
        dimnames(robj) <- c(nx, ny)
    }
    robj
}
<bytecode: 0x55b7544dc030>
<environment: namespace:base>
> is.function(match.fun("outer")) # as well
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("matmult")
> ### * matmult
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: matmult
> ### Title: Matrix Multiplication
> ### Aliases: %*% matmult
> ### Keywords: array arith
> 
> ### ** Examples
> 
> x <- 1:4
> (z <- x %*% x)    # scalar ("inner") product (1 x 1 matrix)
     [,1]
[1,]   30
> drop(z)             # as scalar
[1] 30
> 
> y <- diag(x)
> z <- matrix(1:12, ncol = 3, nrow = 4)
> y %*% z
     [,1] [,2] [,3]
[1,]    1    5    9
[2,]    4   12   20
[3,]    9   21   33
[4,]   16   32   48
> y %*% x
     [,1]
[1,]    1
[2,]    4
[3,]    9
[4,]   16
> x %*% z
     [,1] [,2] [,3]
[1,]   30   70  110
> 
> 
> 
> cleanEx()
> nameEx("matrix")
> ### * matrix
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: matrix
> ### Title: Matrices
> ### Aliases: matrix as.matrix as.matrix.default as.matrix.data.frame
> ###   is.matrix
> ### Keywords: array algebra
> 
> ### ** Examples
> 
> is.matrix(as.matrix(1:10))
[1] TRUE
> !is.matrix(warpbreaks)  # data.frame, NOT matrix!
[1] TRUE
> warpbreaks[1:10,]
   breaks wool tension
1      26    A       L
2      30    A       L
3      54    A       L
4      25    A       L
5      70    A       L
6      52    A       L
7      51    A       L
8      26    A       L
9      67    A       L
10     18    A       M
> as.matrix(warpbreaks[1:10,])  # using as.matrix.data.frame(.) method
   breaks wool tension
1  "26"   "A"  "L"    
2  "30"   "A"  "L"    
3  "54"   "A"  "L"    
4  "25"   "A"  "L"    
5  "70"   "A"  "L"    
6  "52"   "A"  "L"    
7  "51"   "A"  "L"    
8  "26"   "A"  "L"    
9  "67"   "A"  "L"    
10 "18"   "A"  "M"    
> 
> ## Example of setting row and column names
> mdat <- matrix(c(1,2,3, 11,12,13), nrow = 2, ncol = 3, byrow = TRUE,
+                dimnames = list(c("row1", "row2"),
+                                c("C.1", "C.2", "C.3")))
> mdat
     C.1 C.2 C.3
row1   1   2   3
row2  11  12  13
> 
> 
> 
> cleanEx()
> nameEx("maxCol")
> ### * maxCol
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: maxCol
> ### Title: Find Maximum Position in Matrix
> ### Aliases: max.col
> ### Keywords: utilities array
> 
> ### ** Examples
> 
> table(mc <- max.col(swiss))  # mostly "1" and "5", 5 x "2" and once "4"

 1  2  4  5 
23  5  1 18 
> swiss[unique(print(mr <- max.col(t(swiss)))) , ]  # 3 33 45 45 33 6
[1]  3 33 45 45 33  6
             Fertility Agriculture Examination Education Catholic
Franches-Mnt      92.5        39.7           5         5    93.40
Herens            77.3        89.7           5         2   100.00
V. De Geneve      35.0         1.2          37        53    42.34
Porrentruy        76.1        35.3           9         7    90.57
             Infant.Mortality
Franches-Mnt             20.2
Herens                   18.3
V. De Geneve             18.0
Porrentruy               26.6
> 
> set.seed(1)  # reproducible example:
> (mm <- rbind(x = round(2*stats::runif(12)),
+              y = round(5*stats::runif(12)),
+              z = round(8*stats::runif(12))))
  [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12]
x    1    1    1    2    0    2    2    1    1     0     0     0
y    3    2    4    2    4    5    2    4    5     1     3     1
z    2    3    0    3    7    3    4    5    4     1     7     5
> ## Not run: 
> ##D   [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12]
> ##D x    1    1    1    2    0    2    2    1    1     0     0     0
> ##D y    3    2    4    2    4    5    2    4    5     1     3     1
> ##D z    2    3    0    3    7    3    4    5    4     1     7     5
> ## End(Not run)
> ## column indices of all row maxima :
> utils::str(lapply(1:3, function(i) which(mm[i,] == max(mm[i,]))))
List of 3
 $ : int [1:3] 4 6 7
 $ : int [1:2] 6 9
 $ : int [1:2] 5 11
> max.col(mm) ; max.col(mm) # "random"
[1] 4 6 5
[1] 6 6 5
> max.col(mm, "first") # -> 4 6 5
[1] 4 6 5
> max.col(mm, "last")  # -> 7 9 11
[1]  7  9 11
> ## Don't show: 
> stopifnot(max.col(mm, "first") == c(4, 6, 5),
+           max.col(mm, "last")  == c(7, 9, 11))
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("mean")
> ### * mean
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mean
> ### Title: Arithmetic Mean
> ### Aliases: mean mean.default
> ### Keywords: univar
> 
> ### ** Examples
> 
> x <- c(0:10, 50)
> xm <- mean(x)
> c(xm, mean(x, trim = 0.10))
[1] 8.75 5.50
> 
> 
> 
> cleanEx()
> nameEx("memCompress")
> ### * memCompress
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: memCompress
> ### Title: In-memory Compression and Decompression
> ### Aliases: memCompress memDecompress
> ### Keywords: file connection
> 
> ### ** Examples
> 
> txt <- readLines(file.path(R.home("doc"), "COPYING"))
> sum(nchar(txt))
[1] 17671
> txt.gz <- memCompress(txt, "g")
> length(txt.gz)
[1] 6837
> txt2 <- strsplit(memDecompress(txt.gz, "g", asChar = TRUE), "\n")[[1]]
> stopifnot(identical(txt, txt2))
> txt.bz2 <- memCompress(txt, "b")
> length(txt.bz2)
[1] 6168
> ## can auto-detect bzip2:
> txt3 <- strsplit(memDecompress(txt.bz2, asChar = TRUE), "\n")[[1]]
> stopifnot(identical(txt, txt3))
> 
> ## xz compression is only worthwhile for large objects
> txt.xz <- memCompress(txt, "x")
> length(txt.xz)
[1] 6564
> txt3 <- strsplit(memDecompress(txt.xz, asChar = TRUE), "\n")[[1]]
> stopifnot(identical(txt, txt3))
> 
> 
> 
> cleanEx()
> nameEx("memory.profile")
> ### * memory.profile
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: memory.profile
> ### Title: Profile the Usage of Cons Cells
> ### Aliases: memory.profile
> ### Keywords: utilities
> 
> ### ** Examples
> 
> 
> cleanEx()
> nameEx("merge")
> ### * merge
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: merge
> ### Title: Merge Two Data Frames
> ### Aliases: merge merge.default merge.data.frame
> ### Keywords: array manip
> 
> ### ** Examples
> 
> authors <- data.frame(
+     ## I(*) : use character columns of names to get sensible sort order
+     surname = I(c("Tukey", "Venables", "Tierney", "Ripley", "McNeil")),
+     nationality = c("US", "Australia", "US", "UK", "Australia"),
+     deceased = c("yes", rep("no", 4)))
> authorN <- within(authors, { name <- surname; rm(surname) })
> books <- data.frame(
+     name = I(c("Tukey", "Venables", "Tierney",
+              "Ripley", "Ripley", "McNeil", "R Core")),
+     title = c("Exploratory Data Analysis",
+               "Modern Applied Statistics ...",
+               "LISP-STAT",
+               "Spatial Statistics", "Stochastic Simulation",
+               "Interactive Data Analysis",
+               "An Introduction to R"),
+     other.author = c(NA, "Ripley", NA, NA, NA, NA,
+                      "Venables & Smith"))
> 
> (m0 <- merge(authorN, books))
      name nationality deceased                         title other.author
1   McNeil   Australia       no     Interactive Data Analysis         <NA>
2   Ripley          UK       no            Spatial Statistics         <NA>
3   Ripley          UK       no         Stochastic Simulation         <NA>
4  Tierney          US       no                     LISP-STAT         <NA>
5    Tukey          US      yes     Exploratory Data Analysis         <NA>
6 Venables   Australia       no Modern Applied Statistics ...       Ripley
> (m1 <- merge(authors, books, by.x = "surname", by.y = "name"))
   surname nationality deceased                         title other.author
1   McNeil   Australia       no     Interactive Data Analysis         <NA>
2   Ripley          UK       no            Spatial Statistics         <NA>
3   Ripley          UK       no         Stochastic Simulation         <NA>
4  Tierney          US       no                     LISP-STAT         <NA>
5    Tukey          US      yes     Exploratory Data Analysis         <NA>
6 Venables   Australia       no Modern Applied Statistics ...       Ripley
>  m2 <- merge(books, authors, by.x = "name", by.y = "surname")
> stopifnot(exprs = {
+    identical(m0, m2[, names(m0)])
+    as.character(m1[, 1]) == as.character(m2[, 1])
+    all.equal(m1[, -1], m2[, -1][ names(m1)[-1] ])
+    identical(dim(merge(m1, m2, by = NULL)),
+              c(nrow(m1)*nrow(m2), ncol(m1)+ncol(m2)))
+ })
> 
> ## "R core" is missing from authors and appears only here :
> merge(authors, books, by.x = "surname", by.y = "name", all = TRUE)
   surname nationality deceased                         title     other.author
1   McNeil   Australia       no     Interactive Data Analysis             <NA>
2   R Core        <NA>     <NA>          An Introduction to R Venables & Smith
3   Ripley          UK       no            Spatial Statistics             <NA>
4   Ripley          UK       no         Stochastic Simulation             <NA>
5  Tierney          US       no                     LISP-STAT             <NA>
6    Tukey          US      yes     Exploratory Data Analysis             <NA>
7 Venables   Australia       no Modern Applied Statistics ...           Ripley
> 
> 
> ## example of using 'incomparables'
> x <- data.frame(k1 = c(NA,NA,3,4,5), k2 = c(1,NA,NA,4,5), data = 1:5)
> y <- data.frame(k1 = c(NA,2,NA,4,5), k2 = c(NA,NA,3,4,5), data = 1:5)
> merge(x, y, by = c("k1","k2")) # NA's match
  k1 k2 data.x data.y
1  4  4      4      4
2  5  5      5      5
3 NA NA      2      1
> merge(x, y, by = "k1") # NA's match, so 6 rows
  k1 k2.x data.x k2.y data.y
1  4    4      4    4      4
2  5    5      5    5      5
3 NA    1      1   NA      1
4 NA    1      1    3      3
5 NA   NA      2   NA      1
6 NA   NA      2    3      3
> merge(x, y, by = "k2", incomparables = NA) # 2 rows
  k2 k1.x data.x k1.y data.y
1  4    4      4    4      4
2  5    5      5    5      5
> 
> 
> 
> cleanEx()
> nameEx("message")
> ### * message
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: message
> ### Title: Diagnostic Messages
> ### Aliases: message suppressMessages packageStartupMessage
> ###   .packageStartupMessage suppressPackageStartupMessages .makeMessage
> ### Keywords: programming
> 
> ### ** Examples
> 
> message("ABC", "DEF")
ABCDEF
> suppressMessages(message("ABC"))
> 
> testit <- function() {
+   message("testing package startup messages")
+   packageStartupMessage("initializing ...", appendLF = FALSE)
+   Sys.sleep(1)
+   packageStartupMessage(" done")
+ }
> 
> testit()
testing package startup messages
initializing ... done
> suppressPackageStartupMessages(testit())
testing package startup messages
> suppressMessages(testit())
> 
> 
> 
> cleanEx()
> nameEx("missing")
> ### * missing
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: missing
> ### Title: Does a Formal Argument have a Value?
> ### Aliases: missing
> ### Keywords: programming
> 
> ### ** Examples
> 
> myplot <- function(x, y) {
+                 if(missing(y)) {
+                         y <- x
+                         x <- 1:length(y)
+                 }
+                 plot(x, y)
+         }
> 
> 
> 
> cleanEx()
> nameEx("mode")
> ### * mode
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mode
> ### Title: The (Storage) Mode of an Object
> ### Aliases: mode mode<- storage.mode storage.mode<-
> ### Keywords: attribute
> 
> ### ** Examples
> 
> require(stats)
> 
> sapply(options(), mode)
            add.smooth             bitmapType                browser 
             "logical"            "character"            "character" 
     browserNLdisabled           CBoundsCheck           check.bounds 
             "logical"              "logical"              "logical" 
   citation.bibtex.max               continue              contrasts 
             "numeric"            "character"            "character" 
       defaultPackages               demo.ask         deparse.cutoff 
           "character"            "character"              "numeric" 
                device     device.ask.default                 digits 
            "function"              "logical"              "numeric" 
              dvipscmd                   echo                 editor 
           "character"              "logical"            "character" 
              encoding            example.ask            expressions 
           "character"            "character"              "numeric" 
     help.search.types  help.try.all.packages          HTTPUserAgent 
           "character"              "logical"            "character" 
         internet.info        keep.parse.data   keep.parse.data.pkgs 
             "numeric"              "logical"              "logical" 
           keep.source       keep.source.pkgs            locatorBell 
             "logical"              "logical"              "logical" 
                mailer                matprod              max.print 
           "character"            "character"              "numeric" 
         menu.graphics              na.action              nwarnings 
             "logical"            "character"              "numeric" 
                OutDec                  pager              papersize 
           "character"            "character"            "character" 
  PCRE_limit_recursion             PCRE_study           PCRE_use_JIT 
             "logical"              "logical"              "logical" 
             pdfviewer                pkgType               printcmd 
           "character"            "character"            "character" 
                prompt                  repos         rl_word_breaks 
           "character"            "character"            "character" 
                scipen      show.coef.Pvalues    show.error.messages 
             "numeric"              "logical"              "logical" 
     show.signif.stars         showErrorCalls                    str 
             "logical"              "logical"                 "list" 
   str.dendrogram.last       stringsAsFactors               texi2dvi 
           "character"              "logical"            "character" 
               timeout                 ts.eps            ts.S.compat 
             "numeric"              "numeric"              "logical" 
                 unzip         useFancyQuotes                verbose 
           "character"              "logical"              "logical" 
                  warn         warning.length warnPartialMatchDollar 
             "numeric"              "numeric"              "logical" 
                 width 
             "numeric" 
> 
> cex3 <- c("NULL", "1", "1:1", "1i", "list(1)", "data.frame(x = 1)",
+   "pairlist(pi)", "c", "lm", "formals(lm)[[1]]",  "formals(lm)[[2]]",
+   "y ~ x","expression((1))[[1]]", "(y ~ x)[[1]]",
+   "expression(x <- pi)[[1]][[1]]")
> lex3 <- sapply(cex3, function(x) eval(str2lang(x)))
> mex3 <- t(sapply(lex3,
+                  function(x) c(typeof(x), storage.mode(x), mode(x))))
> dimnames(mex3) <- list(cex3, c("typeof(.)","storage.mode(.)","mode(.)"))
> mex3
                              typeof(.)  storage.mode(.) mode(.)   
NULL                          "NULL"     "NULL"          "NULL"    
1                             "double"   "double"        "numeric" 
1:1                           "integer"  "integer"       "numeric" 
1i                            "complex"  "complex"       "complex" 
list(1)                       "list"     "list"          "list"    
data.frame(x = 1)             "list"     "list"          "list"    
pairlist(pi)                  "pairlist" "pairlist"      "pairlist"
c                             "builtin"  "function"      "function"
lm                            "closure"  "function"      "function"
formals(lm)[[1]]              "symbol"   "symbol"        "name"    
formals(lm)[[2]]              "symbol"   "symbol"        "name"    
y ~ x                         "language" "language"      "call"    
expression((1))[[1]]          "language" "language"      "("       
(y ~ x)[[1]]                  "symbol"   "symbol"        "name"    
expression(x <- pi)[[1]][[1]] "symbol"   "symbol"        "name"    
> 
> ## This also makes a local copy of 'pi':
> storage.mode(pi) <- "complex"
> storage.mode(pi)
[1] "complex"
> rm(pi)
> 
> 
> 
> cleanEx()
> nameEx("name")
> ### * name
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: name
> ### Title: Names and Symbols
> ### Aliases: name is.symbol as.symbol as.name is.name
> ### Keywords: programming attribute
> 
> ### ** Examples
> 
> an <- as.name("arrg")
> is.name(an) # TRUE
[1] TRUE
> mode(an)   # name
[1] "name"
> typeof(an) # symbol
[1] "symbol"
> 
> 
> 
> cleanEx()
> nameEx("names")
> ### * names
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: names
> ### Title: The Names of an Object
> ### Aliases: names names.default names<- names<-.default
> ### Keywords: attribute
> 
> ### ** Examples
> 
> # print the names attribute of the islands data set
> names(islands)
 [1] "Africa"           "Antarctica"       "Asia"             "Australia"       
 [5] "Axel Heiberg"     "Baffin"           "Banks"            "Borneo"          
 [9] "Britain"          "Celebes"          "Celon"            "Cuba"            
[13] "Devon"            "Ellesmere"        "Europe"           "Greenland"       
[17] "Hainan"           "Hispaniola"       "Hokkaido"         "Honshu"          
[21] "Iceland"          "Ireland"          "Java"             "Kyushu"          
[25] "Luzon"            "Madagascar"       "Melville"         "Mindanao"        
[29] "Moluccas"         "New Britain"      "New Guinea"       "New Zealand (N)" 
[33] "New Zealand (S)"  "Newfoundland"     "North America"    "Novaya Zemlya"   
[37] "Prince of Wales"  "Sakhalin"         "South America"    "Southampton"     
[41] "Spitsbergen"      "Sumatra"          "Taiwan"           "Tasmania"        
[45] "Tierra del Fuego" "Timor"            "Vancouver"        "Victoria"        
> 
> # remove the names attribute
> names(islands) <- NULL
> islands
 [1] 11506  5500 16988  2968    16   184    23   280    84    73    25    43
[13]    21    82  3745   840    13    30    30    89    40    33    49    14
[25]    42   227    16    36    29    15   306    44    58    43  9390    32
[37]    13    29  6795    16    15   183    14    26    19    13    12    82
> rm(islands) # remove the copy made
> 
> z <- list(a = 1, b = "c", c = 1:3)
> names(z)
[1] "a" "b" "c"
> # change just the name of the third element.
> names(z)[3] <- "c2"
> z
$a
[1] 1

$b
[1] "c"

$c2
[1] 1 2 3

> 
> z <- 1:3
> names(z)
NULL
> ## assign just one name
> names(z)[2] <- "b"
> z
<NA>    b <NA> 
   1    2    3 
> 
> ## Don't show: 
> ## "show" the equivalence claimed above:
>   for(e in c(baseenv(), globalenv()))
+   stopifnot(identical(names(e), ls(e, all.names=TRUE, sorted=FALSE)),
+             identical(names(e), names(as.list(e, all.names=TRUE))))
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("nargs")
> ### * nargs
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: nargs
> ### Title: The Number of Arguments to a Function
> ### Aliases: nargs
> ### Keywords: programming
> 
> ### ** Examples
> 
> tst <- function(a, b = 3, ...) {nargs()}
> tst() # 0
[1] 0
> tst(clicketyclack) # 1 (even non-existing)
[1] 1
> tst(c1, a2, rr3) # 3
[1] 3
> 
> foo <- function(x, y, z, w) {
+    cat("call was ", deparse(match.call()), "\n", sep = "")
+    nargs()
+ }
> foo()      # 0
call was foo()
[1] 0
> foo(, , 3) # 3
call was foo(z = 3)
[1] 3
> foo(z = 3) # 1, even though this is the same call
call was foo(z = 3)
[1] 1
> 
> nargs()  # not really meaningful
[1] NA
> 
> 
> 
> cleanEx()
> nameEx("nchar")
> ### * nchar
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: nchar
> ### Title: Count the Number of Characters (or Bytes or Width)
> ### Aliases: nchar nzchar
> ### Keywords: character
> 
> ### ** Examples
> 
> x <- c("asfef", "qwerty", "yuiop[", "b", "stuff.blah.yech")
> nchar(x)
[1]  5  6  6  1 15
> # 5  6  6  1 15
> 
> nchar(deparse(mean))
[1] 18 17
> # 18 17  <-- unless mean differs from base::mean
> 
> x[3] <- NA; x
[1] "asfef"           "qwerty"          NA                "b"              
[5] "stuff.blah.yech"
> nchar(x, keepNA= TRUE) #  5  6 NA  1 15
[1]  5  6 NA  1 15
> nchar(x, keepNA=FALSE) #  5  6  2  1 15
[1]  5  6  2  1 15
> stopifnot(identical(nchar(x     ), nchar(x, keepNA= TRUE)),
+           identical(nchar(x, "w"), nchar(x, keepNA=FALSE)),
+           identical(is.na(x), is.na(nchar(x))))
> 
> ##' nchar() for all three types :
> nchars <- function(x, ...)
+    vapply(c("chars", "bytes", "width"),
+           function(tp) nchar(x, tp, ...), integer(length(x)))
> 
> nchars("\u200b") # in R versions (>= 2015-09-xx):
chars bytes width 
    1     3     0 
> ## chars bytes width
> ##     1     3     0
> 
> data.frame(x, nchars(x)) ## all three types : same unless for NA
                x chars bytes width
1           asfef     5     5     5
2          qwerty     6     6     6
3            <NA>    NA    NA     2
4               b     1     1     1
5 stuff.blah.yech    15    15    15
> ## force the same by forcing 'keepNA':
> (ncT <- nchars(x, keepNA = TRUE)) ## .... NA NA NA ....
     chars bytes width
[1,]     5     5     5
[2,]     6     6     6
[3,]    NA    NA    NA
[4,]     1     1     1
[5,]    15    15    15
> (ncF <- nchars(x, keepNA = FALSE))## ....  2  2  2 ....
     chars bytes width
[1,]     5     5     5
[2,]     6     6     6
[3,]     2     2     2
[4,]     1     1     1
[5,]    15    15    15
> stopifnot(apply(ncT, 1, function(.) length(unique(.))) == 1,
+           apply(ncF, 1, function(.) length(unique(.))) == 1)
> 
> 
> 
> cleanEx()
> nameEx("nlevels")
> ### * nlevels
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: nlevels
> ### Title: The Number of Levels of a Factor
> ### Aliases: nlevels
> ### Keywords: category
> 
> ### ** Examples
> 
> nlevels(gl(3, 7)) # = 3
[1] 3
> 
> 
> 
> cleanEx()
> nameEx("noquote")
> ### * noquote
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: noquote
> ### Title: Class for 'no quote' Printing of Character Strings
> ### Aliases: noquote print.noquote as.matrix.noquote c.noquote [.noquote
> ### Keywords: print methods utilities
> 
> ### ** Examples
> 
> letters
 [1] "a" "b" "c" "d" "e" "f" "g" "h" "i" "j" "k" "l" "m" "n" "o" "p" "q" "r" "s"
[20] "t" "u" "v" "w" "x" "y" "z"
> nql <- noquote(letters)
> nql
 [1] a b c d e f g h i j k l m n o p q r s t u v w x y z
> nql[1:4] <- "oh"
> nql[1:12]
 [1] oh oh oh oh e  f  g  h  i  j  k  l 
> 
> cmp.logical <- function(log.v)
+ {
+   ## Purpose: compact printing of logicals
+   log.v <- as.logical(log.v)
+   noquote(if(length(log.v) == 0)"()" else c(".","|")[1 + log.v])
+ }
> cmp.logical(stats::runif(20) > 0.8)
 [1] . . . | . | | . . . . . . . . . . | . .
> 
> chmat <- as.matrix(format(stackloss)) # a "typical" character matrix
> ## noquote(*, right=TRUE)  so it prints exactly like a data frame
> chmat <- noquote(chmat, right = TRUE)
> chmat
   Air.Flow Water.Temp Acid.Conc. stack.loss
1        80         27         89         42
2        80         27         88         37
3        75         25         90         37
4        62         24         87         28
5        62         22         87         18
6        62         23         87         18
7        62         24         93         19
8        62         24         93         20
9        58         23         87         15
10       58         18         80         14
11       58         18         89         14
12       58         17         88         13
13       58         18         82         11
14       58         19         93         12
15       50         18         89          8
16       50         18         86          7
17       50         19         72          8
18       50         19         79          8
19       50         20         80          9
20       56         20         82         15
21       70         20         91         15
> ## Don't show: 
> stopifnot(identical(
+    capture.output(stackloss),
+    capture.output(chmat)))
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("norm")
> ### * norm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: norm
> ### Title: Compute the Norm of a Matrix
> ### Aliases: norm
> ### Keywords: math
> 
> ### ** Examples
> 
> (x1 <- cbind(1, 1:10))
      [,1] [,2]
 [1,]    1    1
 [2,]    1    2
 [3,]    1    3
 [4,]    1    4
 [5,]    1    5
 [6,]    1    6
 [7,]    1    7
 [8,]    1    8
 [9,]    1    9
[10,]    1   10
> norm(x1)
[1] 55
> norm(x1, "I")
[1] 11
> norm(x1, "M")
[1] 10
> stopifnot(all.equal(norm(x1, "F"),
+                     sqrt(sum(x1^2))))
> 
> hilbert <- function(n) { i <- 1:n; 1 / outer(i - 1, i, "+") }
> h9 <- hilbert(9)
> ## all 5 types of norm:
> (nTyp <- eval(formals(base::norm)$type))
[1] "O" "I" "F" "M" "2"
> sapply(nTyp, norm, x = h9)
       O        I        F        M        2 
2.828968 2.828968 1.755872 1.000000 1.725883 
> 
> 
> 
> cleanEx()
> nameEx("normalizePath")
> ### * normalizePath
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: normalizePath
> ### Title: Express File Paths in Canonical Form
> ### Aliases: normalizePath
> ### Keywords: utilities
> 
> ### ** Examples
> 
> 
> cleanEx()
> nameEx("notyet")
> ### * notyet
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: NotYet
> ### Title: Not Yet Implemented Functions and Unused Arguments
> ### Aliases: NotYetImplemented .NotYetImplemented NotYetUsed .NotYetUsed
> ### Keywords: documentation utilities
> 
> ### ** Examples
> 
> require(graphics)
> barplot(1:5, inside = TRUE) # 'inside' is not yet used
Warning: argument 'inside' is not used (yet)
> 
> 
> 
> cleanEx()
> nameEx("nrow")
> ### * nrow
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: nrow
> ### Title: The Number of Rows/Columns of an Array
> ### Aliases: nrow NROW ncol NCOL
> ### Keywords: array
> 
> ### ** Examples
> 
> ma <- matrix(1:12, 3, 4)
> nrow(ma)   # 3
[1] 3
> ncol(ma)   # 4
[1] 4
> 
> ncol(array(1:24, dim = 2:4)) # 3, the second dimension
[1] 3
> NCOL(1:12) # 1
[1] 1
> NROW(1:12) # 12
[1] 12
> 
> ## as.matrix() produces 1-column matrices from 0-length vectors,
> ## and so does cbind() :
> dim(as.matrix(numeric())) # 0 1
[1] 0 1
> dim(    cbind(numeric())) # ditto
[1] 0 1
> ## consequently, NCOL(.) gives 1, too :
> NCOL(numeric()) # 1 and hence
[1] 1
> NCOL(NULL)      # 1
[1] 1
> 
> 
> 
> cleanEx()
> nameEx("ns-dblcolon")
> ### * ns-dblcolon
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ns-dblcolon
> ### Title: Double Colon and Triple Colon Operators
> ### Aliases: :: :::
> ### Keywords: programming
> 
> ### ** Examples
> 
> base::log
function (x, base = exp(1))  .Primitive("log")
> base::"+"
function (e1, e2)  .Primitive("+")
> 
> ## Beware --  use ':::' at your own risk! (see "Details")
> stats:::coef.default
function (object, complete = TRUE, ...) 
{
    cf <- object$coefficients
    if (complete) 
        cf
    else cf[!is.na(cf)]
}
<bytecode: 0x55b754fe0660>
<environment: namespace:stats>
> 
> 
> 
> cleanEx()
> nameEx("ns-internal")
> ### * ns-internal
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ns-internals
> ### Title: Namespace Internals
> ### Aliases: asNamespace getNamespaceInfo .getNamespaceInfo importIntoEnv
> ###   isBaseNamespace isNamespace namespaceExport namespaceImport
> ###   namespaceImportClasses namespaceImportFrom namespaceImportMethods
> ###   packageHasNamespace parseNamespaceFile registerS3method
> ###   registerS3methods setNamespaceInfo .__S3MethodsTable__.
> ###   .mergeExportMethods .mergeImportMethods .knownS3Generics
> ###   loadingNamespaceInfo .getNamespace .getNamespaceInfo ..getNamespace
> ###   .S3_methods_table
> ### Keywords: internal
> 
> ### ** Examples
> 
> nsName <- "stats"
> (ns <- asNamespace(nsName)) # <environment: namespace:stats>
<environment: namespace:stats>
> 
> ## Inverse function of asNamespace() :
> environmentName(asNamespace("stats")) # "stats"
[1] "stats"
> environmentName(asNamespace("base"))  # "base"
[1] "base"
> getNamespaceInfo(ns, "spec")[["name"]] ## -> "stats"
[1] "stats"
> ## Don't show: 
> stopifnot(identical(nsName,
+                       getNamespaceInfo(ns, "spec")[["name"]]))
> ## End(Don't show)
> 
> ## Only for for the daring ones, trying to get into the bowels :
> 
> lsNamespaceInfo <- function(ns, ...) {
+     ns <- asNamespace(ns, base.OK = FALSE)
+     ls(..., envir = get(".__NAMESPACE__.", envir = ns, inherits = FALSE))
+ }
> allinfoNS <- function(ns) sapply(lsNamespaceInfo(ns), getNamespaceInfo, ns=ns)
> 
> utils::str(allinfoNS("stats"))
List of 9
 $ DLLs          :List of 1
  ..$ stats:List of 5
  .. ..$ name         : chr "stats"
  .. ..$ path         : chr "/usr/local/lib/R/library/stats/libs/stats.so"
  .. ..$ dynamicLookup: logi FALSE
  .. ..$ handle       :Class 'DLLHandle' <externalptr> 
  .. ..$ info         :Class 'DLLInfoReference' <externalptr> 
  .. ..- attr(*, "class")= chr "DLLInfo"
 $ dynlibs       : Named chr "stats"
  ..- attr(*, "names")= chr ""
 $ exports       :<environment: 0x55b7527bc620> 
 $ imports       :List of 4
  ..$ base     : logi TRUE
  ..$ graphics : Named chr [1:88] "assocplot" "title" "axis.Date" "points" ...
  .. ..- attr(*, "names")= chr [1:88] "assocplot" "title" "axis.Date" "points" ...
  ..$ grDevices: Named chr [1:12] "as.graphicsAnnot" "dev.cur" "dev.flush" "dev.hold" ...
  .. ..- attr(*, "names")= chr [1:12] "as.graphicsAnnot" "dev.cur" "dev.flush" "dev.hold" ...
  ..$ utils    : Named chr [1:4] "count.fields" "flush.console" "str" "tail"
  .. ..- attr(*, "names")= chr [1:4] "count.fields" "flush.console" "str" "tail"
 $ lazydata      :<environment: 0x55b7527bc9a0> 
  ..- attr(*, "name")= chr "lazydata:stats"
 $ nativeRoutines:List of 1
  ..$ stats: Named chr [1:221] "loess_raw" "loess_dfit" "loess_dfitse" "loess_ifit" ...
  .. ..- attr(*, "names")= chr [1:221] "C_loess_raw" "C_loess_dfit" "C_loess_dfitse" "C_loess_ifit" ...
 $ path          : chr "/usr/local/lib/R/library/stats"
 $ S3methods     : chr [1:416, 1:4] "[" "[" "[" "[" ...
 $ spec          : Named chr [1:2] "stats" "4.0.3"
  ..- attr(*, "names")= chr [1:2] "name" "version"
> utils::str(allinfoNS("stats4"))
List of 8
 $ dynlibs       : chr(0) 
 $ exports       :<environment: 0x55b758836a30> 
 $ imports       :List of 6
  ..$ base     : logi TRUE
  ..$ grDevices: Named chr [1:2] "dev.flush" "dev.hold"
  .. ..- attr(*, "names")= chr [1:2] "dev.flush" "dev.hold"
  ..$ graphics : Named chr [1:3] "abline" "lines" "par"
  .. ..- attr(*, "names")= chr [1:3] "abline" "lines" "par"
  ..$ methods  : Named chr [1:3] "new" "show" "slotNames"
  .. ..- attr(*, "names")= chr [1:3] "new" "show" "slotNames"
  ..$ stats    : Named chr [1:7] "approx" "optim" "pchisq" "predict" ...
  .. ..- attr(*, "names")= chr [1:7] "approx" "optim" "pchisq" "predict" ...
  ..$ stats    : Named chr [1:10] "AIC" "BIC" "coef" "confint" ...
  .. ..- attr(*, "names")= chr [1:10] "AIC" "BIC" "coef" "confint" ...
 $ lazydata      :<environment: 0x55b758837d10> 
  ..- attr(*, "name")= chr "lazydata:stats4"
 $ nativeRoutines: list()
 $ path          : chr "/usr/local/lib/R/library/stats4"
 $ S3methods     : chr[0 , 1:4] 
 $ spec          : Named chr [1:2] "stats4" "4.0.3"
  ..- attr(*, "names")= chr [1:2] "name" "version"
> 
> 
> 
> cleanEx()
> nameEx("ns-load")
> ### * ns-load
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ns-load
> ### Title: Loading and Unloading Name Spaces
> ### Aliases: attachNamespace loadNamespace requireNamespace
> ###   loadedNamespaces unloadNamespace isNamespaceLoaded
> ### Keywords: data utilities
> 
> ### ** Examples
> 
>  (lns <- loadedNamespaces())
 [1] "compiler"  "graphics"  "tools"     "utils"     "grDevices" "stats"    
 [7] "datasets"  "splines"   "methods"   "stats4"    "base"     
>  statL <- isNamespaceLoaded("stats")
>  stopifnot( identical(statL, "stats" %in% lns) )
> 
>  ## The string "foo" and the symbol 'foo' can be used interchangably here:
>  stopifnot( identical(isNamespaceLoaded(  "foo"   ), FALSE),
+             identical(isNamespaceLoaded(quote(foo)), FALSE),
+             identical(isNamespaceLoaded(quote(stats)), statL))
> 
> hasS <- isNamespaceLoaded("splines") # (to restore if needed)
> Sns <- asNamespace("splines") # loads it if not already
> stopifnot(   isNamespaceLoaded("splines"))
> unloadNamespace(Sns) # unloading the NS 'object'
> stopifnot( ! isNamespaceLoaded("splines"))
> if (hasS) loadNamespace("splines") # (restoring previous state)
<environment: namespace:splines>
> 
> 
> 
> cleanEx()
> nameEx("ns-topenv")
> ### * ns-topenv
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ns-topenv
> ### Title: Top Level Environment
> ### Aliases: topenv
> ### Keywords: programming
> 
> ### ** Examples
> 
> topenv(.GlobalEnv)
<environment: R_GlobalEnv>
> topenv(new.env()) # also global env
<environment: R_GlobalEnv>
> topenv(environment(ls))# namespace:base
<environment: namespace:base>
> topenv(environment(lm))# namespace:stats
<environment: namespace:stats>
> ## Don't show: 
> stopifnot(identical(.GlobalEnv,        topenv(new.env())),
+           identical(.GlobalEnv,        topenv(.GlobalEnv)),
+           identical(baseenv(),         topenv(baseenv())),
+           identical(.BaseNamespaceEnv, topenv(.BaseNamespaceEnv)),
+           identical(topenv(environment(ls)), asNamespace("base")),
+           identical(topenv(environment(lm)), asNamespace("stats")))
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("numeric")
> ### * numeric
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: numeric
> ### Title: Numeric Vectors
> ### Aliases: numeric as.numeric is.numeric is.numeric.Date
> ###   is.numeric.POSIXt
> ### Keywords: classes attribute
> 
> ### ** Examples
> 
> ## Conversion does trim whitespace; non-numeric strings give NA + warning
> as.numeric(c("-.1"," 2.7 ","B"))
Warning: NAs introduced by coercion
[1] -0.1  2.7   NA
> 
> ## Numeric values are sometimes accidentally converted to factors.
> ## Converting them back to numeric is trickier than you'd expect.
> f <- factor(5:10)
> as.numeric(f) # not what you might expect, probably not what you want
[1] 1 2 3 4 5 6
> ## what you typically meant and want:
> as.numeric(as.character(f))
[1]  5  6  7  8  9 10
> ## the same, considerably more efficient (for long vectors):
> as.numeric(levels(f))[f]
[1]  5  6  7  8  9 10
> 
> 
> 
> cleanEx()
> nameEx("numeric_version")
> ### * numeric_version
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: numeric_version
> ### Title: Numeric Versions
> ### Aliases: numeric_version as.numeric_version is.numeric_version
> ###   package_version is.package_version as.package_version
> ###   R_system_version getRversion [.numeric_version [<-.numeric_version
> ###   [[.numeric_version [[<-.numeric_version Ops.numeric_version
> ###   Summary.numeric_version anyNA.numeric_version
> ###   as.character.numeric_version as.data.frame.numeric_version
> ###   as.list.numeric_version c.numeric_version duplicated.numeric_version
> ###   format.numeric_version is.na.numeric_version is.na<-.numeric_version
> ###   print.numeric_version rep.numeric_version unique.numeric_version
> ###   xtfrm.numeric_version $.package_version .encode_numeric_version
> ###   .decode_numeric_version .make_numeric_version
> ### Keywords: utilities
> 
> ### ** Examples
> 
> x <- package_version(c("1.2-4", "1.2-3", "2.1"))
> x < "1.4-2.3"
[1]  TRUE  TRUE FALSE
> c(min(x), max(x))
[1] ‘1.2.3’ ‘2.1’  
> x[2, 2]
[1] ‘2’
> x$major
[1] 1 1 2
> x$minor
[1] 2 2 1
> 
> if(getRversion() <= "2.5.0") { ## work around missing feature
+   cat("Your version of R, ", as.character(getRversion()),
+       ", is outdated.\n",
+       "Now trying to work around that ...\n", sep = "")
+ }
> 
> x[[c(1, 3)]]  # '4' as a numeric vector, same as x[1, 3]
[1] ‘4’
> x[1, 3]      # 4 as an integer
[1] ‘4’
> x[[2, 3]] <- 0   # zero the patchlevel
> x[[c(2, 3)]] <- 0 # same
> x
[1] ‘1.2.4’ ‘1.2.0’ ‘2.1’  
> x[[3]] <- "2.2.3"; x
[1] ‘1.2.4’ ‘1.2.0’ ‘2.2.3’
> x <- c(x, package_version("0.0"))
> is.na(x)[4] <- TRUE
Warning in y[i] <- unclass(as.numeric_version(value)) :
  number of items to replace is not a multiple of replacement length
> stopifnot(identical(is.na(x), c(rep(FALSE,3), TRUE)),
+ 	  anyNA(x))
> 
> 
> 
> cleanEx()
> nameEx("octmode")
> ### * octmode
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: octmode
> ### Title: Display Numbers in Octal
> ### Aliases: as.octmode format.octmode print.octmode as.character.octmode
> ###   [.octmode !.octmode |.octmode &.octmode octmode
> ### Keywords: utilities print
> 
> ### ** Examples
> 
> (on <- as.octmode(c(16, 32, 127:129))) # "020" "040" "177" "200" "201"
[1] "020" "040" "177" "200" "201"
> unclass(on[3:4]) # subsetting
[1] 127 128
> 
> ## manipulate file modes
> fmode <- as.octmode("170")
> (fmode | "644") & "755"
[1] "754"
> 
> 
> cleanEx()
> nameEx("on.exit")
> ### * on.exit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: on.exit
> ### Title: Function Exit Code
> ### Aliases: on.exit
> ### Keywords: programming
> 
> ### ** Examples
> 
> require(graphics)
> 
> opar <- par(mai = c(1,1,1,1))
> on.exit(par(opar))
> ## Don't show: 
> par(opar)
> ## End(Don't show)
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("options")
> ### * options
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: options
> ### Title: Options Settings
> ### Aliases: options .Options getOption option MC_CORES R_C_BOUNDS_CHECK
> ###   R_DEFAULT_DEVICE R_KEEP_PKG_SOURCE R_INTERACTIVE_DEVICE
> ### Keywords: environment error print
> 
> ### ** Examples
> 
> op <- options(); utils::str(op) # op is a named list
List of 67
 $ add.smooth            : logi TRUE
 $ bitmapType            : chr "cairo"
 $ browser               : chr "xdg-open"
 $ browserNLdisabled     : logi FALSE
 $ CBoundsCheck          : logi FALSE
 $ check.bounds          : logi FALSE
 $ citation.bibtex.max   : int 1
 $ continue              : chr "+ "
 $ contrasts             : Named chr [1:2] "contr.treatment" "contr.poly"
  ..- attr(*, "names")= chr [1:2] "unordered" "ordered"
 $ defaultPackages       : chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
 $ demo.ask              : chr "default"
 $ deparse.cutoff        : int 60
 $ device                :function (file = if (onefile) "Rplots.pdf" else "Rplot%03d.pdf", width, 
    height, onefile, family, title, fonts, version, paper, encoding, bg, 
    fg, pointsize, pagecentre, colormodel, useDingbats, useKerning, fillOddEven, 
    compress)  
 $ device.ask.default    : logi FALSE
 $ digits                : int 7
 $ dvipscmd              : chr "dvips"
 $ echo                  : logi TRUE
 $ editor                : chr "vi"
 $ encoding              : chr "native.enc"
 $ example.ask           : chr "default"
 $ expressions           : int 5000
 $ help.search.types     : chr [1:3] "vignette" "demo" "help"
 $ help.try.all.packages : logi FALSE
 $ HTTPUserAgent         : chr "R (4.0.3 x86_64-pc-linux-gnu x86_64 linux-gnu)"
 $ internet.info         : int 2
 $ keep.parse.data       : logi TRUE
 $ keep.parse.data.pkgs  : logi FALSE
 $ keep.source           : logi FALSE
 $ keep.source.pkgs      : logi FALSE
 $ locatorBell           : logi TRUE
 $ mailer                : chr "mailto"
 $ matprod               : chr "default"
 $ max.print             : int 99999
 $ menu.graphics         : logi TRUE
 $ na.action             : chr "na.omit"
 $ nwarnings             : int 50
 $ OutDec                : chr "."
 $ pager                 : chr "/usr/local/lib/R/bin/pager"
 $ papersize             : chr "letter"
 $ PCRE_limit_recursion  : logi NA
 $ PCRE_study            : logi FALSE
 $ PCRE_use_JIT          : logi TRUE
 $ pdfviewer             : chr "/usr/bin/xdg-open"
 $ pkgType               : chr "source"
 $ printcmd              : chr "/usr/bin/lpr"
 $ prompt                : chr "> "
 $ repos                 : Named chr "@CRAN@"
  ..- attr(*, "names")= chr "CRAN"
 $ rl_word_breaks        : chr " \t\n\"\\'`><=%;,|&{()}"
 $ scipen                : num 0
 $ show.coef.Pvalues     : logi TRUE
 $ show.error.messages   : logi TRUE
 $ show.signif.stars     : logi TRUE
 $ showErrorCalls        : logi TRUE
 $ str                   :List of 7
  ..$ strict.width     : chr "no"
  ..$ digits.d         : int 3
  ..$ vec.len          : int 4
  ..$ list.len         : int 99
  ..$ deparse.lines    : NULL
  ..$ drop.deparse.attr: logi TRUE
  ..$ formatNum        :function (x, ...)  
 $ str.dendrogram.last   : chr "`"
 $ stringsAsFactors      : logi FALSE
 $ texi2dvi              : chr "/usr/bin/texi2dvi"
 $ timeout               : int 60
 $ ts.eps                : num 1e-05
 $ ts.S.compat           : logi FALSE
 $ unzip                 : chr "/usr/bin/unzip"
 $ useFancyQuotes        : logi TRUE
 $ verbose               : logi FALSE
 $ warn                  : int 1
 $ warning.length        : int 1000
 $ warnPartialMatchDollar: logi FALSE
 $ width                 : int 80
> 
> getOption("width") == options()$width # the latter needs more memory
[1] TRUE
> options(digits = 15)
> pi
[1] 3.14159265358979
> 
> # set the editor, and save previous value
> old.o <- options(editor = "nedit")
> old.o
$editor
[1] "vi"

> 
> options(check.bounds = TRUE, warn = 1)
> x <- NULL; x[4] <- "yes" # gives a warning
Warning in x[4] <- "yes" :
  assignment outside vector/list limits (extending from 0 to 4)
> 
> options(digits = 5)
> print(1e5)
[1] 1e+05
> options(scipen = 3); print(1e5)
[1] 100000
> 
> options(op)     # reset (all) initial options
> options("digits")
$digits
[1] 7

> 
> ## Not run: 
> ##D ## set contrast handling to be like S
> ##D options(contrasts = c("contr.helmert", "contr.poly"))
> ## End(Not run)
> 
> ## Not run: 
> ##D ## on error, terminate the R session with error status 66
> ##D options(error = quote(q("no", status = 66, runLast = FALSE)))
> ##D stop("test it")
> ## End(Not run)
> 
> ## Not run: 
> ##D ## Set error actions for debugging:
> ##D ## enter browser on error, see ?recover:
> ##D options(error = recover)
> ##D ## allows to call debugger() afterwards, see ?debugger:
> ##D options(error = dump.frames)
> ##D ## A possible setting for non-interactive sessions
> ##D options(error = quote({dump.frames(to.file = TRUE); q()}))
> ## End(Not run)
> 
>   # Compare the two ways to get an option and use it
>   # acconting for the possibility it might not be set.
> if(as.logical(getOption("performCleanp", TRUE)))
+    cat("do cleanup\n")
do cleanup
> 
> ## Not run: 
> ##D   # a clumsier way of expressing the above w/o the default.
> ##D tmp <- getOption("performCleanup")
> ##D if(is.null(tmp))
> ##D   tmp <- TRUE
> ##D if(tmp)
> ##D    cat("do cleanup\n")
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("order")
> ### * order
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: order
> ### Title: Ordering Permutation
> ### Aliases: order sort.list
> ### Keywords: univar manip
> 
> ### ** Examples
> 
> require(stats)
> 
> (ii <- order(x <- c(1,1,3:1,1:4,3), y <- c(9,9:1), z <- c(2,1:9)))
 [1]  6  5  2  1  7  4 10  8  3  9
> ## 6  5  2  1  7  4 10  8  3  9
> rbind(x, y, z)[,ii] # shows the reordering (ties via 2nd & 3rd arg)
  [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
x    1    1    1    1    2    2    3    3    3     4
y    5    6    9    9    4    7    1    3    8     2
z    5    4    1    2    6    3    9    7    2     8
> 
> ## Suppose we wanted descending order on y.
> ## A simple solution for numeric 'y' is
> rbind(x, y, z)[, order(x, -y, z)]
  [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
x    1    1    1    1    2    2    3    3    3     4
y    9    9    6    5    7    4    8    3    1     2
z    1    2    4    5    3    6    2    7    9     8
> ## More generally we can make use of xtfrm
> cy <- as.character(y)
> rbind(x, y, z)[, order(x, -xtfrm(cy), z)]
  [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
x    1    1    1    1    2    2    3    3    3     4
y    9    9    6    5    7    4    8    3    1     2
z    1    2    4    5    3    6    2    7    9     8
> ## The radix sort supports multiple 'decreasing' values:
> rbind(x, y, z)[, order(x, cy, z, decreasing = c(FALSE, TRUE, FALSE),
+                        method="radix")]
  [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
x    1    1    1    1    2    2    3    3    3     4
y    9    9    6    5    7    4    8    3    1     2
z    1    2    4    5    3    6    2    7    9     8
> 
> ## Sorting data frames:
> dd <- transform(data.frame(x, y, z),
+                 z = factor(z, labels = LETTERS[9:1]))
> ## Either as above {for factor 'z' : using internal coding}:
> dd[ order(x, -y, z), ]
   x y z
2  1 9 I
1  1 9 H
5  1 6 F
6  1 5 E
4  2 7 G
7  2 4 D
3  3 8 H
8  3 3 C
10 3 1 A
9  4 2 B
> ## or along 1st column, ties along 2nd, ... *arbitrary* no.{columns}:
> dd[ do.call(order, dd), ]
   x y z
6  1 5 E
5  1 6 F
2  1 9 I
1  1 9 H
7  2 4 D
4  2 7 G
10 3 1 A
8  3 3 C
3  3 8 H
9  4 2 B
> 
> set.seed(1)  # reproducible example:
> d4 <- data.frame(x = round(   rnorm(100)), y = round(10*runif(100)),
+                  z = round( 8*rnorm(100)), u = round(50*runif(100)))
> (d4s <- d4[ do.call(order, d4), ])
     x  y   z  u
67  -2  1  -2 12
84  -2  4   5  2
24  -2  5  -1  6
14  -2  9   7 36
81  -1  0  -8 17
28  -1  0  17 38
97  -1  1  -4 24
98  -1  1  -2 25
99  -1  1  -1 19
72  -1  1   0 21
46  -1  2  -8  6
74  -1  2  -3  5
91  -1  2   6 28
75  -1  3  -9 41
1   -1  3   4 28
45  -1  4 -10 10
35  -1  4   4  6
6   -1  5  -9 48
3   -1  5  -3 33
58  -1  5   4  2
54  -1  6  -3 45
65  -1  7   8 45
80  -1  8   2 37
13  -1  8   8  0
52  -1  9  14 29
71   0  1 -14  8
12   0  1  -2 23
86   0  1  -1 21
32   0  1   8  1
89   0  1   9 48
78   0  2 -13 20
5    0  2 -12 24
88   0  2  -9 26
2    0  2   0 34
90   0  2   0 35
57   0  2   5  5
66   0  2  12 35
76   0  2  14 26
77   0  3  -3 33
41   0  3  -1 20
62   0  3   3  7
23   0  3   4 17
27   0  3   6 40
16   0  3  18  9
33   0  4   2 17
29   0  4   8 48
47   0  4  12 50
82   0  5 -23 47
26   0  5   0 46
79   0  5   2 42
49   0  5   3 28
53   0  5  13  1
34   0  6 -12 14
38   0  6  -6 17
17   0  6  -2 32
42   0  6   3 48
69   0  6   5 14
7    0  6   8 20
36   0  7  -1  2
37   0  7  12 19
10   0  7  15 27
64   0  8 -11 37
51   0  8   3 44
60   0  9   4 41
100  0  9   8 23
30   0  9  10 50
85   1  0   0 30
48   1  1  -8 19
8    1  1  -5 42
44   1  1   7 16
92   1  1   8 12
22   1  2   1 35
9    1  3 -11 38
31   1  3 -10 30
94   1  3  -7 33
63   1  3  -3 17
20   1  3   2 32
87   1  3   4  4
21   1  3  18 41
73   1  4  -5 13
39   1  4  -3  9
59   1  4   0 41
55   1  5 -18 39
40   1  5  -7 31
96   1  7 -16 32
68   1  8 -10 32
15   1  8  -5 36
43   1  9  -6 33
83   1  9  -5 32
25   1  9  -3 19
50   1  9  -3 37
18   1 10 -11 27
19   1 10  -1 17
93   1 10   2 39
56   2  1  20 19
70   2  2   0 48
4    2  3  -7 33
61   2  5  -1 33
95   2  5   9 42
11   2 10   3 44
> (i <- which(diff(d4s[, 3]) == 0))
[1] 34 90
> #   in 2 places, needed 3 cols to break ties:
> d4s[ rbind(i, i+1), ]
   x y  z  u
2  0 2  0 34
90 0 2  0 35
25 1 9 -3 19
50 1 9 -3 37
> 
> ## rearrange matched vectors so that the first is in ascending order
> x <- c(5:1, 6:8, 12:9)
> y <- (x - 5)^2
> o <- order(x)
> rbind(x[o], y[o])
     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12]
[1,]    1    2    3    4    5    6    7    8    9    10    11    12
[2,]   16    9    4    1    0    1    4    9   16    25    36    49
> 
> ## tests of na.last
> a <- c(4, 3, 2, NA, 1)
> b <- c(4, NA, 2, 7, 1)
> z <- cbind(a, b)
> (o <- order(a, b)); z[o, ]
[1] 5 3 2 1 4
      a  b
[1,]  1  1
[2,]  2  2
[3,]  3 NA
[4,]  4  4
[5,] NA  7
> (o <- order(a, b, na.last = FALSE)); z[o, ]
[1] 4 5 3 2 1
      a  b
[1,] NA  7
[2,]  1  1
[3,]  2  2
[4,]  3 NA
[5,]  4  4
> (o <- order(a, b, na.last = NA)); z[o, ]
[1] 5 3 1
     a b
[1,] 1 1
[2,] 2 2
[3,] 4 4
> 
> 
> 
> cleanEx()
> nameEx("outer")
> ### * outer
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: outer
> ### Title: Outer Product of Arrays
> ### Aliases: outer %o%
> ### Keywords: array
> 
> ### ** Examples
> 
> x <- 1:9; names(x) <- x
> # Multiplication & Power Tables
> x %o% x
  1  2  3  4  5  6  7  8  9
1 1  2  3  4  5  6  7  8  9
2 2  4  6  8 10 12 14 16 18
3 3  6  9 12 15 18 21 24 27
4 4  8 12 16 20 24 28 32 36
5 5 10 15 20 25 30 35 40 45
6 6 12 18 24 30 36 42 48 54
7 7 14 21 28 35 42 49 56 63
8 8 16 24 32 40 48 56 64 72
9 9 18 27 36 45 54 63 72 81
> y <- 2:8; names(y) <- paste(y,":", sep = "")
> outer(y, x, "^")
   1  2   3    4     5      6       7        8         9
2: 2  4   8   16    32     64     128      256       512
3: 3  9  27   81   243    729    2187     6561     19683
4: 4 16  64  256  1024   4096   16384    65536    262144
5: 5 25 125  625  3125  15625   78125   390625   1953125
6: 6 36 216 1296  7776  46656  279936  1679616  10077696
7: 7 49 343 2401 16807 117649  823543  5764801  40353607
8: 8 64 512 4096 32768 262144 2097152 16777216 134217728
> 
> outer(month.abb, 1999:2003, FUN = "paste")
      [,1]       [,2]       [,3]       [,4]       [,5]      
 [1,] "Jan 1999" "Jan 2000" "Jan 2001" "Jan 2002" "Jan 2003"
 [2,] "Feb 1999" "Feb 2000" "Feb 2001" "Feb 2002" "Feb 2003"
 [3,] "Mar 1999" "Mar 2000" "Mar 2001" "Mar 2002" "Mar 2003"
 [4,] "Apr 1999" "Apr 2000" "Apr 2001" "Apr 2002" "Apr 2003"
 [5,] "May 1999" "May 2000" "May 2001" "May 2002" "May 2003"
 [6,] "Jun 1999" "Jun 2000" "Jun 2001" "Jun 2002" "Jun 2003"
 [7,] "Jul 1999" "Jul 2000" "Jul 2001" "Jul 2002" "Jul 2003"
 [8,] "Aug 1999" "Aug 2000" "Aug 2001" "Aug 2002" "Aug 2003"
 [9,] "Sep 1999" "Sep 2000" "Sep 2001" "Sep 2002" "Sep 2003"
[10,] "Oct 1999" "Oct 2000" "Oct 2001" "Oct 2002" "Oct 2003"
[11,] "Nov 1999" "Nov 2000" "Nov 2001" "Nov 2002" "Nov 2003"
[12,] "Dec 1999" "Dec 2000" "Dec 2001" "Dec 2002" "Dec 2003"
> 
> ## three way multiplication table:
> x %o% x %o% y[1:3]
, , 2:

   1  2  3  4  5   6   7   8   9
1  2  4  6  8 10  12  14  16  18
2  4  8 12 16 20  24  28  32  36
3  6 12 18 24 30  36  42  48  54
4  8 16 24 32 40  48  56  64  72
5 10 20 30 40 50  60  70  80  90
6 12 24 36 48 60  72  84  96 108
7 14 28 42 56 70  84  98 112 126
8 16 32 48 64 80  96 112 128 144
9 18 36 54 72 90 108 126 144 162

, , 3:

   1  2  3   4   5   6   7   8   9
1  3  6  9  12  15  18  21  24  27
2  6 12 18  24  30  36  42  48  54
3  9 18 27  36  45  54  63  72  81
4 12 24 36  48  60  72  84  96 108
5 15 30 45  60  75  90 105 120 135
6 18 36 54  72  90 108 126 144 162
7 21 42 63  84 105 126 147 168 189
8 24 48 72  96 120 144 168 192 216
9 27 54 81 108 135 162 189 216 243

, , 4:

   1  2   3   4   5   6   7   8   9
1  4  8  12  16  20  24  28  32  36
2  8 16  24  32  40  48  56  64  72
3 12 24  36  48  60  72  84  96 108
4 16 32  48  64  80  96 112 128 144
5 20 40  60  80 100 120 140 160 180
6 24 48  72  96 120 144 168 192 216
7 28 56  84 112 140 168 196 224 252
8 32 64  96 128 160 192 224 256 288
9 36 72 108 144 180 216 252 288 324

> 
> 
> 
> cleanEx()
> nameEx("parse")
> ### * parse
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: parse
> ### Title: Parse R Expressions
> ### Aliases: parse str2lang str2expression
> ### Keywords: file programming connection
> 
> ### ** Examples
> 
> fil <- tempfile(fileext = ".Rdmped")
> cat("x <- c(1, 4)\n  x ^ 3 -10 ; outer(1:7, 5:9)\n", file = fil)
> # parse 3 statements from our temp file
> parse(file = fil, n = 3)
expression(x <- c(1, 4), x^3 - 10, outer(1:7, 5:9))
> unlink(fil)
> 
> ## str2lang(<string>)  || str2expression(<character>) :
> stopifnot(exprs = {
+   identical( str2lang("x[3] <- 1+4"), quote(x[3] <- 1+4))
+   identical( str2lang("log(y)"),      quote(log(y)) )
+   identical( str2lang("abc"   ),      quote(abc) -> qa)
+   is.symbol(qa) & !is.call(qa)           # a symbol/name, not a call
+   identical( str2lang("1.375" ), 1.375)  # just a number, not a call
+ })
> 
> # A partial parse with a syntax error
> txt <- "
+ x <- 1
+ an error
+ "
> sf <- srcfile("txt")
> try(parse(text = txt, srcfile = sf))
Error in parse(text = txt, srcfile = sf) : txt:3:4: unexpected symbol
2: x <- 1
3: an error
      ^
> getParseData(sf)
   line1 col1 line2 col2 id parent       token terminal  text
9      2    1     2    6  9      0        expr    FALSE      
3      2    1     2    1  3      5      SYMBOL     TRUE     x
5      2    1     2    1  5      9        expr    FALSE      
4      2    3     2    4  4      9 LEFT_ASSIGN     TRUE    <-
6      2    6     2    6  6      7   NUM_CONST     TRUE     1
7      2    6     2    6  7      9        expr    FALSE      
12     3    1     3    2 12     14      SYMBOL     TRUE    an
14     3    1     3    2 14      0        expr    FALSE      
13     3    4     3    8 13      0      SYMBOL     TRUE error
> 
> 
> 
> cleanEx()
> nameEx("paste")
> ### * paste
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: paste
> ### Title: Concatenate Strings
> ### Aliases: paste paste0
> ### Keywords: character
> 
> ### ** Examples
> 
> ## When passing a single vector, paste0 and paste work like as.character.
> paste0(1:12)
 [1] "1"  "2"  "3"  "4"  "5"  "6"  "7"  "8"  "9"  "10" "11" "12"
> paste(1:12)        # same
 [1] "1"  "2"  "3"  "4"  "5"  "6"  "7"  "8"  "9"  "10" "11" "12"
> as.character(1:12) # same
 [1] "1"  "2"  "3"  "4"  "5"  "6"  "7"  "8"  "9"  "10" "11" "12"
> 
> ## If you pass several vectors to paste0, they are concatenated in a
> ## vectorized way.
> (nth <- paste0(1:12, c("st", "nd", "rd", rep("th", 9))))
 [1] "1st"  "2nd"  "3rd"  "4th"  "5th"  "6th"  "7th"  "8th"  "9th"  "10th"
[11] "11th" "12th"
> 
> ## paste works the same, but separates each input with a space.
> ## Notice that the recycling rules make every input as long as the longest input.
> paste(month.abb, "is the", nth, "month of the year.")
 [1] "Jan is the 1st month of the year."  "Feb is the 2nd month of the year." 
 [3] "Mar is the 3rd month of the year."  "Apr is the 4th month of the year." 
 [5] "May is the 5th month of the year."  "Jun is the 6th month of the year." 
 [7] "Jul is the 7th month of the year."  "Aug is the 8th month of the year." 
 [9] "Sep is the 9th month of the year."  "Oct is the 10th month of the year."
[11] "Nov is the 11th month of the year." "Dec is the 12th month of the year."
> paste(month.abb, letters)
 [1] "Jan a" "Feb b" "Mar c" "Apr d" "May e" "Jun f" "Jul g" "Aug h" "Sep i"
[10] "Oct j" "Nov k" "Dec l" "Jan m" "Feb n" "Mar o" "Apr p" "May q" "Jun r"
[19] "Jul s" "Aug t" "Sep u" "Oct v" "Nov w" "Dec x" "Jan y" "Feb z"
> 
> ## You can change the separator by passing a sep argument
> ## which can be multiple characters.
> paste(month.abb, "is the", nth, "month of the year.", sep = "_*_")
 [1] "Jan_*_is the_*_1st_*_month of the year." 
 [2] "Feb_*_is the_*_2nd_*_month of the year." 
 [3] "Mar_*_is the_*_3rd_*_month of the year." 
 [4] "Apr_*_is the_*_4th_*_month of the year." 
 [5] "May_*_is the_*_5th_*_month of the year." 
 [6] "Jun_*_is the_*_6th_*_month of the year." 
 [7] "Jul_*_is the_*_7th_*_month of the year." 
 [8] "Aug_*_is the_*_8th_*_month of the year." 
 [9] "Sep_*_is the_*_9th_*_month of the year." 
[10] "Oct_*_is the_*_10th_*_month of the year."
[11] "Nov_*_is the_*_11th_*_month of the year."
[12] "Dec_*_is the_*_12th_*_month of the year."
> 
> ## To collapse the output into a single string, pass a collapse argument.
> paste0(nth, collapse = ", ")
[1] "1st, 2nd, 3rd, 4th, 5th, 6th, 7th, 8th, 9th, 10th, 11th, 12th"
> 
> ## For inputs of length 1, use the sep argument rather than collapse
> paste("1st", "2nd", "3rd", collapse = ", ") # probably not what you wanted
[1] "1st 2nd 3rd"
> paste("1st", "2nd", "3rd", sep = ", ")
[1] "1st, 2nd, 3rd"
> 
> ## You can combine the sep and collapse arguments together.
> paste(month.abb, nth, sep = ": ", collapse = "; ")
[1] "Jan: 1st; Feb: 2nd; Mar: 3rd; Apr: 4th; May: 5th; Jun: 6th; Jul: 7th; Aug: 8th; Sep: 9th; Oct: 10th; Nov: 11th; Dec: 12th"
> 
> ## Using paste() in combination with strwrap() can be useful
> ## for dealing with long strings.
> (title <- paste(strwrap(
+     "Stopping distance of cars (ft) vs. speed (mph) from Ezekiel (1930)",
+     width = 30), collapse = "\n"))
[1] "Stopping distance of cars\n(ft) vs. speed (mph) from\nEzekiel (1930)"
> plot(dist ~ speed, cars, main = title)
> 
> ## 'recycle0 = TRUE' allows more vectorized behaviour, i.e. zero-length recycling :
> valid <- FALSE
> val <- pi
> paste("The value is", val[valid], "-- not so good!")
[1] "The value is  -- not so good!"
> paste("The value is", val[valid], "-- good: empty!", recycle0=TRUE) # -> character(0)
character(0)
> ## When  'collapse = <string>',  the result is a length-1 string :
> paste("foo", {}, "bar", collapse="|")                  # |-->  "foo  bar"
[1] "foo  bar"
> paste("foo", {}, "bar", collapse="|", recycle0 = TRUE) # |-->  ""
[1] ""
> ## all empty args
> paste(	  collapse="|")                  # |-->  ""  as do all these:
[1] ""
> paste(	  collapse="|", recycle0 = TRUE)
[1] ""
> paste({}, collapse="|")
[1] ""
> paste({}, collapse="|", recycle0 = TRUE)
[1] ""
> 
> 
> 
> cleanEx()
> nameEx("path.expand")
> ### * path.expand
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: path.expand
> ### Title: Expand File Paths
> ### Aliases: path.expand 'tilde expansion'
> ### Keywords: file
> 
> ### ** Examples
> 
> path.expand("~/foo")
[1] "/root/foo"
> 
> 
> 
> cleanEx()
> nameEx("pcre_config")
> ### * pcre_config
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pcre_config
> ### Title: Report Configuration Options for PCRE
> ### Aliases: pcre_config
> 
> ### ** Examples
> 
> pcre_config()
             UTF-8 Unicode properties                JIT              stack 
              TRUE               TRUE               TRUE              FALSE 
> 
> 
> 
> cleanEx()
> nameEx("plot")
> ### * plot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot
> ### Title: Generic X-Y Plotting
> ### Aliases: plot
> ### Keywords: hplot
> 
> ### ** Examples
> 
> require(stats) # for lowess, rpois, rnorm
> require(graphics) # for plot methods
> plot(cars)
> lines(lowess(cars))
> 
> plot(sin, -pi, 2*pi) # see ?plot.function
> 
> ## Discrete Distribution Plot:
> plot(table(rpois(100, 5)), type = "h", col = "red", lwd = 10,
+      main = "rpois(100, lambda = 5)")
> 
> ## Simple quantiles/ECDF, see ecdf() {library(stats)} for a better one:
> plot(x <- sort(rnorm(47)), type = "s", main = "plot(x, type = \"s\")")
> points(x, cex = .5, col = "dark red")
> 
> 
> 
> cleanEx()
> nameEx("pmatch")
> ### * pmatch
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pmatch
> ### Title: Partial String Matching
> ### Aliases: pmatch
> ### Keywords: character
> 
> ### ** Examples
> 
> pmatch("", "")                             # returns NA
[1] NA
> pmatch("m",   c("mean", "median", "mode")) # returns NA
[1] NA
> pmatch("med", c("mean", "median", "mode")) # returns 2
[1] 2
> 
> pmatch(c("", "ab", "ab"), c("abc", "ab"), dup = FALSE)
[1] NA  2  1
> pmatch(c("", "ab", "ab"), c("abc", "ab"), dup = TRUE)
[1] NA  2  2
> ## compare
> charmatch(c("", "ab", "ab"), c("abc", "ab"))
[1] 0 2 2
> 
> 
> 
> cleanEx()
> nameEx("polyroot")
> ### * polyroot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: polyroot
> ### Title: Find Zeros of a Real or Complex Polynomial
> ### Aliases: polyroot
> ### Keywords: math
> 
> ### ** Examples
> 
> polyroot(c(1, 2, 1))
[1] -1-0i -1+0i
> round(polyroot(choose(8, 0:8)), 11) # guess what!
[1] -1+0i -1+0i -1+0i -1+0i -1+0i -1+0i -1+0i -1+0i
> for (n1 in 1:4) print(polyroot(1:n1), digits = 4)
complex(0)
[1] -0.5+0i
[1] -0.3333+0.4714i -0.3333-0.4714i
[1] -0.0721+0.6383i -0.6058-0.0000i -0.0721-0.6383i
> polyroot(c(1, 2, 1, 0, 0)) # same as the first
[1] -1-0i -1+0i
> 
> 
> 
> cleanEx()
> nameEx("pos.to.env")
> ### * pos.to.env
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pos.to.env
> ### Title: Convert Positions in the Search Path to Environments
> ### Aliases: pos.to.env
> ### Keywords: utilities
> 
> ### ** Examples
> 
> pos.to.env(1) # R_GlobalEnv
<environment: R_GlobalEnv>
> # the next returns the base environment
> pos.to.env(length(search()))
<environment: base>
> 
> 
> 
> cleanEx()
> nameEx("pretty")
> ### * pretty
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pretty
> ### Title: Pretty Breakpoints
> ### Aliases: pretty pretty.default
> ### Keywords: dplot
> 
> ### ** Examples
> 
> pretty(1:15)          # 0  2  4  6  8 10 12 14 16
[1]  0  2  4  6  8 10 12 14 16
> pretty(1:15, h = 2)   # 0  5 10 15
[1]  0  5 10 15
> pretty(1:15, n = 4)   # 0  5 10 15
[1]  0  5 10 15
> pretty(1:15 * 2)      # 0  5 10 15 20 25 30
[1]  0  5 10 15 20 25 30
> pretty(1:20)          # 0  5 10 15 20
[1]  0  5 10 15 20
> pretty(1:20, n = 2)   # 0 10 20
[1]  0 10 20
> pretty(1:20, n = 10)  # 0  2  4 ... 20
 [1]  0  2  4  6  8 10 12 14 16 18 20
> 
> for(k in 5:11) {
+   cat("k=", k, ": "); print(diff(range(pretty(100 + c(0, pi*10^-k)))))}
k= 5 : [1] 3.5e-05
k= 6 : [1] 3.5e-06
k= 7 : [1] 3.5e-07
k= 8 : [1] 3.5e-08
k= 9 : [1] 3.500006e-09
k= 10 : [1] 3.499991e-10
k= 11 : [1] 3.498712e-11
> 
> ##-- more bizarre, when  min(x) == max(x):
> pretty(pi)
[1] 2 4
> 
> add.names <- function(v) { names(v) <- paste(v); v}
> utils::str(lapply(add.names(-10:20), pretty))
List of 31
 $ -10: num [1:2] -10 0
 $ -9 : int [1:2] -10 -5
 $ -8 : int [1:2] -10 -5
 $ -7 : int [1:2] -10 -5
 $ -6 : int [1:2] -10 -5
 $ -5 : num [1:2] -5 0
 $ -4 : num [1:2] -5 0
 $ -3 : int [1:2] -4 -2
 $ -2 : num [1:2] -2 0
 $ -1 : num [1:2] -1 0
 $ 0  : num [1:2] -1 0
 $ 1  : num [1:2] 0 1
 $ 2  : num [1:2] 0 2
 $ 3  : int [1:2] 2 4
 $ 4  : num [1:2] 0 5
 $ 5  : num [1:2] 0 5
 $ 6  : int [1:2] 5 10
 $ 7  : int [1:2] 5 10
 $ 8  : int [1:2] 5 10
 $ 9  : int [1:2] 5 10
 $ 10 : num [1:2] 0 10
 $ 11 : int [1:2] 10 20
 $ 12 : int [1:2] 10 20
 $ 13 : int [1:2] 10 20
 $ 14 : int [1:2] 10 20
 $ 15 : int [1:2] 10 20
 $ 16 : int [1:2] 10 20
 $ 17 : int [1:2] 10 20
 $ 18 : int [1:2] 10 20
 $ 19 : int [1:2] 10 20
 $ 20 : int [1:2] 10 20
> utils::str(lapply(add.names(0:20),   pretty, min.n = 0))
List of 21
 $ 0 : int 0
 $ 1 : int 1
 $ 2 : int 2
 $ 3 : int [1:2] 2 4
 $ 4 : num [1:2] 0 5
 $ 5 : int 5
 $ 6 : int [1:2] 5 10
 $ 7 : int [1:2] 5 10
 $ 8 : int [1:2] 5 10
 $ 9 : int [1:2] 5 10
 $ 10: int 10
 $ 11: int [1:2] 10 20
 $ 12: int [1:2] 10 20
 $ 13: int [1:2] 10 20
 $ 14: int [1:2] 10 20
 $ 15: int [1:2] 10 20
 $ 16: int [1:2] 10 20
 $ 17: int [1:2] 10 20
 $ 18: int [1:2] 10 20
 $ 19: int [1:2] 10 20
 $ 20: int 20
> sapply(    add.names(0:20),   pretty, min.n = 4)
        0   1   2   3 4 5 6 7  8  9 10 11 12 13 14 15 16 17 18 19 20
[1,] -0.4 0.6 1.0 2.0 2 3 4 5  4  4  6  6  8  8 10 10 12 12 14 14 16
[2,] -0.2 0.8 1.5 2.5 3 4 5 6  6  6  8  8 10 10 12 12 14 14 16 16 18
[3,]  0.0 1.0 2.0 3.0 4 5 6 7  8  8 10 10 12 12 14 14 16 16 18 18 20
[4,]  0.2 1.2 2.5 3.5 5 6 7 8 10 10 12 12 14 14 16 16 18 18 20 20 22
[5,]  0.4 1.4 3.0 4.0 6 7 8 9 12 12 14 14 16 16 18 18 20 20 22 22 24
> 
> pretty(1.234e100)
[1] 1.2e+100 1.3e+100
> pretty(1001.1001)
[1] 1000 1100
> pretty(1001.1001, shrink = 0.2)
[1] 1000 1020
> for(k in -7:3)
+   cat("shrink=", formatC(2^k, width = 9),":",
+       formatC(pretty(1001.1001, shrink.sml = 2^k), width = 6),"\n")
shrink=  0.007812 :   1001   1002 
shrink=   0.01562 :   1000   1002 
shrink=   0.03125 :   1000   1005 
shrink=    0.0625 :   1000   1005 
shrink=     0.125 :   1000   1010 
shrink=      0.25 :   1000   1020 
shrink=       0.5 :   1000   1050 
shrink=         1 :   1000   1100 
shrink=         2 :   1000   1200 
shrink=         4 :   1000   1500 
shrink=         8 :   1000   2000 
> 
> 
> 
> cleanEx()
> nameEx("print")
> ### * print
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: print
> ### Title: Print Values
> ### Aliases: print print.factor print.function print.listof
> ###   print.simple.list print.Dlist print.table
> ### Keywords: print
> 
> ### ** Examples
> 
> require(stats)
> 
> ts(1:20)  #-- print is the "Default function" --> print.ts(.) is called
Time Series:
Start = 1 
End = 20 
Frequency = 1 
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20
> for(i in 1:3) print(1:i)
[1] 1
[1] 1 2
[1] 1 2 3
> 
> ## Printing of factors
> attenu$station ## 117 levels -> 'max.levels' depending on width
  [1] 117  1083 1095 283  135  475  113  1008 1028 2001 117  1117 1438 1083 1013
 [16] 1014 1015 1016 1095 1011 1028 270  280  116  266  117  113  112  130  475 
 [31] 269  135  1093 1093 111  116  290  112  113  128  126  127  141  266  110 
 [46] 1027 111  125  135  475  262  269  1052 411  290  130  272  1096 1102 112 
 [61] 113  1028 2714 2708 2715 3501 655  272  1032 1377 1028 1250 1051 1293 1291
 [76] 1292 283  885  <NA> 2734 <NA> 2728 1413 1445 1408 1411 1410 1409 1377 1492
 [91] 1251 1422 1376 <NA> 286  <NA> 5028 942  <NA> 5054 958  952  5165 117  955 
[106] 5055 <NA> <NA> 5060 412  5053 5058 5057 <NA> 5051 <NA> 5115 <NA> 931  5056
[121] 5059 5061 <NA> 5062 5052 <NA> 724  <NA> 5066 5050 2316 5055 942  5028 5165
[136] 952  958  955  117  412  5053 5054 5058 5057 5115 5056 5060 1030 1418 1383
[151] 1308 1298 1299 1219 <NA> <NA> 1030 1418 1383 <NA> 1299 1308 1219 1456 5045
[166] 5044 5160 5043 5047 c168 5068 c118 5042 5067 5049 c204 5070 c266 c203 5069
[181] 5073 5072
117 Levels: 1008 1011 1013 1014 1015 1016 1027 1028 1030 1032 1051 1052 ... c266
> 
> ## ordered factors: levels  "l1 < l2 < .."
> esoph$agegp[1:12]
 [1] 25-34 25-34 25-34 25-34 25-34 25-34 25-34 25-34 25-34 25-34 25-34 25-34
Levels: 25-34 < 35-44 < 45-54 < 55-64 < 65-74 < 75+
> esoph$alcgp[1:12]
 [1] 0-39g/day 0-39g/day 0-39g/day 0-39g/day 40-79     40-79     40-79    
 [8] 40-79     80-119    80-119    80-119    120+     
Levels: 0-39g/day < 40-79 < 80-119 < 120+
> 
> ## Printing of sparse (contingency) tables
> set.seed(521)
> t1 <- round(abs(rt(200, df = 1.8)))
> t2 <- round(abs(rt(200, df = 1.4)))
> table(t1, t2) # simple
    t2
t1    0  1  2  3  4  5  6  7  8 10 17 21 30
  0  21 22 14  4  1  0  1  1  1  0  1  0  0
  1  25 21  7  3  4  2  1  1  1  1  0  0  0
  2   8 16  9  2  0  0  0  0  0  0  0  1  1
  3   3  7  0  2  0  0  0  0  0  0  0  0  0
  4   1  5  2  0  0  0  1  0  0  0  0  0  0
  5   1  1  1  0  0  0  0  0  0  0  0  0  0
  6   1  3  0  0  0  0  0  0  0  0  0  0  0
  7   1  0  0  0  0  0  0  0  0  0  0  0  0
  9   0  0  0  1  0  0  0  0  0  0  0  0  0
  12  1  0  0  0  0  0  0  0  0  0  0  0  0
> print(table(t1, t2), zero.print = ".") # nicer to read
    t2
t1    0  1  2  3  4  5  6  7  8 10 17 21 30
  0  21 22 14  4  1  .  1  1  1  .  1  .  .
  1  25 21  7  3  4  2  1  1  1  1  .  .  .
  2   8 16  9  2  .  .  .  .  .  .  .  1  1
  3   3  7  .  2  .  .  .  .  .  .  .  .  .
  4   1  5  2  .  .  .  1  .  .  .  .  .  .
  5   1  1  1  .  .  .  .  .  .  .  .  .  .
  6   1  3  .  .  .  .  .  .  .  .  .  .  .
  7   1  .  .  .  .  .  .  .  .  .  .  .  .
  9   .  .  .  1  .  .  .  .  .  .  .  .  .
  12  1  .  .  .  .  .  .  .  .  .  .  .  .
> 
> ## same for non-integer "table":
> T <- table(t2,t1)
> T <- T * (1+round(rlnorm(length(T)))/4)
> print(T, zero.print = ".") # quite nicer,
    t1
t2       0     1     2     3     4     5     6     7     9    12
  0  26.25 25.00 10.00  3.75  1.50  1.25  1.25  1.00     .  2.00
  1  22.00 26.25 16.00 10.50 27.50  1.25  3.00     .     .     .
  2  21.00  7.00 13.50     .  3.00  1.25     .     .     .     .
  3   5.00  3.75  2.50  2.50     .     .     .     .  1.50     .
  4   1.25  5.00     .     .     .     .     .     .     .     .
  5      .  2.00     .     .     .     .     .     .     .     .
  6   1.25  1.50     .     .  1.25     .     .     .     .     .
  7   1.25  1.25     .     .     .     .     .     .     .     .
  8   1.50  1.00     .     .     .     .     .     .     .     .
  10     .  1.00     .     .     .     .     .     .     .     .
  17  1.00     .     .     .     .     .     .     .     .     .
  21     .     .  2.75     .     .     .     .     .     .     .
  30     .     .  5.00     .     .     .     .     .     .     .
> print.table(T[,2:8] * 1e9, digits=3, zero.print = ".")
    t1
t2          1        2        3        4        5        6        7
  0  2.50e+10 1.00e+10 3.75e+09 1.50e+09 1.25e+09 1.25e+09 1.00e+09
  1  2.62e+10 1.60e+10 1.05e+10 2.75e+10 1.25e+09 3.00e+09        .
  2  7.00e+09 1.35e+10        . 3.00e+09 1.25e+09        .        .
  3  3.75e+09 2.50e+09 2.50e+09        .        .        .        .
  4  5.00e+09        .        .        .        .        .        .
  5  2.00e+09        .        .        .        .        .        .
  6  1.50e+09        .        . 1.25e+09        .        .        .
  7  1.25e+09        .        .        .        .        .        .
  8  1.00e+09        .        .        .        .        .        .
  10 1.00e+09        .        .        .        .        .        .
  17        .        .        .        .        .        .        .
  21        . 2.75e+09        .        .        .        .        .
  30        . 5.00e+09        .        .        .        .        .
> ## still slightly inferior to  Matrix::Matrix(T)  for larger T
> 
> ## Corner cases with empty extents:
> table(1, NA) # < table of extent 1 x 0 >
< table of extent 1 x 0 >
> 
> 
> 
> cleanEx()
> nameEx("print.dataframe")
> ### * print.dataframe
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: print.data.frame
> ### Title: Printing Data Frames
> ### Aliases: print.data.frame
> ### Keywords: print
> 
> ### ** Examples
> 
> (dd <- data.frame(x = 1:8, f = gl(2,4), ch = I(letters[1:8])))
  x f ch
1 1 1  a
2 2 1  b
3 3 1  c
4 4 1  d
5 5 2  e
6 6 2  f
7 7 2  g
8 8 2  h
>      # print() with defaults
> print(dd, quote = TRUE, row.names = FALSE)
   x   f  ch
 "1" "1" "a"
 "2" "1" "b"
 "3" "1" "c"
 "4" "1" "d"
 "5" "2" "e"
 "6" "2" "f"
 "7" "2" "g"
 "8" "2" "h"
>      # suppresses row.names and quotes all entries
> 
> 
> 
> cleanEx()
> nameEx("print.default")
> ### * print.default
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: print.default
> ### Title: Default Printing
> ### Aliases: print.default
> ### Keywords: print
> 
> ### ** Examples
> 
> pi
[1] 3.141593
> print(pi, digits = 16)
[1] 3.141592653589793
> LETTERS[1:16]
 [1] "A" "B" "C" "D" "E" "F" "G" "H" "I" "J" "K" "L" "M" "N" "O" "P"
> print(LETTERS, quote = FALSE)
 [1] A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
> 
> M <- cbind(I = 1, matrix(1:10000, ncol = 10,
+                          dimnames = list(NULL, LETTERS[1:10])))
> utils::head(M)        # makes more sense than
     I A    B    C    D    E    F    G    H    I    J
[1,] 1 1 1001 2001 3001 4001 5001 6001 7001 8001 9001
[2,] 1 2 1002 2002 3002 4002 5002 6002 7002 8002 9002
[3,] 1 3 1003 2003 3003 4003 5003 6003 7003 8003 9003
[4,] 1 4 1004 2004 3004 4004 5004 6004 7004 8004 9004
[5,] 1 5 1005 2005 3005 4005 5005 6005 7005 8005 9005
[6,] 1 6 1006 2006 3006 4006 5006 6006 7006 8006 9006
> print(M, max = 1000)  # prints 90 rows and a message about omitting 910
        I    A    B    C    D    E    F    G    H    I     J
   [1,] 1    1 1001 2001 3001 4001 5001 6001 7001 8001  9001
   [2,] 1    2 1002 2002 3002 4002 5002 6002 7002 8002  9002
   [3,] 1    3 1003 2003 3003 4003 5003 6003 7003 8003  9003
   [4,] 1    4 1004 2004 3004 4004 5004 6004 7004 8004  9004
   [5,] 1    5 1005 2005 3005 4005 5005 6005 7005 8005  9005
   [6,] 1    6 1006 2006 3006 4006 5006 6006 7006 8006  9006
   [7,] 1    7 1007 2007 3007 4007 5007 6007 7007 8007  9007
   [8,] 1    8 1008 2008 3008 4008 5008 6008 7008 8008  9008
   [9,] 1    9 1009 2009 3009 4009 5009 6009 7009 8009  9009
  [10,] 1   10 1010 2010 3010 4010 5010 6010 7010 8010  9010
  [11,] 1   11 1011 2011 3011 4011 5011 6011 7011 8011  9011
  [12,] 1   12 1012 2012 3012 4012 5012 6012 7012 8012  9012
  [13,] 1   13 1013 2013 3013 4013 5013 6013 7013 8013  9013
  [14,] 1   14 1014 2014 3014 4014 5014 6014 7014 8014  9014
  [15,] 1   15 1015 2015 3015 4015 5015 6015 7015 8015  9015
  [16,] 1   16 1016 2016 3016 4016 5016 6016 7016 8016  9016
  [17,] 1   17 1017 2017 3017 4017 5017 6017 7017 8017  9017
  [18,] 1   18 1018 2018 3018 4018 5018 6018 7018 8018  9018
  [19,] 1   19 1019 2019 3019 4019 5019 6019 7019 8019  9019
  [20,] 1   20 1020 2020 3020 4020 5020 6020 7020 8020  9020
  [21,] 1   21 1021 2021 3021 4021 5021 6021 7021 8021  9021
  [22,] 1   22 1022 2022 3022 4022 5022 6022 7022 8022  9022
  [23,] 1   23 1023 2023 3023 4023 5023 6023 7023 8023  9023
  [24,] 1   24 1024 2024 3024 4024 5024 6024 7024 8024  9024
  [25,] 1   25 1025 2025 3025 4025 5025 6025 7025 8025  9025
  [26,] 1   26 1026 2026 3026 4026 5026 6026 7026 8026  9026
  [27,] 1   27 1027 2027 3027 4027 5027 6027 7027 8027  9027
  [28,] 1   28 1028 2028 3028 4028 5028 6028 7028 8028  9028
  [29,] 1   29 1029 2029 3029 4029 5029 6029 7029 8029  9029
  [30,] 1   30 1030 2030 3030 4030 5030 6030 7030 8030  9030
  [31,] 1   31 1031 2031 3031 4031 5031 6031 7031 8031  9031
  [32,] 1   32 1032 2032 3032 4032 5032 6032 7032 8032  9032
  [33,] 1   33 1033 2033 3033 4033 5033 6033 7033 8033  9033
  [34,] 1   34 1034 2034 3034 4034 5034 6034 7034 8034  9034
  [35,] 1   35 1035 2035 3035 4035 5035 6035 7035 8035  9035
  [36,] 1   36 1036 2036 3036 4036 5036 6036 7036 8036  9036
  [37,] 1   37 1037 2037 3037 4037 5037 6037 7037 8037  9037
  [38,] 1   38 1038 2038 3038 4038 5038 6038 7038 8038  9038
  [39,] 1   39 1039 2039 3039 4039 5039 6039 7039 8039  9039
  [40,] 1   40 1040 2040 3040 4040 5040 6040 7040 8040  9040
  [41,] 1   41 1041 2041 3041 4041 5041 6041 7041 8041  9041
  [42,] 1   42 1042 2042 3042 4042 5042 6042 7042 8042  9042
  [43,] 1   43 1043 2043 3043 4043 5043 6043 7043 8043  9043
  [44,] 1   44 1044 2044 3044 4044 5044 6044 7044 8044  9044
  [45,] 1   45 1045 2045 3045 4045 5045 6045 7045 8045  9045
  [46,] 1   46 1046 2046 3046 4046 5046 6046 7046 8046  9046
  [47,] 1   47 1047 2047 3047 4047 5047 6047 7047 8047  9047
  [48,] 1   48 1048 2048 3048 4048 5048 6048 7048 8048  9048
  [49,] 1   49 1049 2049 3049 4049 5049 6049 7049 8049  9049
  [50,] 1   50 1050 2050 3050 4050 5050 6050 7050 8050  9050
  [51,] 1   51 1051 2051 3051 4051 5051 6051 7051 8051  9051
  [52,] 1   52 1052 2052 3052 4052 5052 6052 7052 8052  9052
  [53,] 1   53 1053 2053 3053 4053 5053 6053 7053 8053  9053
  [54,] 1   54 1054 2054 3054 4054 5054 6054 7054 8054  9054
  [55,] 1   55 1055 2055 3055 4055 5055 6055 7055 8055  9055
  [56,] 1   56 1056 2056 3056 4056 5056 6056 7056 8056  9056
  [57,] 1   57 1057 2057 3057 4057 5057 6057 7057 8057  9057
  [58,] 1   58 1058 2058 3058 4058 5058 6058 7058 8058  9058
  [59,] 1   59 1059 2059 3059 4059 5059 6059 7059 8059  9059
  [60,] 1   60 1060 2060 3060 4060 5060 6060 7060 8060  9060
  [61,] 1   61 1061 2061 3061 4061 5061 6061 7061 8061  9061
  [62,] 1   62 1062 2062 3062 4062 5062 6062 7062 8062  9062
  [63,] 1   63 1063 2063 3063 4063 5063 6063 7063 8063  9063
  [64,] 1   64 1064 2064 3064 4064 5064 6064 7064 8064  9064
  [65,] 1   65 1065 2065 3065 4065 5065 6065 7065 8065  9065
  [66,] 1   66 1066 2066 3066 4066 5066 6066 7066 8066  9066
  [67,] 1   67 1067 2067 3067 4067 5067 6067 7067 8067  9067
  [68,] 1   68 1068 2068 3068 4068 5068 6068 7068 8068  9068
  [69,] 1   69 1069 2069 3069 4069 5069 6069 7069 8069  9069
  [70,] 1   70 1070 2070 3070 4070 5070 6070 7070 8070  9070
  [71,] 1   71 1071 2071 3071 4071 5071 6071 7071 8071  9071
  [72,] 1   72 1072 2072 3072 4072 5072 6072 7072 8072  9072
  [73,] 1   73 1073 2073 3073 4073 5073 6073 7073 8073  9073
  [74,] 1   74 1074 2074 3074 4074 5074 6074 7074 8074  9074
  [75,] 1   75 1075 2075 3075 4075 5075 6075 7075 8075  9075
  [76,] 1   76 1076 2076 3076 4076 5076 6076 7076 8076  9076
  [77,] 1   77 1077 2077 3077 4077 5077 6077 7077 8077  9077
  [78,] 1   78 1078 2078 3078 4078 5078 6078 7078 8078  9078
  [79,] 1   79 1079 2079 3079 4079 5079 6079 7079 8079  9079
  [80,] 1   80 1080 2080 3080 4080 5080 6080 7080 8080  9080
  [81,] 1   81 1081 2081 3081 4081 5081 6081 7081 8081  9081
  [82,] 1   82 1082 2082 3082 4082 5082 6082 7082 8082  9082
  [83,] 1   83 1083 2083 3083 4083 5083 6083 7083 8083  9083
  [84,] 1   84 1084 2084 3084 4084 5084 6084 7084 8084  9084
  [85,] 1   85 1085 2085 3085 4085 5085 6085 7085 8085  9085
  [86,] 1   86 1086 2086 3086 4086 5086 6086 7086 8086  9086
  [87,] 1   87 1087 2087 3087 4087 5087 6087 7087 8087  9087
  [88,] 1   88 1088 2088 3088 4088 5088 6088 7088 8088  9088
  [89,] 1   89 1089 2089 3089 4089 5089 6089 7089 8089  9089
  [90,] 1   90 1090 2090 3090 4090 5090 6090 7090 8090  9090
 [ reached getOption("max.print") -- omitted 910 rows ]
> 
> 
> 
> cleanEx()
> nameEx("prmatrix")
> ### * prmatrix
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: prmatrix
> ### Title: Print Matrices, Old-style
> ### Aliases: prmatrix
> ### Keywords: print
> 
> ### ** Examples
> 
> prmatrix(m6 <- diag(6), rowlab = rep("", 6), collab = rep("", 6))
            
 1 0 0 0 0 0
 0 1 0 0 0 0
 0 0 1 0 0 0
 0 0 0 1 0 0
 0 0 0 0 1 0
 0 0 0 0 0 1
> 
> chm <- matrix(scan(system.file("help", "AnIndex", package = "splines"),
+                    what = ""), , 2, byrow = TRUE)
Read 44 items
> chm  # uses print.matrix()
      [,1]                  [,2]             
 [1,] "splines-package"     "splines-package"
 [2,] "as.polySpline"       "polySpline"     
 [3,] "asVector"            "asVector"       
 [4,] "backSpline"          "backSpline"     
 [5,] "bs"                  "bs"             
 [6,] "interpSpline"        "interpSpline"   
 [7,] "ns"                  "ns"             
 [8,] "periodicSpline"      "periodicSpline" 
 [9,] "polySpline"          "polySpline"     
[10,] "predict.bs"          "predict.bs"     
[11,] "predict.bSpline"     "predict.bSpline"
[12,] "predict.nbSpline"    "predict.bSpline"
[13,] "predict.npolySpline" "predict.bSpline"
[14,] "predict.ns"          "predict.bs"     
[15,] "predict.pbSpline"    "predict.bSpline"
[16,] "predict.ppolySpline" "predict.bSpline"
[17,] "spline.des"          "splineDesign"   
[18,] "splineDesign"        "splineDesign"   
[19,] "splineKnots"         "splineKnots"    
[20,] "splineOrder"         "splineOrder"    
[21,] "splines"             "splines-package"
[22,] "xyVector"            "xyVector"       
> prmatrix(chm, collab = paste("Column", 1:3), right = TRUE, quote = FALSE)
                 Column 1        Column 2
 [1,]     splines-package splines-package
 [2,]       as.polySpline      polySpline
 [3,]            asVector        asVector
 [4,]          backSpline      backSpline
 [5,]                  bs              bs
 [6,]        interpSpline    interpSpline
 [7,]                  ns              ns
 [8,]      periodicSpline  periodicSpline
 [9,]          polySpline      polySpline
[10,]          predict.bs      predict.bs
[11,]     predict.bSpline predict.bSpline
[12,]    predict.nbSpline predict.bSpline
[13,] predict.npolySpline predict.bSpline
[14,]          predict.ns      predict.bs
[15,]    predict.pbSpline predict.bSpline
[16,] predict.ppolySpline predict.bSpline
[17,]          spline.des    splineDesign
[18,]        splineDesign    splineDesign
[19,]         splineKnots     splineKnots
[20,]         splineOrder     splineOrder
[21,]             splines splines-package
[22,]            xyVector        xyVector
> 
> 
> 
> cleanEx()
> nameEx("proc.time")
> ### * proc.time
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: proc.time
> ### Title: Running Time of R
> ### Aliases: proc.time print.proc_time summary.proc_time
> ### Keywords: utilities
> 
> ### ** Examples
> 
> 
> cleanEx()
> nameEx("prod")
> ### * prod
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: prod
> ### Title: Product of Vector Elements
> ### Aliases: prod
> ### Keywords: arith
> 
> ### ** Examples
> 
> print(prod(1:7)) == print(gamma(8))
[1] 5040
[1] 5040
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("proportions")
> ### * proportions
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: proportions
> ### Title: Express Table Entries as Fraction of Marginal Table
> ### Aliases: proportions prop.table
> ### Keywords: array
> 
> ### ** Examples
> 
> m <- matrix(1:4, 2)
> m
     [,1] [,2]
[1,]    1    3
[2,]    2    4
> proportions(m, 1)
          [,1]      [,2]
[1,] 0.2500000 0.7500000
[2,] 0.3333333 0.6666667
> 
> DF <- as.data.frame(UCBAdmissions)
> tbl <- xtabs(Freq ~ Gender + Admit, DF)
> 
> proportions(tbl, "Gender")
        Admit
Gender    Admitted  Rejected
  Male   0.4451877 0.5548123
  Female 0.3035422 0.6964578
> 
> 
> 
> cleanEx()
> nameEx("pushBack")
> ### * pushBack
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pushBack
> ### Title: Push Text Back on to a Connection
> ### Aliases: pushBack pushBackLength clearPushBack
> ### Keywords: connection
> 
> ### ** Examples
> 
> zz <- textConnection(LETTERS)
> readLines(zz, 2)
[1] "A" "B"
> pushBack(c("aa", "bb"), zz)
> pushBackLength(zz)
[1] 2
> readLines(zz, 1)
[1] "aa"
> pushBackLength(zz)
[1] 1
> readLines(zz, 1)
[1] "bb"
> readLines(zz, 1)
[1] "C"
> close(zz)
> 
> 
> 
> cleanEx()
> nameEx("qr")
> ### * qr
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: qr
> ### Title: The QR Decomposition of a Matrix
> ### Aliases: qr qr.default qr.coef qr.qy qr.qty qr.resid qr.fitted qr.solve
> ###   is.qr as.qr solve.qr
> ### Keywords: algebra array
> 
> ### ** Examples
> 
> hilbert <- function(n) { i <- 1:n; 1 / outer(i - 1, i, "+") }
> h9 <- hilbert(9); h9
           [,1]      [,2]       [,3]       [,4]       [,5]       [,6]
 [1,] 1.0000000 0.5000000 0.33333333 0.25000000 0.20000000 0.16666667
 [2,] 0.5000000 0.3333333 0.25000000 0.20000000 0.16666667 0.14285714
 [3,] 0.3333333 0.2500000 0.20000000 0.16666667 0.14285714 0.12500000
 [4,] 0.2500000 0.2000000 0.16666667 0.14285714 0.12500000 0.11111111
 [5,] 0.2000000 0.1666667 0.14285714 0.12500000 0.11111111 0.10000000
 [6,] 0.1666667 0.1428571 0.12500000 0.11111111 0.10000000 0.09090909
 [7,] 0.1428571 0.1250000 0.11111111 0.10000000 0.09090909 0.08333333
 [8,] 0.1250000 0.1111111 0.10000000 0.09090909 0.08333333 0.07692308
 [9,] 0.1111111 0.1000000 0.09090909 0.08333333 0.07692308 0.07142857
            [,7]       [,8]       [,9]
 [1,] 0.14285714 0.12500000 0.11111111
 [2,] 0.12500000 0.11111111 0.10000000
 [3,] 0.11111111 0.10000000 0.09090909
 [4,] 0.10000000 0.09090909 0.08333333
 [5,] 0.09090909 0.08333333 0.07692308
 [6,] 0.08333333 0.07692308 0.07142857
 [7,] 0.07692308 0.07142857 0.06666667
 [8,] 0.07142857 0.06666667 0.06250000
 [9,] 0.06666667 0.06250000 0.05882353
> qr(h9)$rank           #--> only 7
[1] 7
> qrh9 <- qr(h9, tol = 1e-10)
> qrh9$rank             #--> 9
[1] 9
> ##-- Solve linear equation system  H %*% x = y :
> y <- 1:9/10
> x <- qr.solve(h9, y, tol = 1e-10) # or equivalently :
> x <- qr.coef(qrh9, y) #-- is == but much better than
>                       #-- solve(h9) %*% y
> h9 %*% x              # = y
      [,1]
 [1,]  0.1
 [2,]  0.2
 [3,]  0.3
 [4,]  0.4
 [5,]  0.5
 [6,]  0.6
 [7,]  0.7
 [8,]  0.8
 [9,]  0.9
> 
> 
> ## overdetermined system
> A <- matrix(runif(12), 4)
> b <- 1:4
> qr.solve(A, b) # or solve(qr(A), b)
[1]  3.9751622  0.7056647 -0.2818144
> solve(qr(A, LAPACK = TRUE), b)
[1]  3.9751622  0.7056647 -0.2818144
> # this is a least-squares solution, cf. lm(b ~ 0 + A)
> 
> ## underdetermined system
> A <- matrix(runif(12), 3)
> b <- 1:3
> qr.solve(A, b)
[1] -4.402222 15.112876 -9.202409  0.000000
> solve(qr(A, LAPACK = TRUE), b)
[1] -1.326626  4.144325  0.000000 -0.712753
> # solutions will have one zero, not necessarily the same one
> 
> 
> 
> cleanEx()
> nameEx("qraux")
> ### * qraux
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: QR.Auxiliaries
> ### Title: Reconstruct the Q, R, or X Matrices from a QR Object
> ### Aliases: qr.X qr.Q qr.R
> ### Keywords: algebra array
> 
> ### ** Examples
> 
> p <- ncol(x <- LifeCycleSavings[, -1]) # not the 'sr'
> qrstr <- qr(x)   # dim(x) == c(n,p)
> qrstr $ rank # = 4 = p
[1] 4
> Q <- qr.Q(qrstr) # dim(Q) == dim(x)
> R <- qr.R(qrstr) # dim(R) == ncol(x)
> X <- qr.X(qrstr) # X == x
> range(X - as.matrix(x))  # ~ < 6e-12
[1] -1.818989e-12  1.364242e-12
> ## X == Q %*% R if there has been no pivoting, as here:
> all.equal(unname(X),
+           unname(Q %*% R))
[1] TRUE
> 
> # example of pivoting
> x <- cbind(int = 1,
+            b1 = rep(1:0, each = 3), b2 = rep(0:1, each = 3),
+            c1 = rep(c(1,0,0), 2), c2 = rep(c(0,1,0), 2), c3 = rep(c(0,0,1),2))
> x # is singular, columns "b2" and "c3" are "extra"
     int b1 b2 c1 c2 c3
[1,]   1  1  0  1  0  0
[2,]   1  1  0  0  1  0
[3,]   1  1  0  0  0  1
[4,]   1  0  1  1  0  0
[5,]   1  0  1  0  1  0
[6,]   1  0  1  0  0  1
> a <- qr(x)
> zapsmall(qr.R(a)) # columns are int b1 c1 c2 b2 c3
          int        b1         c1         c2        b2         c3
[1,] -2.44949 -1.224745 -0.8164966 -0.8164966 -1.224745 -0.8164966
[2,]  0.00000 -1.224745  0.0000000  0.0000000  1.224745  0.0000000
[3,]  0.00000  0.000000  1.1547005 -0.5773503  0.000000 -0.5773503
[4,]  0.00000  0.000000  0.0000000 -1.0000000  0.000000  1.0000000
[5,]  0.00000  0.000000  0.0000000  0.0000000  0.000000  0.0000000
[6,]  0.00000  0.000000  0.0000000  0.0000000  0.000000  0.0000000
> a$pivot
[1] 1 2 4 5 3 6
> pivI <- sort.list(a$pivot) # the inverse permutation
> all.equal (x,            qr.Q(a) %*% qr.R(a)) # no, no
[1] "Attributes: < Component “dimnames”: Component 2: 3 string mismatches >"
[2] "Mean relative difference: 0.7692308"                                   
> stopifnot(
+  all.equal(x[, a$pivot], qr.Q(a) %*% qr.R(a)),          # TRUE
+  all.equal(x           , qr.Q(a) %*% qr.R(a)[, pivI]))  # TRUE too!
> 
> 
> 
> cleanEx()
> nameEx("quit")
> ### * quit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: quit
> ### Title: Terminate an R Session
> ### Aliases: quit q .Last .Last.sys
> ### Keywords: environment
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ## Unix-flavour example
> ##D .Last <- function() {
> ##D   graphics.off() # close devices before printing
> ##D   cat("Now sending PDF graphics to the printer:\n")
> ##D   system("lpr Rplots.pdf")
> ##D   cat("bye bye...\n")
> ##D }
> ##D quit("yes")
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("range")
> ### * range
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: range
> ### Title: Range of Values
> ### Aliases: range range.default
> ### Keywords: univar arith
> 
> ### ** Examples
> 
> (r.x <- range(stats::rnorm(100)))
[1] -2.214700  2.401618
> diff(r.x) # the SAMPLE range
[1] 4.616318
> 
> x <- c(NA, 1:3, -1:1/0); x
[1]   NA    1    2    3 -Inf  NaN  Inf
> range(x)
[1] NA NA
> range(x, na.rm = TRUE)
[1] -Inf  Inf
> range(x, finite = TRUE)
[1] 1 3
> 
> 
> 
> cleanEx()
> nameEx("rank")
> ### * rank
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rank
> ### Title: Sample Ranks
> ### Aliases: rank
> ### Keywords: univar
> 
> ### ** Examples
> 
> (r1 <- rank(x1 <- c(3, 1, 4, 15, 92)))
[1] 2 1 3 4 5
> x2 <- c(3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5)
> names(x2) <- letters[1:11]
> (r2 <- rank(x2)) # ties are averaged
   a    b    c    d    e    f    g    h    i    j    k 
 4.5  1.5  6.0  1.5  8.0 11.0  3.0 10.0  8.0  4.5  8.0 
> 
> ## rank() is "idempotent": rank(rank(x)) == rank(x) :
> stopifnot(rank(r1) == r1, rank(r2) == r2)
> 
> ## ranks without averaging
> rank(x2, ties.method= "first")  # first occurrence wins
 a  b  c  d  e  f  g  h  i  j  k 
 4  1  6  2  7 11  3 10  8  5  9 
> rank(x2, ties.method= "last")   #  last occurrence wins
 a  b  c  d  e  f  g  h  i  j  k 
 5  2  6  1  9 11  3 10  8  4  7 
> rank(x2, ties.method= "random") # ties broken at random
 a  b  c  d  e  f  g  h  i  j  k 
 5  1  6  2  7 11  3 10  9  4  8 
> rank(x2, ties.method= "random") # and again
 a  b  c  d  e  f  g  h  i  j  k 
 4  1  6  2  8 11  3 10  9  5  7 
> 
> ## keep ties ties, no average
> (rma <- rank(x2, ties.method= "max"))  # as used classically
 a  b  c  d  e  f  g  h  i  j  k 
 5  2  6  2  9 11  3 10  9  5  9 
> (rmi <- rank(x2, ties.method= "min"))  # as in Sports
 a  b  c  d  e  f  g  h  i  j  k 
 4  1  6  1  7 11  3 10  7  4  7 
> stopifnot(rma + rmi == round(r2 + r2))
> 
> ## Comparing all tie.methods:
> tMeth <- eval(formals(rank)$ties.method)
> rx2 <- sapply(tMeth, function(M) rank(x2, ties.method=M))
> cbind(x2, rx2)
  x2 average first last random max min
a  3     4.5     4    5      5   5   4
b  1     1.5     1    2      1   2   1
c  4     6.0     6    6      6   6   6
d  1     1.5     2    1      2   2   1
e  5     8.0     7    9      7   9   7
f  9    11.0    11   11     11  11  11
g  2     3.0     3    3      3   3   3
h  6    10.0    10   10     10  10  10
i  5     8.0     8    8      8   9   7
j  3     4.5     5    4      4   5   4
k  5     8.0     9    7      9   9   7
> ## ties.method's does not matter w/o ties:
> x <- sample(47)
> rx <- sapply(tMeth, function(MM) rank(x, ties.method=MM))
> stopifnot(all(rx[,1] == rx))
> 
> 
> 
> cleanEx()
> nameEx("rapply")
> ### * rapply
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rapply
> ### Title: Recursively Apply a Function to a List
> ### Aliases: rapply
> ### Keywords: iteration list
> 
> ### ** Examples
> 
> X <- list(list(a = pi, b = list(c = 1L)), d = "a test")
> # the "identity operation":
> rapply(X, function(x) x, how = "replace") -> X.; stopifnot(identical(X, X.))
> rapply(X, sqrt, classes = "numeric", how = "replace")
[[1]]
[[1]]$a
[1] 1.772454

[[1]]$b
[[1]]$b$c
[1] 1



$d
[1] "a test"

> rapply(X, deparse, control = "all") # passing extras. argument of deparse()
                   a                  b.c                    d 
"3.1415926535897931"                 "1L"         "\"a test\"" 
> rapply(X, nchar, classes = "character", deflt = NA_integer_, how = "list")
[[1]]
[[1]]$a
[1] NA

[[1]]$b
[[1]]$b$c
[1] NA



$d
[1] 6

> rapply(X, nchar, classes = "character", deflt = NA_integer_, how = "unlist")
  a b.c   d 
 NA  NA   6 
> rapply(X, nchar, classes = "character",                      how = "unlist")
d 
6 
> rapply(X, log, classes = "numeric", how = "replace", base = 2)
[[1]]
[[1]]$a
[1] 1.651496

[[1]]$b
[[1]]$b$c
[1] 1



$d
[1] "a test"

> 
> ## with expression() / list():
> E  <- expression(list(a = pi, b = expression(c = C1 * C2)), d = "a test")
> LE <- list(expression(a = pi, b = expression(c = C1 * C2)), d = "a test")
> rapply(E, nchar, how="replace") # "expression(c = C1 * C2)" are 23 chars
expression(c(4L, 2L, 23L), d = 6L)
> rapply(E, nchar, classes = "character", deflt = NA_integer_, how = "unlist")
    d 
NA  6 
> rapply(LE, as.character) # a "pi" | b1 "expression" | b2 "C1 * C2" ..
           a           b1           b2            d 
        "pi" "expression"    "C1 * C2"     "a test" 
> rapply(LE, nchar)        # (see above)
 a b1 b2  d 
 2 10  7  6 
> stopifnot(exprs = {
+   identical(E , rapply(E , identity, how = "replace"))
+   identical(LE, rapply(LE, identity, how = "replace"))
+ })
> 
> 
> 
> cleanEx()
> nameEx("raw")
> ### * raw
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: raw
> ### Title: Raw Vectors
> ### Aliases: raw as.raw is.raw
> ### Keywords: classes
> 
> ### ** Examples
> 
> xx <- raw(2)
> xx[1] <- as.raw(40)     # NB, not just 40.
> xx[2] <- charToRaw("A")
> xx       ## 28 41   -- raw prints hexadecimals
[1] 28 41
> dput(xx) ## as.raw(c(0x28, 0x41))
as.raw(c(0x28, 0x41))
> as.integer(xx) ## 40 65
[1] 40 65
> 
> x <- "A test string"
> (y <- charToRaw(x))
 [1] 41 20 74 65 73 74 20 73 74 72 69 6e 67
> is.vector(y) # TRUE
[1] TRUE
> rawToChar(y)
[1] "A test string"
> is.raw(x)
[1] FALSE
> is.raw(y)
[1] TRUE
> stopifnot( charToRaw("\xa3") == as.raw(0xa3) )
> 
> isASCII <-  function(txt) all(charToRaw(txt) <= as.raw(127))
> isASCII(x)  # true
[1] TRUE
> isASCII("\xa325.63") # false (in Latin-1, this is an amount in UK pounds)
[1] FALSE
> 
> 
> 
> cleanEx()
> nameEx("rawConnection")
> ### * rawConnection
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rawConnection
> ### Title: Raw Connections
> ### Aliases: rawConnection rawConnectionValue
> ### Keywords: file connection
> 
> ### ** Examples
> 
> zz <- rawConnection(raw(0), "r+") # start with empty raw vector
> writeBin(LETTERS, zz)
> seek(zz, 0)
[1] 52
> readLines(zz) # raw vector has embedded nuls
Warning in readLines(zz) : line 1 appears to contain an embedded nul
Warning in readLines(zz) : incomplete final line found on 'raw(0)'
[1] "A"
> seek(zz, 0)
[1] 52
> writeBin(letters[1:3], zz)
> rawConnectionValue(zz)
 [1] 61 00 62 00 63 00 44 00 45 00 46 00 47 00 48 00 49 00 4a 00 4b 00 4c 00 4d
[26] 00 4e 00 4f 00 50 00 51 00 52 00 53 00 54 00 55 00 56 00 57 00 58 00 59 00
[51] 5a 00
> close(zz)
> 
> 
> 
> cleanEx()
> nameEx("rawConversion")
> ### * rawConversion
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rawConversion
> ### Title: Convert to or from Raw Vectors
> ### Aliases: charToRaw rawToChar rawShift rawToBits intToBits packBits
> ### Keywords: classes
> 
> ### ** Examples
> 
> x <- "A test string"
> (y <- charToRaw(x))
 [1] 41 20 74 65 73 74 20 73 74 72 69 6e 67
> is.vector(y) # TRUE
[1] TRUE
> 
> rawToChar(y)
[1] "A test string"
> rawToChar(y, multiple = TRUE)
 [1] "A" " " "t" "e" "s" "t" " " "s" "t" "r" "i" "n" "g"
> (xx <- c(y,  charToRaw("&"), charToRaw("more")))
 [1] 41 20 74 65 73 74 20 73 74 72 69 6e 67 26 6d 6f 72 65
> rawToChar(xx)
[1] "A test string&more"
> 
> rawShift(y, 1)
 [1] 82 40 e8 ca e6 e8 40 e6 e8 e4 d2 dc ce
> rawShift(y, -2)
 [1] 10 08 1d 19 1c 1d 08 1c 1d 1c 1a 1b 19
> 
> rawToBits(y)
  [1] 01 00 00 00 00 00 01 00 00 00 00 00 00 01 00 00 00 00 01 00 01 01 01 00 01
 [26] 00 01 00 00 01 01 00 01 01 00 00 01 01 01 00 00 00 01 00 01 01 01 00 00 00
 [51] 00 00 00 01 00 00 01 01 00 00 01 01 01 00 00 00 01 00 01 01 01 00 00 01 00
 [76] 00 01 01 01 00 01 00 00 01 00 01 01 00 00 01 01 01 00 01 01 00 01 01 01 00
[101] 00 01 01 00
> 
> showBits <- function(r) stats::symnum(as.logical(rawToBits(r)))
> 
> z <- as.raw(5)
> z ; showBits(z)
[1] 05
[1] | . | . . . . .
> showBits(rawShift(z, 1)) # shift to right
[1] . | . | . . . .
> showBits(rawShift(z, 2))
[1] . . | . | . . .
> showBits(z)
[1] | . | . . . . .
> showBits(rawShift(z, -1)) # shift to left
[1] . | . . . . . .
> showBits(rawShift(z, -2)) # ..
[1] | . . . . . . .
> showBits(rawShift(z, -3)) # shifted off entirely
[1] . . . . . . . .
> 
> 
> 
> cleanEx()
> nameEx("readBin")
> ### * readBin
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: readBin
> ### Title: Transfer Binary Data To and From Connections
> ### Aliases: readBin writeBin
> ### Keywords: file connection
> 
> ### ** Examples
> 
> zzfil <- tempfile("testbin")
> zz <- file(zzfil, "wb")
> writeBin(1:10, zz)
> writeBin(pi, zz, endian = "swap")
> writeBin(pi, zz, size = 4)
> writeBin(pi^2, zz, size = 4, endian = "swap")
> writeBin(pi+3i, zz)
> writeBin("A test of a connection", zz)
> z <- paste("A very long string", 1:100, collapse = " + ")
> writeBin(z, zz)
> if(.Machine$sizeof.long == 8 || .Machine$sizeof.longlong == 8)
+     writeBin(as.integer(5^(1:10)), zz, size = 8)
> if((s <- .Machine$sizeof.longdouble) > 8)
+     writeBin((pi/3)^(1:10), zz, size = s)
> close(zz)
> 
> zz <- file(zzfil, "rb")
> readBin(zz, integer(), 4)
[1] 1 2 3 4
> readBin(zz, integer(), 6)
[1]  5  6  7  8  9 10
> readBin(zz, numeric(), 1, endian = "swap")
[1] 3.141593
> readBin(zz, numeric(), size = 4)
[1] 3.141593
> readBin(zz, numeric(), size = 4, endian = "swap")
[1] 9.869604
> readBin(zz, complex(), 1)
[1] 3.141593+3i
> readBin(zz, character(), 1)
[1] "A test of a connection"
> z2 <- readBin(zz, character(), 1)
> if(.Machine$sizeof.long == 8 || .Machine$sizeof.longlong == 8)
+     readBin(zz, integer(), 10,  size = 8)
 [1]       5      25     125     625    3125   15625   78125  390625 1953125
[10] 9765625
> if((s <- .Machine$sizeof.longdouble) > 8)
+     readBin(zz, numeric(), 10, size = s)
 [1] 1.047198 1.096623 1.148381 1.202581 1.259340 1.318778 1.381021 1.446202
 [9] 1.514459 1.585938
> close(zz)
> unlink(zzfil)
> stopifnot(z2 == z)
> 
> ## signed vs unsigned ints
> zzfil <- tempfile("testbin")
> zz <- file(zzfil, "wb")
> x <- as.integer(seq(0, 255, 32))
> writeBin(x, zz, size = 1)
> writeBin(x, zz, size = 1)
> x <- as.integer(seq(0, 60000, 10000))
> writeBin(x, zz, size = 2)
> writeBin(x, zz, size = 2)
> close(zz)
> zz <- file(zzfil, "rb")
> readBin(zz, integer(), 8, size = 1)
[1]    0   32   64   96 -128  -96  -64  -32
> readBin(zz, integer(), 8, size = 1, signed = FALSE)
[1]   0  32  64  96 128 160 192 224
> readBin(zz, integer(), 7, size = 2)
[1]      0  10000  20000  30000 -25536 -15536  -5536
> readBin(zz, integer(), 7, size = 2, signed = FALSE)
[1]     0 10000 20000 30000 40000 50000 60000
> close(zz)
> unlink(zzfil)
> 
> ## use of raw
> z <- writeBin(pi^{1:5}, raw(), size = 4)
> readBin(z, numeric(), 5, size = 4)
[1]   3.141593   9.869604  31.006277  97.409088 306.019684
> z <- writeBin(c("a", "test", "of", "character"), raw())
> readBin(z, character(), 4)
[1] "a"         "test"      "of"        "character"
> 
> 
> 
> cleanEx()
> nameEx("readChar")
> ### * readChar
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: readChar
> ### Title: Transfer Character Strings To and From Connections
> ### Aliases: readChar writeChar
> ### Keywords: file connection
> 
> ### ** Examples
> 
> ## test fixed-length strings
> zzfil <- tempfile("testchar")
> zz <- file(zzfil, "wb")
> x <- c("a", "this will be truncated", "abc")
> nc <- c(3, 10, 3)
> writeChar(x, zz, nc, eos = NULL)
Warning in writeChar(x, zz, nc, eos = NULL) :
  writeChar: more characters requested than are in the string - will zero-pad
> writeChar(x, zz, eos = "\r\n")
> close(zz)
> 
> zz <- file(zzfil, "rb")
> readChar(zz, nc)
Warning in readChar(zz, nc) : truncating string with embedded nuls
[1] "a"          "this will " "abc"       
> readChar(zz, nchar(x)+3) # need to read the terminator explicitly
Warning in readChar(zz, nchar(x) + 3) :
  truncating string with embedded nuls
[1] "a\r\n"                      "this will be truncated\r\n"
[3] "abc\r\n"                   
> close(zz)
> unlink(zzfil)
> 
> 
> 
> cleanEx()
> nameEx("readLines")
> ### * readLines
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: readLines
> ### Title: Read Text Lines from a Connection
> ### Aliases: readLines
> ### Keywords: file connection
> 
> ### ** Examples
> 
> fil <- tempfile(fileext = ".data")
> cat("TITLE extra line", "2 3 5 7", "", "11 13 17", file = fil,
+     sep = "\n")
> readLines(fil, n = -1)
[1] "TITLE extra line" "2 3 5 7"          ""                 "11 13 17"        
> unlink(fil) # tidy up
> 
> ## difference in blocking
> fil <- tempfile("test")
> cat("123\nabc", file = fil)
> readLines(fil) # line with a warning
Warning in readLines(fil) :
  incomplete final line found on '/tmp/Rtmptzw2rA/test3d8269c83a7'
[1] "123" "abc"
> 
> con <- file(fil, "r", blocking = FALSE)
> readLines(con) # empty
[1] "123"
> cat(" def\n", file = fil, append = TRUE)
> readLines(con) # gets both
[1] "abc def"
> close(con)
> 
> unlink(fil) # tidy up
> 
> ## Not run: 
> ##D # read a 'Windows Unicode' file
> ##D A <- readLines(con <- file("Unicode.txt", encoding = "UCS-2LE"))
> ##D close(con)
> ##D unique(Encoding(A)) # will most likely be UTF-8
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("readRDS")
> ### * readRDS
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: readRDS
> ### Title: Serialization Interface for Single Objects
> ### Aliases: readRDS saveRDS infoRDS
> ### Keywords: file connection
> 
> ### ** Examples
> 
> fil <- tempfile("women", fileext = ".rds")
> ## save a single object to file
> saveRDS(women, fil)
> ## restore it under a different name
> women2 <- readRDS(fil)
> identical(women, women2)
[1] TRUE
> ## or examine the object via a connection, which will be opened as needed.
> con <- gzfile(fil)
> readRDS(con)
   height weight
1      58    115
2      59    117
3      60    120
4      61    123
5      62    126
6      63    129
7      64    132
8      65    135
9      66    139
10     67    142
11     68    146
12     69    150
13     70    154
14     71    159
15     72    164
> close(con)
> 
> ## Less convenient ways to restore the object
> ## which demonstrate compatibility with unserialize()
> con <- gzfile(fil, "rb")
> identical(unserialize(con), women)
[1] TRUE
> close(con)
> con <- gzfile(fil, "rb")
> wm <- readBin(con, "raw", n = 1e4) # size is a guess
> close(con)
> identical(unserialize(wm), women)
[1] TRUE
> 
> ## Format compatibility with serialize():
> fil2 <- tempfile("women")
> con <- file(fil2, "w")
> serialize(women, con) # ASCII, uncompressed
NULL
> close(con)
> identical(women, readRDS(fil2))
[1] TRUE
> fil3 <- tempfile("women")
> con <- bzfile(fil3, "w")
> serialize(women, con) # binary, bzip2-compressed
NULL
> close(con)
> identical(women, readRDS(fil3))
[1] TRUE
> 
> unlink(c(fil, fil2, fil3))
> 
> 
> 
> cleanEx()
> nameEx("readRenviron")
> ### * readRenviron
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: readRenviron
> ### Title: Set Environment Variables from a File
> ### Aliases: readRenviron
> ### Keywords: file
> 
> ### ** Examples
> ## Not run: 
> ##D ## re-read a startup file (or read it in a vanilla session)
> ##D readRenviron("~/.Renviron")
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("readline")
> ### * readline
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: readline
> ### Title: Read a Line from the Terminal
> ### Aliases: readline
> ### Keywords: utilities
> 
> ### ** Examples
> 
> fun <- function() {
+   ANSWER <- readline("Are you a satisfied R user? ")
+   ## a better version would check the answer less cursorily, and
+   ## perhaps re-prompt
+   if (substr(ANSWER, 1, 1) == "n")
+     cat("This is impossible.  YOU LIED!\n")
+   else
+     cat("I knew it.\n")
+ }
> if(interactive()) fun()
> 
> 
> 
> cleanEx()
> nameEx("reg.finalizer")
> ### * reg.finalizer
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: reg.finalizer
> ### Title: Finalization of Objects
> ### Aliases: reg.finalizer finalizer
> ### Keywords: programming environment
> 
> ### ** Examples
> 
> f <- function(e) print("cleaning....")
> g <- function(x){ e <- environment(); reg.finalizer(e, f) }
> g()
NULL
> invisible(gc()) # trigger cleanup
[1] "cleaning...."
> 
> 
> 
> cleanEx()
> nameEx("regmatches")
> ### * regmatches
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: regmatches
> ### Title: Extract or Replace Matched Substrings
> ### Aliases: regmatches regmatches<-
> ### Keywords: character utilities
> 
> ### ** Examples
> 
> x <- c("A and B", "A, B and C", "A, B, C and D", "foobar")
> pattern <- "[[:space:]]*(,|and)[[:space:]]"
> ## Match data from regexpr()
> m <- regexpr(pattern, x)
> regmatches(x, m)
[1] " and " ", "    ", "   
> regmatches(x, m, invert = TRUE)
[[1]]
[1] "A" "B"

[[2]]
[1] "A"       "B and C"

[[3]]
[1] "A"          "B, C and D"

[[4]]
[1] "foobar"

> ## Match data from gregexpr()
> m <- gregexpr(pattern, x)
> regmatches(x, m)
[[1]]
[1] " and "

[[2]]
[1] ", "    " and "

[[3]]
[1] ", "    ", "    " and "

[[4]]
character(0)

> regmatches(x, m, invert = TRUE)
[[1]]
[1] "A" "B"

[[2]]
[1] "A" "B" "C"

[[3]]
[1] "A" "B" "C" "D"

[[4]]
[1] "foobar"

> 
> ## Consider
> x <- "John (fishing, hunting), Paul (hiking, biking)"
> ## Suppose we want to split at the comma (plus spaces) between the
> ## persons, but not at the commas in the parenthesized hobby lists.
> ## One idea is to "blank out" the parenthesized parts to match the
> ## parts to be used for splitting, and extract the persons as the
> ## non-matched parts.
> ## First, match the parenthesized hobby lists.
> m <- gregexpr("\\([^)]*\\)", x)
> ## Create blank strings with given numbers of characters.
> blanks <- function(n) strrep(" ", n)
> ## Create a copy of x with the parenthesized parts blanked out.
> s <- x
> regmatches(s, m) <- Map(blanks, lapply(regmatches(s, m), nchar))
> s
[1] "John                   , Paul                 "
> ## Compute the positions of the split matches (note that we cannot call
> ## strsplit() on x with match data from s).
> m <- gregexpr(", *", s)
> ## And finally extract the non-matched parts.
> regmatches(x, m, invert = TRUE)
[[1]]
[1] "John (fishing, hunting)" "Paul (hiking, biking)"  

> 
> 
> 
> cleanEx()
> nameEx("rep")
> ### * rep
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rep
> ### Title: Replicate Elements of Vectors and Lists
> ### Aliases: rep rep.factor rep.int rep.POSIXct rep.POSIXlt rep.Date
> ###   rep_len
> ### Keywords: manip chron
> 
> ### ** Examples
> 
> rep(1:4, 2)
[1] 1 2 3 4 1 2 3 4
> rep(1:4, each = 2)       # not the same.
[1] 1 1 2 2 3 3 4 4
> rep(1:4, c(2,2,2,2))     # same as second.
[1] 1 1 2 2 3 3 4 4
> rep(1:4, c(2,1,2,1))
[1] 1 1 2 3 3 4
> rep(1:4, each = 2, len = 4)    # first 4 only.
[1] 1 1 2 2
> rep(1:4, each = 2, len = 10)   # 8 integers plus two recycled 1's.
 [1] 1 1 2 2 3 3 4 4 1 1
> rep(1:4, each = 2, times = 3)  # length 24, 3 complete replications
 [1] 1 1 2 2 3 3 4 4 1 1 2 2 3 3 4 4 1 1 2 2 3 3 4 4
> 
> rep(1, 40*(1-.8)) # length 7 on most platforms
[1] 1 1 1 1 1 1 1
> rep(1, 40*(1-.8)+1e-7) # better
[1] 1 1 1 1 1 1 1 1
> 
> ## replicate a list
> fred <- list(happy = 1:10, name = "squash")
> rep(fred, 5)
$happy
 [1]  1  2  3  4  5  6  7  8  9 10

$name
[1] "squash"

$happy
 [1]  1  2  3  4  5  6  7  8  9 10

$name
[1] "squash"

$happy
 [1]  1  2  3  4  5  6  7  8  9 10

$name
[1] "squash"

$happy
 [1]  1  2  3  4  5  6  7  8  9 10

$name
[1] "squash"

$happy
 [1]  1  2  3  4  5  6  7  8  9 10

$name
[1] "squash"

> 
> # date-time objects
> x <- .leap.seconds[1:3]
> rep(x, 2)
[1] "1972-07-01 UTC" "1973-01-01 UTC" "1974-01-01 UTC" "1972-07-01 UTC"
[5] "1973-01-01 UTC" "1974-01-01 UTC"
> rep(as.POSIXlt(x), rep(2, 3))
[1] "1972-07-01 UTC" "1972-07-01 UTC" "1973-01-01 UTC" "1973-01-01 UTC"
[5] "1974-01-01 UTC" "1974-01-01 UTC"
> 
> ## named factor
> x <- factor(LETTERS[1:4]); names(x) <- letters[1:4]
> x
a b c d 
A B C D 
Levels: A B C D
> rep(x, 2)
a b c d a b c d 
A B C D A B C D 
Levels: A B C D
> rep(x, each = 2)
a a b b c c d d 
A A B B C C D D 
Levels: A B C D
> rep.int(x, 2)  # no names
a b c d a b c d 
A B C D A B C D 
Levels: A B C D
> rep_len(x, 10)
a b c d a b c d a b 
A B C D A B C D A B 
Levels: A B C D
> 
> 
> 
> cleanEx()
> nameEx("rev")
> ### * rev
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rev
> ### Title: Reverse Elements
> ### Aliases: rev rev.default
> ### Keywords: manip
> 
> ### ** Examples
> 
> x <- c(1:5, 5:3)
> ## sort into descending order; first more efficiently:
> stopifnot(sort(x, decreasing = TRUE) == rev(sort(x)))
> stopifnot(rev(1:7) == 7:1)  #- don't need 'rev' here
> 
> 
> 
> cleanEx()
> nameEx("rle")
> ### * rle
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rle
> ### Title: Run Length Encoding
> ### Aliases: rle inverse.rle print.rle
> ### Keywords: manip
> 
> ### ** Examples
> 
> x <- rev(rep(6:10, 1:5))
> rle(x)
Run Length Encoding
  lengths: int [1:5] 5 4 3 2 1
  values : int [1:5] 10 9 8 7 6
> ## lengths [1:5]  5 4 3 2 1
> ## values  [1:5] 10 9 8 7 6
> 
> z <- c(TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, TRUE, TRUE, TRUE)
> rle(z)
Run Length Encoding
  lengths: int [1:5] 2 2 1 1 3
  values : logi [1:5] TRUE FALSE TRUE FALSE TRUE
> rle(as.character(z))
Run Length Encoding
  lengths: int [1:5] 2 2 1 1 3
  values : chr [1:5] "TRUE" "FALSE" "TRUE" "FALSE" "TRUE"
> print(rle(z), prefix = "..| ")
..| Run Length Encoding
..|   lengths: int [1:5] 2 2 1 1 3
..|   values : logi [1:5] TRUE FALSE TRUE FALSE TRUE
> 
> N <- integer(0)
> stopifnot(x == inverse.rle(rle(x)),
+           identical(N, inverse.rle(rle(N))),
+           z == inverse.rle(rle(z)))
> 
> 
> 
> cleanEx()
> nameEx("rm")
> ### * rm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: remove
> ### Title: Remove Objects from a Specified Environment
> ### Aliases: rm remove
> ### Keywords: environment
> 
> ### ** Examples
> 
> tmp <- 1:4
> ## work with tmp  and cleanup
> rm(tmp)
> 
> ## Not run: 
> ##D ## remove (almost) everything in the working environment.
> ##D ## You will get no warning, so don't do this unless you are really sure.
> ##D rm(list = ls())
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("round.POSIXt")
> ### * round.POSIXt
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: round.POSIXt
> ### Title: Round / Truncate Data-Time Objects
> ### Aliases: round.POSIXt trunc.POSIXt round.Date trunc.Date
> ### Keywords: chron
> 
> ### ** Examples
> 
> round(.leap.seconds + 1000, "hour")
 [1] "1972-07-01 UTC" "1973-01-01 UTC" "1974-01-01 UTC" "1975-01-01 UTC"
 [5] "1976-01-01 UTC" "1977-01-01 UTC" "1978-01-01 UTC" "1979-01-01 UTC"
 [9] "1980-01-01 UTC" "1981-07-01 UTC" "1982-07-01 UTC" "1983-07-01 UTC"
[13] "1985-07-01 UTC" "1988-01-01 UTC" "1990-01-01 UTC" "1991-01-01 UTC"
[17] "1992-07-01 UTC" "1993-07-01 UTC" "1994-07-01 UTC" "1996-01-01 UTC"
[21] "1997-07-01 UTC" "1999-01-01 UTC" "2006-01-01 UTC" "2009-01-01 UTC"
[25] "2012-07-01 UTC" "2015-07-01 UTC" "2017-01-01 UTC"
> 
> 
> 
> cleanEx()
> nameEx("row")
> ### * row
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: row
> ### Title: Row Indexes
> ### Aliases: row .row
> ### Keywords: array
> 
> ### ** Examples
> 
> x <- matrix(1:12, 3, 4)
> # extract the diagonal of a matrix - more slowly than diag(x)
> dx <- x[row(x) == col(x)]
> dx
[1] 1 5 9
> 
> # create an identity 5-by-5 matrix more slowly than diag(n = 5):
> x <- matrix(0, nrow = 5, ncol = 5)
> x[row(x) == col(x)] <- 1
> x
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    0    0    0    0
[2,]    0    1    0    0    0
[3,]    0    0    1    0    0
[4,]    0    0    0    1    0
[5,]    0    0    0    0    1
> 
> (i34 <- .row(3:4))
     [,1] [,2] [,3] [,4]
[1,]    1    1    1    1
[2,]    2    2    2    2
[3,]    3    3    3    3
> stopifnot(identical(i34, .row(c(3,4)))) # 'dim' maybe "double"
> 
> 
> 
> cleanEx()
> nameEx("row.names")
> ### * row.names
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: row.names
> ### Title: Get and Set Row Names for Data Frames
> ### Aliases: row.names row.names.data.frame row.names.default row.names<-
> ###   row.names<-.data.frame row.names<-.default .rowNamesDF<-
> ### Keywords: classes methods
> 
> ### ** Examples
> 
> ## To illustrate the note:
> df <- data.frame(x = c(TRUE, FALSE, NA, NA), y = c(12, 34, 56, 78))
> row.names(df) <- 1 : 4
> attr(df, "row.names")
[1] 1 2 3 4
> deparse(df)
[1] "structure(list(x = c(TRUE, FALSE, NA, NA), y = c(12, 34, 56, "
[2] "78)), class = \"data.frame\", row.names = c(NA, 4L))"         
> ## (Compact storage, not regarded as automatic.)
> row.names(df) <- NULL
> attr(df, "row.names")
[1] 1 2 3 4
> deparse(df)
[1] "structure(list(x = c(TRUE, FALSE, NA, NA), y = c(12, 34, 56, "
[2] "78)), class = \"data.frame\", row.names = c(NA, -4L))"        
> ## (Compact storage, regarded as automatic.)
> 
> 
> 
> cleanEx()
> nameEx("rowsum")
> ### * rowsum
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rowsum
> ### Title: Give Column Sums of a Matrix or Data Frame, Based on a Grouping
> ###   Variable
> ### Aliases: rowsum rowsum.default rowsum.data.frame
> ### Keywords: manip
> 
> ### ** Examples
> 
> require(stats)
> 
> x <- matrix(runif(100), ncol = 5)
> group <- sample(1:8, 20, TRUE)
> (xsum <- rowsum(x, group))
       [,1]      [,2]      [,3]      [,4]      [,5]
1 1.5991081 1.3355949 1.9780816 1.2919629 0.7141450
2 1.2675407 1.4958401 0.1701452 1.3685496 1.5762235
3 1.6789289 0.6014849 0.9567314 0.7366730 1.0523723
4 0.6376326 1.1468478 1.4680065 1.2064793 1.1471742
5 1.1000716 0.6533348 1.3190758 0.9088872 0.9597794
6 1.8223467 0.9798800 1.1288575 2.0607036 1.6028944
7 1.3272066 1.0950363 1.3621603 1.6570585 1.0096850
8 1.6705071 2.1696246 1.7612095 2.1007259 1.6661391
> ## Slower versions
> tapply(x, list(group[row(x)], col(x)), sum)
          1         2         3         4         5
1 1.5991081 1.3355949 1.9780816 1.2919629 0.7141450
2 1.2675407 1.4958401 0.1701452 1.3685496 1.5762235
3 1.6789289 0.6014849 0.9567314 0.7366730 1.0523723
4 0.6376326 1.1468478 1.4680065 1.2064793 1.1471742
5 1.1000716 0.6533348 1.3190758 0.9088872 0.9597794
6 1.8223467 0.9798800 1.1288575 2.0607036 1.6028944
7 1.3272066 1.0950363 1.3621603 1.6570585 1.0096850
8 1.6705071 2.1696246 1.7612095 2.1007259 1.6661391
> t(sapply(split(as.data.frame(x), group), colSums))
         V1        V2        V3        V4        V5
1 1.5991081 1.3355949 1.9780816 1.2919629 0.7141450
2 1.2675407 1.4958401 0.1701452 1.3685496 1.5762235
3 1.6789289 0.6014849 0.9567314 0.7366730 1.0523723
4 0.6376326 1.1468478 1.4680065 1.2064793 1.1471742
5 1.1000716 0.6533348 1.3190758 0.9088872 0.9597794
6 1.8223467 0.9798800 1.1288575 2.0607036 1.6028944
7 1.3272066 1.0950363 1.3621603 1.6570585 1.0096850
8 1.6705071 2.1696246 1.7612095 2.1007259 1.6661391
> aggregate(x, list(group), sum)[-1]
         V1        V2        V3        V4        V5
1 1.5991081 1.3355949 1.9780816 1.2919629 0.7141450
2 1.2675407 1.4958401 0.1701452 1.3685496 1.5762235
3 1.6789289 0.6014849 0.9567314 0.7366730 1.0523723
4 0.6376326 1.1468478 1.4680065 1.2064793 1.1471742
5 1.1000716 0.6533348 1.3190758 0.9088872 0.9597794
6 1.8223467 0.9798800 1.1288575 2.0607036 1.6028944
7 1.3272066 1.0950363 1.3621603 1.6570585 1.0096850
8 1.6705071 2.1696246 1.7612095 2.1007259 1.6661391
> 
> 
> 
> cleanEx()
> nameEx("sQuote")
> ### * sQuote
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sQuote
> ### Title: Quote Text
> ### Aliases: sQuote dQuote
> ### Keywords: character
> 
> ### ** Examples
> 
> op <- options("useFancyQuotes")
> paste("argument", sQuote("x"), "must be non-zero")
[1] "argument ‘x’ must be non-zero"
> options(useFancyQuotes = FALSE)
> cat("\ndistinguish plain", sQuote("single"), "and",
+     dQuote("double"), "quotes\n")

distinguish plain 'single' and "double" quotes
> options(useFancyQuotes = TRUE)
> cat("\ndistinguish fancy", sQuote("single"), "and",
+     dQuote("double"), "quotes\n")

distinguish fancy ‘single’ and “double” quotes
> options(useFancyQuotes = "TeX")
> cat("\ndistinguish TeX", sQuote("single"), "and",
+     dQuote("double"), "quotes\n")

distinguish TeX `single' and ``double'' quotes
> if(l10n_info()$`Latin-1`) {
+     options(useFancyQuotes = c("\xab", "\xbb", "\xbf", "?"))
+     cat("\n", sQuote("guillemet"), "and",
+         dQuote("Spanish question"), "styles\n")
+ } else if(l10n_info()$`UTF-8`) {
+     options(useFancyQuotes = c("\xc2\xab", "\xc2\xbb", "\xc2\xbf", "?"))
+     cat("\n", sQuote("guillemet"), "and",
+         dQuote("Spanish question"), "styles\n")
+ }

 «guillemet» and ¿Spanish question? styles
> options(op)
> 
> 
> 
> cleanEx()
> nameEx("sample")
> ### * sample
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sample
> ### Title: Random Samples and Permutations
> ### Aliases: sample sample.int
> ### Keywords: distribution
> 
> ### ** Examples
> 
> x <- 1:12
> # a random permutation
> sample(x)
 [1]  9  4  7  1  2  5  3  8  6 11 12 10
> # bootstrap resampling -- only if length(x) > 1 !
> sample(x, replace = TRUE)
 [1]  5 10  6 10  7  9  5  5  9  9  5  5
> 
> # 100 Bernoulli trials
> sample(c(0,1), 100, replace = TRUE)
  [1] 1 1 1 0 1 0 0 1 0 1 1 1 1 0 1 1 1 1 1 0 0 1 0 1 1 0 0 1 1 1 0 0 1 1 1 1 1
 [38] 1 0 1 1 1 1 0 0 0 1 1 0 0 1 1 1 0 0 0 1 0 1 0 1 0 0 1 1 0 0 0 1 1 0 1 1 1
 [75] 0 0 0 0 1 0 0 0 0 0 1 1 1 1 0 1 1 1 1 0 0 1 0 0 1 1
> 
> ## More careful bootstrapping --  Consider this when using sample()
> ## programmatically (i.e., in your function or simulation)!
> 
> # sample()'s surprise -- example
> x <- 1:10
>     sample(x[x >  8]) # length 2
[1]  9 10
>     sample(x[x >  9]) # oops -- length 10!
 [1] 10  8  2  5  4  7  6  9  3  1
>     sample(x[x > 10]) # length 0
integer(0)
> 
> ## safer version:
> resample <- function(x, ...) x[sample.int(length(x), ...)]
> resample(x[x >  8]) # length 2
[1]  9 10
> resample(x[x >  9]) # length 1
[1] 10
> resample(x[x > 10]) # length 0
integer(0)
> 
> ## R 3.x.y only
> sample.int(1e10, 12, replace = TRUE)
 [1] 6569661254 1916585902 1774325846 1634264380 7477893878 1261514999
 [7] 6831414337 5073110210 9144648098 2789930000 6489522676 1794693792
> sample.int(1e10, 12) # not that there is much chance of duplicates
 [1]  564551647 1675407500 6678212092 5611164688 9202395713 4049978129
 [7]  467287916 3017026112 3241451220 4562164714  727141493 1104490086
> 
> 
> 
> cleanEx()
> nameEx("save")
> ### * save
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: save
> ### Title: Save R Objects
> ### Aliases: save save.image
> ### Keywords: file
> 
> ### ** Examples
> 
> ## Don't show: 
> oldwd <- setwd(tempdir()) # so examples do write there
> ## End(Don't show)
> x <- stats::runif(20)
> y <- list(a = 1, b = TRUE, c = "oops")
> save(x, y, file = "xy.RData")
> save.image() # creating ".RData" in current working directory
> unlink("xy.RData")
> 
> # set save defaults using option:
> options(save.defaults = list(ascii = TRUE, safe = FALSE))
> save.image() # creating ".RData"
> if(interactive()) withAutoprint({
+    file.info(".RData")
+    readLines(".RData", n = 7) # first 7 lines; first starts w/ "RDA"..
+ })
> unlink(".RData")
> ## Don't show: 
> setwd(oldwd)
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("scale")
> ### * scale
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: scale
> ### Title: Scaling and Centering of Matrix-like Objects
> ### Aliases: scale scale.default
> ### Keywords: array
> 
> ### ** Examples
> 
> require(stats)
> x <- matrix(1:10, ncol = 2)
> (centered.x <- scale(x, scale = FALSE))
     [,1] [,2]
[1,]   -2   -2
[2,]   -1   -1
[3,]    0    0
[4,]    1    1
[5,]    2    2
attr(,"scaled:center")
[1] 3 8
> cov(centered.scaled.x <- scale(x)) # all 1
     [,1] [,2]
[1,]    1    1
[2,]    1    1
> 
> 
> 
> cleanEx()
> nameEx("scan")
> ### * scan
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: scan
> ### Title: Read Data Values
> ### Aliases: scan
> ### Keywords: file connection
> 
> ### ** Examples
> 
> cat("TITLE extra line", "2 3 5 7", "11 13 17", file = "ex.data", sep = "\n")
> pp <- scan("ex.data", skip = 1, quiet = TRUE)
> scan("ex.data", skip = 1)
Read 7 items
[1]  2  3  5  7 11 13 17
> scan("ex.data", skip = 1, nlines = 1) # only 1 line after the skipped one
Read 4 items
[1] 2 3 5 7
> scan("ex.data", what = list("","","")) # flush is F -> read "7"
Warning in scan("ex.data", what = list("", "", "")) :
  number of items read is not a multiple of the number of columns
Read 4 records
[[1]]
[1] "TITLE" "2"     "7"     "17"   

[[2]]
[1] "extra" "3"     "11"    ""     

[[3]]
[1] "line" "5"    "13"   ""    

> scan("ex.data", what = list("","",""), flush = TRUE)
Read 3 records
[[1]]
[1] "TITLE" "2"     "11"   

[[2]]
[1] "extra" "3"     "13"   

[[3]]
[1] "line" "5"    "17"  

> unlink("ex.data") # tidy up
> 
> ## "inline" usage
> scan(text = "1 2 3")
Read 3 items
[1] 1 2 3
> 
> 
> 
> 
> cleanEx()
> nameEx("search")
> ### * search
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: search
> ### Title: Give Search Path for R Objects
> ### Aliases: search searchpaths .rmpkg
> ### Keywords: data
> 
> ### ** Examples
> 
> search()
 [1] ".GlobalEnv"        "CheckExEnv"        "package:stats"    
 [4] "package:graphics"  "package:grDevices" "package:utils"    
 [7] "package:datasets"  "package:methods"   "Autoloads"        
[10] "package:base"     
> searchpaths()
 [1] ".GlobalEnv"                         "CheckExEnv"                        
 [3] "/usr/local/lib/R/library/stats"     "/usr/local/lib/R/library/graphics" 
 [5] "/usr/local/lib/R/library/grDevices" "/usr/local/lib/R/library/utils"    
 [7] "/usr/local/lib/R/library/datasets"  "/usr/local/lib/R/library/methods"  
 [9] "Autoloads"                          "/usr/local/lib/R/library/base"     
> 
> 
> 
> cleanEx()
> nameEx("seq.Date")
> ### * seq.Date
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: seq.Date
> ### Title: Generate Regular Sequences of Dates
> ### Aliases: seq.Date
> ### Keywords: manip chron
> 
> ### ** Examples
> 
> ## first days of years
> seq(as.Date("1910/1/1"), as.Date("1999/1/1"), "years")
 [1] "1910-01-01" "1911-01-01" "1912-01-01" "1913-01-01" "1914-01-01"
 [6] "1915-01-01" "1916-01-01" "1917-01-01" "1918-01-01" "1919-01-01"
[11] "1920-01-01" "1921-01-01" "1922-01-01" "1923-01-01" "1924-01-01"
[16] "1925-01-01" "1926-01-01" "1927-01-01" "1928-01-01" "1929-01-01"
[21] "1930-01-01" "1931-01-01" "1932-01-01" "1933-01-01" "1934-01-01"
[26] "1935-01-01" "1936-01-01" "1937-01-01" "1938-01-01" "1939-01-01"
[31] "1940-01-01" "1941-01-01" "1942-01-01" "1943-01-01" "1944-01-01"
[36] "1945-01-01" "1946-01-01" "1947-01-01" "1948-01-01" "1949-01-01"
[41] "1950-01-01" "1951-01-01" "1952-01-01" "1953-01-01" "1954-01-01"
[46] "1955-01-01" "1956-01-01" "1957-01-01" "1958-01-01" "1959-01-01"
[51] "1960-01-01" "1961-01-01" "1962-01-01" "1963-01-01" "1964-01-01"
[56] "1965-01-01" "1966-01-01" "1967-01-01" "1968-01-01" "1969-01-01"
[61] "1970-01-01" "1971-01-01" "1972-01-01" "1973-01-01" "1974-01-01"
[66] "1975-01-01" "1976-01-01" "1977-01-01" "1978-01-01" "1979-01-01"
[71] "1980-01-01" "1981-01-01" "1982-01-01" "1983-01-01" "1984-01-01"
[76] "1985-01-01" "1986-01-01" "1987-01-01" "1988-01-01" "1989-01-01"
[81] "1990-01-01" "1991-01-01" "1992-01-01" "1993-01-01" "1994-01-01"
[86] "1995-01-01" "1996-01-01" "1997-01-01" "1998-01-01" "1999-01-01"
> ## by month
> seq(as.Date("2000/1/1"), by = "month", length.out = 12)
 [1] "2000-01-01" "2000-02-01" "2000-03-01" "2000-04-01" "2000-05-01"
 [6] "2000-06-01" "2000-07-01" "2000-08-01" "2000-09-01" "2000-10-01"
[11] "2000-11-01" "2000-12-01"
> ## quarters
> seq(as.Date("2000/1/1"), as.Date("2003/1/1"), by = "quarter")
 [1] "2000-01-01" "2000-04-01" "2000-07-01" "2000-10-01" "2001-01-01"
 [6] "2001-04-01" "2001-07-01" "2001-10-01" "2002-01-01" "2002-04-01"
[11] "2002-07-01" "2002-10-01" "2003-01-01"
> 
> ## find all 7th of the month between two dates, the last being a 7th.
> st <- as.Date("1998-12-17")
> en <- as.Date("2000-1-7")
> ll <- seq(en, st, by = "-1 month")
> rev(ll[ll > st & ll < en])
 [1] "1999-01-07" "1999-02-07" "1999-03-07" "1999-04-07" "1999-05-07"
 [6] "1999-06-07" "1999-07-07" "1999-08-07" "1999-09-07" "1999-10-07"
[11] "1999-11-07" "1999-12-07"
> 
> 
> 
> cleanEx()
> nameEx("seq.POSIXt")
> ### * seq.POSIXt
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: seq.POSIXt
> ### Title: Generate Regular Sequences of Times
> ### Aliases: seq.POSIXt
> ### Keywords: manip chron
> 
> ### ** Examples
> 
> ## first days of years
> seq(ISOdate(1910,1,1), ISOdate(1999,1,1), "years")
 [1] "1910-01-01 12:00:00 GMT" "1911-01-01 12:00:00 GMT"
 [3] "1912-01-01 12:00:00 GMT" "1913-01-01 12:00:00 GMT"
 [5] "1914-01-01 12:00:00 GMT" "1915-01-01 12:00:00 GMT"
 [7] "1916-01-01 12:00:00 GMT" "1917-01-01 12:00:00 GMT"
 [9] "1918-01-01 12:00:00 GMT" "1919-01-01 12:00:00 GMT"
[11] "1920-01-01 12:00:00 GMT" "1921-01-01 12:00:00 GMT"
[13] "1922-01-01 12:00:00 GMT" "1923-01-01 12:00:00 GMT"
[15] "1924-01-01 12:00:00 GMT" "1925-01-01 12:00:00 GMT"
[17] "1926-01-01 12:00:00 GMT" "1927-01-01 12:00:00 GMT"
[19] "1928-01-01 12:00:00 GMT" "1929-01-01 12:00:00 GMT"
[21] "1930-01-01 12:00:00 GMT" "1931-01-01 12:00:00 GMT"
[23] "1932-01-01 12:00:00 GMT" "1933-01-01 12:00:00 GMT"
[25] "1934-01-01 12:00:00 GMT" "1935-01-01 12:00:00 GMT"
[27] "1936-01-01 12:00:00 GMT" "1937-01-01 12:00:00 GMT"
[29] "1938-01-01 12:00:00 GMT" "1939-01-01 12:00:00 GMT"
[31] "1940-01-01 12:00:00 GMT" "1941-01-01 12:00:00 GMT"
[33] "1942-01-01 12:00:00 GMT" "1943-01-01 12:00:00 GMT"
[35] "1944-01-01 12:00:00 GMT" "1945-01-01 12:00:00 GMT"
[37] "1946-01-01 12:00:00 GMT" "1947-01-01 12:00:00 GMT"
[39] "1948-01-01 12:00:00 GMT" "1949-01-01 12:00:00 GMT"
[41] "1950-01-01 12:00:00 GMT" "1951-01-01 12:00:00 GMT"
[43] "1952-01-01 12:00:00 GMT" "1953-01-01 12:00:00 GMT"
[45] "1954-01-01 12:00:00 GMT" "1955-01-01 12:00:00 GMT"
[47] "1956-01-01 12:00:00 GMT" "1957-01-01 12:00:00 GMT"
[49] "1958-01-01 12:00:00 GMT" "1959-01-01 12:00:00 GMT"
[51] "1960-01-01 12:00:00 GMT" "1961-01-01 12:00:00 GMT"
[53] "1962-01-01 12:00:00 GMT" "1963-01-01 12:00:00 GMT"
[55] "1964-01-01 12:00:00 GMT" "1965-01-01 12:00:00 GMT"
[57] "1966-01-01 12:00:00 GMT" "1967-01-01 12:00:00 GMT"
[59] "1968-01-01 12:00:00 GMT" "1969-01-01 12:00:00 GMT"
[61] "1970-01-01 12:00:00 GMT" "1971-01-01 12:00:00 GMT"
[63] "1972-01-01 12:00:00 GMT" "1973-01-01 12:00:00 GMT"
[65] "1974-01-01 12:00:00 GMT" "1975-01-01 12:00:00 GMT"
[67] "1976-01-01 12:00:00 GMT" "1977-01-01 12:00:00 GMT"
[69] "1978-01-01 12:00:00 GMT" "1979-01-01 12:00:00 GMT"
[71] "1980-01-01 12:00:00 GMT" "1981-01-01 12:00:00 GMT"
[73] "1982-01-01 12:00:00 GMT" "1983-01-01 12:00:00 GMT"
[75] "1984-01-01 12:00:00 GMT" "1985-01-01 12:00:00 GMT"
[77] "1986-01-01 12:00:00 GMT" "1987-01-01 12:00:00 GMT"
[79] "1988-01-01 12:00:00 GMT" "1989-01-01 12:00:00 GMT"
[81] "1990-01-01 12:00:00 GMT" "1991-01-01 12:00:00 GMT"
[83] "1992-01-01 12:00:00 GMT" "1993-01-01 12:00:00 GMT"
[85] "1994-01-01 12:00:00 GMT" "1995-01-01 12:00:00 GMT"
[87] "1996-01-01 12:00:00 GMT" "1997-01-01 12:00:00 GMT"
[89] "1998-01-01 12:00:00 GMT" "1999-01-01 12:00:00 GMT"
> ## by month
> seq(ISOdate(2000,1,1), by = "month", length.out = 12)
 [1] "2000-01-01 12:00:00 GMT" "2000-02-01 12:00:00 GMT"
 [3] "2000-03-01 12:00:00 GMT" "2000-04-01 12:00:00 GMT"
 [5] "2000-05-01 12:00:00 GMT" "2000-06-01 12:00:00 GMT"
 [7] "2000-07-01 12:00:00 GMT" "2000-08-01 12:00:00 GMT"
 [9] "2000-09-01 12:00:00 GMT" "2000-10-01 12:00:00 GMT"
[11] "2000-11-01 12:00:00 GMT" "2000-12-01 12:00:00 GMT"
> seq(ISOdate(2000,1,31), by = "month", length.out = 4)
[1] "2000-01-31 12:00:00 GMT" "2000-03-02 12:00:00 GMT"
[3] "2000-03-31 12:00:00 GMT" "2000-05-01 12:00:00 GMT"
> ## quarters
> seq(ISOdate(1990,1,1), ISOdate(2000,1,1), by = "quarter") # or "3 months"
 [1] "1990-01-01 12:00:00 GMT" "1990-04-01 12:00:00 GMT"
 [3] "1990-07-01 12:00:00 GMT" "1990-10-01 12:00:00 GMT"
 [5] "1991-01-01 12:00:00 GMT" "1991-04-01 12:00:00 GMT"
 [7] "1991-07-01 12:00:00 GMT" "1991-10-01 12:00:00 GMT"
 [9] "1992-01-01 12:00:00 GMT" "1992-04-01 12:00:00 GMT"
[11] "1992-07-01 12:00:00 GMT" "1992-10-01 12:00:00 GMT"
[13] "1993-01-01 12:00:00 GMT" "1993-04-01 12:00:00 GMT"
[15] "1993-07-01 12:00:00 GMT" "1993-10-01 12:00:00 GMT"
[17] "1994-01-01 12:00:00 GMT" "1994-04-01 12:00:00 GMT"
[19] "1994-07-01 12:00:00 GMT" "1994-10-01 12:00:00 GMT"
[21] "1995-01-01 12:00:00 GMT" "1995-04-01 12:00:00 GMT"
[23] "1995-07-01 12:00:00 GMT" "1995-10-01 12:00:00 GMT"
[25] "1996-01-01 12:00:00 GMT" "1996-04-01 12:00:00 GMT"
[27] "1996-07-01 12:00:00 GMT" "1996-10-01 12:00:00 GMT"
[29] "1997-01-01 12:00:00 GMT" "1997-04-01 12:00:00 GMT"
[31] "1997-07-01 12:00:00 GMT" "1997-10-01 12:00:00 GMT"
[33] "1998-01-01 12:00:00 GMT" "1998-04-01 12:00:00 GMT"
[35] "1998-07-01 12:00:00 GMT" "1998-10-01 12:00:00 GMT"
[37] "1999-01-01 12:00:00 GMT" "1999-04-01 12:00:00 GMT"
[39] "1999-07-01 12:00:00 GMT" "1999-10-01 12:00:00 GMT"
[41] "2000-01-01 12:00:00 GMT"
> ## days vs DSTdays: use c() to lose the time zone.
> seq(c(ISOdate(2000,3,20)), by = "day", length.out = 10)
 [1] "2000-03-20 12:00:00 UTC" "2000-03-21 12:00:00 UTC"
 [3] "2000-03-22 12:00:00 UTC" "2000-03-23 12:00:00 UTC"
 [5] "2000-03-24 12:00:00 UTC" "2000-03-25 12:00:00 UTC"
 [7] "2000-03-26 12:00:00 UTC" "2000-03-27 12:00:00 UTC"
 [9] "2000-03-28 12:00:00 UTC" "2000-03-29 12:00:00 UTC"
> seq(c(ISOdate(2000,3,20)), by = "DSTday", length.out = 10)
 [1] "2000-03-20 12:00:00 UTC" "2000-03-21 12:00:00 UTC"
 [3] "2000-03-22 12:00:00 UTC" "2000-03-23 12:00:00 UTC"
 [5] "2000-03-24 12:00:00 UTC" "2000-03-25 12:00:00 UTC"
 [7] "2000-03-26 12:00:00 UTC" "2000-03-27 12:00:00 UTC"
 [9] "2000-03-28 12:00:00 UTC" "2000-03-29 12:00:00 UTC"
> seq(c(ISOdate(2000,3,20)), by = "7 DSTdays", length.out = 4)
[1] "2000-03-20 12:00:00 UTC" "2000-03-27 12:00:00 UTC"
[3] "2000-04-03 12:00:00 UTC" "2000-04-10 12:00:00 UTC"
> 
> 
> 
> cleanEx()
> nameEx("seq")
> ### * seq
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: seq
> ### Title: Sequence Generation
> ### Aliases: seq seq.default seq.int seq_along seq_len
> ### Keywords: manip
> 
> ### ** Examples
> 
> seq(0, 1, length.out = 11)
 [1] 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0
> seq(stats::rnorm(20)) # effectively 'along'
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20
> seq(1, 9, by = 2)     # matches 'end'
[1] 1 3 5 7 9
> seq(1, 9, by = pi)    # stays below 'end'
[1] 1.000000 4.141593 7.283185
> seq(1, 6, by = 3)
[1] 1 4
> seq(1.575, 5.125, by = 0.05)
 [1] 1.575 1.625 1.675 1.725 1.775 1.825 1.875 1.925 1.975 2.025 2.075 2.125
[13] 2.175 2.225 2.275 2.325 2.375 2.425 2.475 2.525 2.575 2.625 2.675 2.725
[25] 2.775 2.825 2.875 2.925 2.975 3.025 3.075 3.125 3.175 3.225 3.275 3.325
[37] 3.375 3.425 3.475 3.525 3.575 3.625 3.675 3.725 3.775 3.825 3.875 3.925
[49] 3.975 4.025 4.075 4.125 4.175 4.225 4.275 4.325 4.375 4.425 4.475 4.525
[61] 4.575 4.625 4.675 4.725 4.775 4.825 4.875 4.925 4.975 5.025 5.075 5.125
> seq(17) # same as 1:17, or even better seq_len(17)
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17
> 
> 
> 
> cleanEx()
> nameEx("sequence")
> ### * sequence
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sequence
> ### Title: Create A Vector of Sequences
> ### Aliases: sequence sequence.default
> ### Keywords: manip
> 
> ### ** Examples
> 
> sequence(c(3, 2)) # the concatenated sequences 1:3 and 1:2.
[1] 1 2 3 1 2
> #> [1] 1 2 3 1 2
> sequence(c(3, 2), from=2L)
[1] 2 3 4 2 3
> #> [1] 2 3 4 2 3
> sequence(c(3, 2), from=2L, by=2L)
[1] 2 4 6 2 4
> #> [1] 2 4 6 2 4
> sequence(c(3, 2), by=c(-1L, 1L))
[1]  1  0 -1  1  2
> #> [1] 1 0 -1 1 2
> 
> 
> 
> cleanEx()
> nameEx("serialize")
> ### * serialize
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: serialize
> ### Title: Simple Serialization Interface
> ### Aliases: serialize unserialize
> ### Keywords: file connection
> 
> ### ** Examples
> 
> x <- serialize(list(1,2,3), NULL)
> unserialize(x)
[[1]]
[1] 1

[[2]]
[1] 2

[[3]]
[1] 3

> 
> ## see also the examples for saveRDS
> 
> 
> 
> cleanEx()
> nameEx("sets")
> ### * sets
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sets
> ### Title: Set Operations
> ### Aliases: union intersect setdiff is.element setequal intersection
> ### Keywords: misc
> 
> ### ** Examples
> 
> (x <- c(sort(sample(1:20, 9)), NA))
 [1]  1  2  4  7 11 13 14 17 19 NA
> (y <- c(sort(sample(3:23, 7)), NA))
[1]  3  9 11 12 16 21 23 NA
> union(x, y)
 [1]  1  2  4  7 11 13 14 17 19 NA  3  9 12 16 21 23
> intersect(x, y)
[1] 11 NA
> setdiff(x, y)
[1]  1  2  4  7 13 14 17 19
> setdiff(y, x)
[1]  3  9 12 16 21 23
> setequal(x, y)
[1] FALSE
> 
> ## True for all possible x & y :
> setequal( union(x, y),
+           c(setdiff(x, y), intersect(x, y), setdiff(y, x)))
[1] TRUE
> 
> is.element(x, y) # length 10
 [1] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE
> is.element(y, x) # length  8
[1] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE
> 
> 
> 
> cleanEx()
> nameEx("shQuote")
> ### * shQuote
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: shQuote
> ### Title: Quote Strings for Use in OS Shells
> ### Aliases: shQuote
> ### Keywords: utilities
> 
> ### ** Examples
> 
> test <- "abc$def`gh`i\\j"
> cat(shQuote(test), "\n")
'abc$def`gh`i\j' 
> ## Not run: system(paste("echo", shQuote(test)))
> test <- "don't do it!"
> cat(shQuote(test), "\n")
"don't do it!" 
> 
> tryit <- paste("use the", sQuote("-c"), "switch\nlike this")
> cat(shQuote(tryit), "\n")
'use the ‘-c’ switch
like this' 
> ## Not run: system(paste("echo", shQuote(tryit)))
> cat(shQuote(tryit, type = "csh"), "\n")
'use the ‘-c’ switch
like this' 
> 
> ## Windows-only example, assuming cmd.exe:
> perlcmd <- 'print "Hello World\\n";'
> ## Not run: 
> ##D shell(shQuote(paste("perl -e", 
> ##D                     shQuote(perlcmd, type = "cmd")),
> ##D               type = "cmd2"))
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("showConnections")
> ### * showConnections
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: showConnections
> ### Title: Display Connections
> ### Aliases: showConnections getConnection getAllConnections
> ###   closeAllConnections stdin stdout stderr nullfile isatty
> ### Keywords: connection
> 
> ### ** Examples
> 
> showConnections(all = TRUE)
  description class      mode text   isopen   can read can write
0 "stdin"     "terminal" "r"  "text" "opened" "yes"    "no"     
1 "stdout"    "terminal" "w"  "text" "opened" "no"     "yes"    
2 "stderr"    "terminal" "w"  "text" "opened" "no"     "yes"    
> ## Not run: 
> ##D textConnection(letters)
> ##D # oops, I forgot to record that one
> ##D showConnections()
> ##D #  class     description      mode text   isopen   can read can write
> ##D #3 "letters" "textConnection" "r"  "text" "opened" "yes"    "no"
> ##D mycon <- getConnection(3)
> ## End(Not run)
> 
> c(isatty(stdin()), isatty(stdout()), isatty(stderr()))
[1] FALSE FALSE FALSE
> 
> 
> 
> cleanEx()
> nameEx("sign")
> ### * sign
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sign
> ### Title: Sign Function
> ### Aliases: sign
> ### Keywords: arith
> 
> ### ** Examples
> 
> sign(pi)    # == 1
[1] 1
> sign(-2:3)  # -1 -1 0 1 1 1
[1] -1 -1  0  1  1  1
> 
> 
> 
> cleanEx()
> nameEx("sink")
> ### * sink
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sink
> ### Title: Send R Output to a File
> ### Aliases: sink sink.number
> ### Keywords: file connection
> 
> ### ** Examples
> 
> sink("sink-examp.txt")
> i <- 1:10
> outer(i, i, "*")
> sink()
> ## Don't show: 
> unlink("sink-examp.txt")
> ## End(Don't show)
> 
> 
> cleanEx()
> nameEx("slice.index")
> ### * slice.index
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: slice.index
> ### Title: Slice Indexes in an Array
> ### Aliases: slice.index
> ### Keywords: array
> 
> ### ** Examples
> 
> x <- array(1 : 24, c(2, 3, 4))
> slice.index(x, 2)
, , 1

     [,1] [,2] [,3]
[1,]    1    2    3
[2,]    1    2    3

, , 2

     [,1] [,2] [,3]
[1,]    1    2    3
[2,]    1    2    3

, , 3

     [,1] [,2] [,3]
[1,]    1    2    3
[2,]    1    2    3

, , 4

     [,1] [,2] [,3]
[1,]    1    2    3
[2,]    1    2    3

> slice.index(x, c(1, 3))
, , 1

     [,1] [,2] [,3]
[1,]    1    1    1
[2,]    2    2    2

, , 2

     [,1] [,2] [,3]
[1,]    3    3    3
[2,]    4    4    4

, , 3

     [,1] [,2] [,3]
[1,]    5    5    5
[2,]    6    6    6

, , 4

     [,1] [,2] [,3]
[1,]    7    7    7
[2,]    8    8    8

> ## When slicing by dimensions 1 and 3, slice index 5 is obtained for
> ## dimension 1 has value 1 and dimension 3 has value 3 (see above):
> which(slice.index(x, c(1, 3)) == 5, arr.ind = TRUE)
     dim1 dim2 dim3
[1,]    1    1    3
[2,]    1    2    3
[3,]    1    3    3
> 
> 
> 
> cleanEx()
> nameEx("socketSelect")
> ### * socketSelect
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: socketSelect
> ### Title: Wait on Socket Connections
> ### Aliases: socketSelect
> ### Keywords: connection
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ## test whether socket connection s is available for writing or reading
> ##D socketSelect(list(s, s), c(TRUE, FALSE), timeout = 0)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("solve")
> ### * solve
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: solve
> ### Title: Solve a System of Equations
> ### Aliases: solve solve.default
> ### Keywords: algebra
> 
> ### ** Examples
> 
> hilbert <- function(n) { i <- 1:n; 1 / outer(i - 1, i, "+") }
> h8 <- hilbert(8); h8
          [,1]      [,2]      [,3]       [,4]       [,5]       [,6]       [,7]
[1,] 1.0000000 0.5000000 0.3333333 0.25000000 0.20000000 0.16666667 0.14285714
[2,] 0.5000000 0.3333333 0.2500000 0.20000000 0.16666667 0.14285714 0.12500000
[3,] 0.3333333 0.2500000 0.2000000 0.16666667 0.14285714 0.12500000 0.11111111
[4,] 0.2500000 0.2000000 0.1666667 0.14285714 0.12500000 0.11111111 0.10000000
[5,] 0.2000000 0.1666667 0.1428571 0.12500000 0.11111111 0.10000000 0.09090909
[6,] 0.1666667 0.1428571 0.1250000 0.11111111 0.10000000 0.09090909 0.08333333
[7,] 0.1428571 0.1250000 0.1111111 0.10000000 0.09090909 0.08333333 0.07692308
[8,] 0.1250000 0.1111111 0.1000000 0.09090909 0.08333333 0.07692308 0.07142857
           [,8]
[1,] 0.12500000
[2,] 0.11111111
[3,] 0.10000000
[4,] 0.09090909
[5,] 0.08333333
[6,] 0.07692308
[7,] 0.07142857
[8,] 0.06666667
> sh8 <- solve(h8)
> round(sh8 %*% h8, 3)
     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]
[1,]    1    0    0    0    0    0    0    0
[2,]    0    1    0    0    0    0    0    0
[3,]    0    0    1    0    0    0    0    0
[4,]    0    0    0    1    0    0    0    0
[5,]    0    0    0    0    1    0    0    0
[6,]    0    0    0    0    0    1    0    0
[7,]    0    0    0    0    0    0    1    0
[8,]    0    0    0    0    0    0    0    1
> 
> A <- hilbert(4)
> A[] <- as.complex(A)
> ## might not be supported on all platforms
> try(solve(A))
        [,1]     [,2]     [,3]     [,4]
[1,]   16+0i  -120+0i   240+0i  -140+0i
[2,] -120+0i  1200+0i -2700+0i  1680+0i
[3,]  240+0i -2700+0i  6480+0i -4200+0i
[4,] -140+0i  1680+0i -4200+0i  2800+0i
> 
> 
> 
> cleanEx()
> nameEx("sort")
> ### * sort
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sort
> ### Title: Sorting or Ordering Vectors
> ### Aliases: sort sort.default sort.POSIXlt sort.int
> ### Keywords: univar manip arith
> 
> ### ** Examples
> 
> require(stats)
> 
> x <- swiss$Education[1:25]
> x; sort(x); sort(x, partial = c(10, 15))
 [1] 12  9  5  7 15  7  7  8  7 13  6 12  7 12  5  2  8 28 20  9 10  3 12  6  1
 [1]  1  2  3  5  5  6  6  7  7  7  7  7  8  8  9  9 10 12 12 12 12 13 15 20 28
 [1]  3  2  5  5  1  6  6  7  7  7  7  8  7  8  9  9 10 12 12 12 12 20 28 13 15
> 
> ## illustrate 'stable' sorting (of ties):
> sort(c(10:3, 2:12), method = "shell", index.return = TRUE) # is stable
$x
 [1]  2  3  3  4  4  5  5  6  6  7  7  8  8  9  9 10 10 11 12

$ix
 [1]  9  8 10  7 11  6 12  5 13  4 14  3 15  2 16  1 17 18 19

> ## $x : 2  3  3  4  4  5  5  6  6  7  7  8  8  9  9 10 10 11 12
> ## $ix: 9  8 10  7 11  6 12  5 13  4 14  3 15  2 16  1 17 18 19
> sort(c(10:3, 2:12), method = "quick", index.return = TRUE) # is not
$x
 [1]  2  3  3  4  4  5  5  6  6  7  7  8  8  9  9 10 10 11 12

$ix
 [1]  9  8 10 11  7  6 12  5 13  4 14  3 15  2 16 17  1 18 19

> ## $x : 2  3  3  4  4  5  5  6  6  7  7  8  8  9  9 10 10 11 12
> ## $ix: 9 10  8  7 11  6 12  5 13  4 14  3 15 16  2 17  1 18 19
> 
> x <- c(1:3, 3:5, 10)
> is.unsorted(x)                  # FALSE: is sorted
[1] FALSE
> is.unsorted(x, strictly = TRUE) # TRUE : is not (and cannot be)
[1] TRUE
>                                 # sorted strictly
> ## Not run: 
> ##D ## Small speed comparison simulation:
> ##D N <- 2000
> ##D Sim <- 20
> ##D rep <- 1000 # << adjust to your CPU
> ##D c1 <- c2 <- numeric(Sim)
> ##D for(is in seq_len(Sim)){
> ##D   x <- rnorm(N)
> ##D   c1[is] <- system.time(for(i in 1:rep) sort(x, method = "shell"))[1]
> ##D   c2[is] <- system.time(for(i in 1:rep) sort(x, method = "quick"))[1]
> ##D   stopifnot(sort(x, method = "shell") == sort(x, method = "quick"))
> ##D }
> ##D rbind(ShellSort = c1, QuickSort = c2)
> ##D cat("Speedup factor of quick sort():\n")
> ##D summary({qq <- c1 / c2; qq[is.finite(qq)]})
> ##D 
> ##D ## A larger test
> ##D x <- rnorm(1e7)
> ##D system.time(x1 <- sort(x, method = "shell"))
> ##D system.time(x2 <- sort(x, method = "quick"))
> ##D system.time(x3 <- sort(x, method = "radix"))
> ##D stopifnot(identical(x1, x2))
> ##D stopifnot(identical(x1, x3))
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("source")
> ### * source
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: source
> ### Title: Read R Code from a File, a Connection or Expressions
> ### Aliases: source withAutoprint
> ### Keywords: file programming connection
> 
> ### ** Examples
> 
> someCond <- 7 > 6
> ## want an if-clause to behave "as top level" wrt auto-printing :
> ## (all should look "as if on top level", e.g. non-assignments should print:)
> if(someCond) withAutoprint({
+    x <- 1:12
+    x-1
+    (y <- (x-5)^2)
+    z <- y
+    z - 10
+ })
> x <- 1:12
> x - 1
 [1]  0  1  2  3  4  5  6  7  8  9 10 11
> (y <- (x - 5)^2)
 [1] 16  9  4  1  0  1  4  9 16 25 36 49
> z <- y
> z - 10
 [1]   6  -1  -6  -9 -10  -9  -6  -1   6  15  26  39
> 
> ## If you want to source() a bunch of files, something like
> ## the following may be useful:
>  sourceDir <- function(path, trace = TRUE, ...) {
+     for (nm in list.files(path, pattern = "[.][RrSsQq]$")) {
+        if(trace) cat(nm,":")
+        source(file.path(path, nm), ...)
+        if(trace) cat("\n")
+     }
+  }
> 
> suppressWarnings( rm(x,y) ) # remove 'x' or 'y' from global env
> withAutoprint({ x <- 1:2; cat("x=",x,"\n"); y <- x^2 })
> x <- 1:2
> cat("x=", x, "\n")
x= 1 2 
> y <- x^2
> ## x and y now exist:
> stopifnot(identical(x, 1:2), identical(y, x^2))
> 
> withAutoprint({ formals(sourceDir); body(sourceDir) },
+               max.dep = 20, verbose = TRUE)
'envir' chosen:<environment: R_GlobalEnv>

>>>> eval(expression_nr. 1 )
		 =================
> formals(sourceDir)
curr.fun: symbol formals
$path


$trace
[1] TRUE

$...


 .. after ‘expression(formals(sourceDir))’

>>>> eval(expression_nr. 2 )
		 =================
> body(sourceDir)
curr.fun: symbol body
{
    for (nm in list.files(path, pattern = "[.][RrSsQq]$")) {
        if (trace) 
            cat(nm, ":")
        source(file.path(path, nm), ...)
        if (trace) 
            cat("\n")
    }
}
 .. after ‘expression(body(sourceDir))’
> 
> 
> 
> cleanEx()
> nameEx("split")
> ### * split
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: split
> ### Title: Divide into Groups and Reassemble
> ### Aliases: split split.default split.data.frame split<- split<-.default
> ###   split<-.data.frame unsplit
> ### Keywords: category
> 
> ### ** Examples
> 
> require(stats); require(graphics)
> n <- 10; nn <- 100
> g <- factor(round(n * runif(n * nn)))
> x <- rnorm(n * nn) + sqrt(as.numeric(g))
> xg <- split(x, g)
> boxplot(xg, col = "lavender", notch = TRUE, varwidth = TRUE)
> sapply(xg, length)
  0   1   2   3   4   5   6   7   8   9  10 
 43 106  95 103 112 109  82 102  95 100  53 
> sapply(xg, mean)
        0         1         2         3         4         5         6         7 
0.9833875 1.2699407 1.7164450 2.0804985 2.1233521 2.7058793 2.6206885 2.5487239 
        8         9        10 
3.0576218 3.1171584 3.2984077 
> 
> ### Calculate 'z-scores' by group (standardize to mean zero, variance one)
> z <- unsplit(lapply(split(x, g), scale), g)
> 
> # or
> 
> zz <- x
> split(zz, g) <- lapply(split(x, g), scale)
> 
> # and check that the within-group std dev is indeed one
> tapply(z, g, sd)
 0  1  2  3  4  5  6  7  8  9 10 
 1  1  1  1  1  1  1  1  1  1  1 
> tapply(zz, g, sd)
 0  1  2  3  4  5  6  7  8  9 10 
 1  1  1  1  1  1  1  1  1  1  1 
> 
> 
> ### data frame variation
> 
> ## Notice that assignment form is not used since a variable is being added
> 
> g <- airquality$Month
> l <- split(airquality, g)
> l <- lapply(l, transform, Oz.Z = scale(Ozone))
> aq2 <- unsplit(l, g)
> head(aq2)
  Ozone Solar.R Wind Temp Month Day       Oz.Z
1    41     190  7.4   67     5   1  0.7822293
2    36     118  8.0   72     5   2  0.5572518
3    12     149 12.6   74     5   3 -0.5226399
4    18     313 11.5   62     5   4 -0.2526670
5    NA      NA 14.3   56     5   5         NA
6    28      NA 14.9   66     5   6  0.1972879
> with(aq2, tapply(Oz.Z,  Month, sd, na.rm = TRUE))
5 6 7 8 9 
1 1 1 1 1 
> 
> 
> ### Split a matrix into a list by columns
> ma <- cbind(x = 1:10, y = (-4:5)^2)
> split(ma, col(ma))
$`1`
 [1]  1  2  3  4  5  6  7  8  9 10

$`2`
 [1] 16  9  4  1  0  1  4  9 16 25

> 
> split(1:10, 1:2)
$`1`
[1] 1 3 5 7 9

$`2`
[1]  2  4  6  8 10

> 
> 
> 
> cleanEx()
> nameEx("sprintf")
> ### * sprintf
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sprintf
> ### Title: Use C-style String Formatting Commands
> ### Aliases: sprintf gettextf
> ### Keywords: print character
> 
> ### ** Examples
> 
> ## be careful with the format: most things in R are floats
> ## only integer-valued reals get coerced to integer.
> 
> sprintf("%s is %f feet tall\n", "Sven", 7.1)      # OK
[1] "Sven is 7.100000 feet tall\n"
> try(sprintf("%s is %i feet tall\n", "Sven", 7.1)) # not OK
Error in sprintf("%s is %i feet tall\n", "Sven", 7.1) : 
  invalid format '%i'; use format %f, %e, %g or %a for numeric objects
>     sprintf("%s is %i feet tall\n", "Sven", 7  )  # OK
[1] "Sven is 7 feet tall\n"
> 
> ## use a literal % :
> 
> sprintf("%.0f%% said yes (out of a sample of size %.0f)", 66.666, 3)
[1] "67% said yes (out of a sample of size 3)"
> 
> ## various formats of pi :
> 
> sprintf("%f", pi)
[1] "3.141593"
> sprintf("%.3f", pi)
[1] "3.142"
> sprintf("%1.0f", pi)
[1] "3"
> sprintf("%5.1f", pi)
[1] "  3.1"
> sprintf("%05.1f", pi)
[1] "003.1"
> sprintf("%+f", pi)
[1] "+3.141593"
> sprintf("% f", pi)
[1] " 3.141593"
> sprintf("%-10f", pi) # left justified
[1] "3.141593  "
> sprintf("%e", pi)
[1] "3.141593e+00"
> sprintf("%E", pi)
[1] "3.141593E+00"
> sprintf("%g", pi)
[1] "3.14159"
> sprintf("%g",   1e6 * pi) # -> exponential
[1] "3.14159e+06"
> sprintf("%.9g", 1e6 * pi) # -> "fixed"
[1] "3141592.65"
> sprintf("%G", 1e-6 * pi)
[1] "3.14159E-06"
> 
> ## no truncation:
> sprintf("%1.f", 101)
[1] "101"
> 
> ## re-use one argument three times, show difference between %x and %X
> xx <- sprintf("%1$d %1$x %1$X", 0:15)
> xx <- matrix(xx, dimnames = list(rep("", 16), "%d%x%X"))
> noquote(format(xx, justify = "right"))
 %d%x%X
  0 0 0
  1 1 1
  2 2 2
  3 3 3
  4 4 4
  5 5 5
  6 6 6
  7 7 7
  8 8 8
  9 9 9
 10 a A
 11 b B
 12 c C
 13 d D
 14 e E
 15 f F
> 
> ## More sophisticated:
> 
> sprintf("min 10-char string '%10s'",
+         c("a", "ABC", "and an even longer one"))
[1] "min 10-char string '         a'"            
[2] "min 10-char string '       ABC'"            
[3] "min 10-char string 'and an even longer one'"
> 
> 
> n <- 1:18
> sprintf(paste0("e with %2d digits = %.", n, "g"), n, exp(1))
 [1] "e with  1 digits = 3"                  
 [2] "e with  2 digits = 2.7"                
 [3] "e with  3 digits = 2.72"               
 [4] "e with  4 digits = 2.718"              
 [5] "e with  5 digits = 2.7183"             
 [6] "e with  6 digits = 2.71828"            
 [7] "e with  7 digits = 2.718282"           
 [8] "e with  8 digits = 2.7182818"          
 [9] "e with  9 digits = 2.71828183"         
[10] "e with 10 digits = 2.718281828"        
[11] "e with 11 digits = 2.7182818285"       
[12] "e with 12 digits = 2.71828182846"      
[13] "e with 13 digits = 2.718281828459"     
[14] "e with 14 digits = 2.718281828459"     
[15] "e with 15 digits = 2.71828182845905"   
[16] "e with 16 digits = 2.718281828459045"  
[17] "e with 17 digits = 2.7182818284590451" 
[18] "e with 18 digits = 2.71828182845904509"
> 
> ## Using arguments out of order
> sprintf("second %2$1.0f, first %1$5.2f, third %3$1.0f", pi, 2, 3)
[1] "second 2, first  3.14, third 3"
> 
> ## Using asterisk for width or precision
> sprintf("precision %.*f, width '%*.3f'", 3, pi, 8, pi)
[1] "precision 3.142, width '   3.142'"
> 
> ## Asterisk and argument re-use, 'e' example reiterated:
> sprintf("e with %1$2d digits = %2$.*1$g", n, exp(1))
 [1] "e with  1 digits = 3"                  
 [2] "e with  2 digits = 2.7"                
 [3] "e with  3 digits = 2.72"               
 [4] "e with  4 digits = 2.718"              
 [5] "e with  5 digits = 2.7183"             
 [6] "e with  6 digits = 2.71828"            
 [7] "e with  7 digits = 2.718282"           
 [8] "e with  8 digits = 2.7182818"          
 [9] "e with  9 digits = 2.71828183"         
[10] "e with 10 digits = 2.718281828"        
[11] "e with 11 digits = 2.7182818285"       
[12] "e with 12 digits = 2.71828182846"      
[13] "e with 13 digits = 2.718281828459"     
[14] "e with 14 digits = 2.718281828459"     
[15] "e with 15 digits = 2.71828182845905"   
[16] "e with 16 digits = 2.718281828459045"  
[17] "e with 17 digits = 2.7182818284590451" 
[18] "e with 18 digits = 2.71828182845904509"
> 
> ## re-cycle arguments
> sprintf("%s %d", "test", 1:3)
[1] "test 1" "test 2" "test 3"
> 
> ## binary output showing rounding/representation errors
> x <- seq(0, 1.0, 0.1); y <- c(0,.1,.2,.3,.4,.5,.6,.7,.8,.9,1)
> cbind(x, sprintf("%a", x), sprintf("%a", y))
      x                                                  
 [1,] "0"   "0x0p+0"               "0x0p+0"              
 [2,] "0.1" "0x1.999999999999ap-4" "0x1.999999999999ap-4"
 [3,] "0.2" "0x1.999999999999ap-3" "0x1.999999999999ap-3"
 [4,] "0.3" "0x1.3333333333334p-2" "0x1.3333333333333p-2"
 [5,] "0.4" "0x1.999999999999ap-2" "0x1.999999999999ap-2"
 [6,] "0.5" "0x1p-1"               "0x1p-1"              
 [7,] "0.6" "0x1.3333333333334p-1" "0x1.3333333333333p-1"
 [8,] "0.7" "0x1.6666666666667p-1" "0x1.6666666666666p-1"
 [9,] "0.8" "0x1.999999999999ap-1" "0x1.999999999999ap-1"
[10,] "0.9" "0x1.ccccccccccccdp-1" "0x1.ccccccccccccdp-1"
[11,] "1"   "0x1p+0"               "0x1p+0"              
> 
> 
> 
> cleanEx()
> nameEx("srcfile")
> ### * srcfile
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: srcfile
> ### Title: References to Source Files and Code
> ### Aliases: srcfile srcfilecopy getSrcLines srcref srcfile-class
> ###   srcfilecopy-class srcref-class print.srcfile summary.srcfile
> ###   open.srcfile open.srcfilecopy close.srcfile print.srcref
> ###   summary.srcref as.character.srcref .isOpen srcfilealias-class
> ###   srcfilealias open.srcfilealias close.srcfilealias
> ### Keywords: debugging utilities
> 
> ### ** Examples
> 
> 
> cleanEx()
> nameEx("startsWith")
> ### * startsWith
> 
> flush(stderr()); flush(stdout())
> 
> ### Encoding: UTF-8
> 
> ### Name: startsWith
> ### Title: Does String Start or End With Another String?
> ### Aliases: endsWith startsWith
> ### Keywords: character utilities
> 
> ### ** Examples
> 
> startsWith(search(), "package:") # typically at least two FALSE, nowadays often three
 [1] FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE
> 
> x1 <- c("Foobar", "bla bla", "something", "another", "blu", "brown",
+         "blau blüht der Enzian")# non-ASCII
> x2 <- cbind(
+       startsWith(x1, "b"),
+       startsWith(x1, "bl"),
+       startsWith(x1, "bla"),
+         endsWith(x1, "n"),
+         endsWith(x1, "an"))
> rownames(x2) <- x1; colnames(x2) <- c("b", "b1", "bla", "n", "an")
> x2
                          b    b1   bla     n    an
Foobar                FALSE FALSE FALSE FALSE FALSE
bla bla                TRUE  TRUE  TRUE FALSE FALSE
something             FALSE FALSE FALSE FALSE FALSE
another               FALSE FALSE FALSE FALSE FALSE
blu                    TRUE  TRUE FALSE FALSE FALSE
brown                  TRUE FALSE FALSE  TRUE FALSE
blau blüht der Enzian  TRUE  TRUE  TRUE  TRUE  TRUE
> 
> ## Non-equivalence in case of missing values in 'x', see Details:
> x <- c("all", "but", NA_character_)
> cbind(startsWith(x, "a"),
+       substring(x, 1L, 1L) == "a",
+       grepl("^a", x))
      [,1]  [,2]  [,3]
[1,]  TRUE  TRUE  TRUE
[2,] FALSE FALSE FALSE
[3,]    NA    NA FALSE
> 
> 
> 
> cleanEx()
> nameEx("stop")
> ### * stop
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: stop
> ### Title: Stop Function Execution
> ### Aliases: stop geterrmessage
> ### Keywords: environment programming error
> 
> ### ** Examples
> 
> iter <- 12
> try(if(iter > 10) stop("too many iterations"))
Error in try(if (iter > 10) stop("too many iterations")) : 
  too many iterations
> 
> tst1 <- function(...) stop("dummy error")
> try(tst1(1:10, long, calling, expression))
Error in tst1(1:10, long, calling, expression) : dummy error
> 
> tst2 <- function(...) stop("dummy error", call. = FALSE)
> try(tst2(1:10, longcalling, expression, but.not.seen.in.Error))
Error : dummy error
> 
> 
> 
> cleanEx()
> nameEx("stopifnot")
> ### * stopifnot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: stopifnot
> ### Title: Ensure the Truth of R Expressions
> ### Aliases: stopifnot
> ### Keywords: environment programming error
> 
> ### ** Examples
> 
> stopifnot(1 == 1, all.equal(pi, 3.14159265), 1 < 2) # all TRUE
> 
> m <- matrix(c(1,3,3,1), 2, 2)
> stopifnot(m == t(m), diag(m) == rep(1, 2)) # all(.) |=>  TRUE
> 
> op <- options(error = expression(NULL))
> # "disabling stop(.)"  << Use with CARE! >>
> 
> stopifnot(length(10)) # gives an error: '1' is *not* TRUE
Error: length(10) is not TRUE
> ## even when   if(1) "ok"   works
> 
> stopifnot(all.equal(pi, 3.141593),  2 < 2, (1:10 < 12), "a" < "b")
Error: pi and 3.141593 are not equal:
  Mean relative difference: 1.102658e-07
> ## More convenient for interactive "line by line" evaluation:
> stopifnot(exprs = {
+   all.equal(pi, 3.1415927)
+   2 < 2
+   1:10 < 12
+   "a" < "b"
+ })
Error: 2 < 2 is not TRUE
> 
> eObj <- expression(2 < 3, 3 <= 3:6, 1:10 < 2)
> stopifnot(exprObject = eObj)
Error: 1:10 < 2 are not all TRUE
> stopifnot(exprObject = quote(3 == 3))
> stopifnot(exprObject = TRUE)
> 
> 
> # long all.equal() error messages are abbreviated:
> stopifnot(all.equal(rep(list(pi),4), list(3.1, 3.14, 3.141, 3.1415)))
Error: rep(list(pi), 4) and list(3.1, 3.14, 3.141, 3.1415) are not equal:
  Component 1: Mean relative difference: 0.01323935
  Component 2: Mean relative difference: 0.0005069574
  Component 3: Mean relative difference: 0.0001886475
  ....
> 
> # The default error message can be overridden to be more informative:
> m[1,2] <- 12
> stopifnot("m must be symmetric"= m == t(m))
Error: m must be symmetric
> #=> Error: m must be symmetric
> 
> options(op)  # revert to previous error handler
> 
> 
> 
> cleanEx()
> nameEx("strptime")
> ### * strptime
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: strptime
> ### Title: Date-time Conversion Functions to and from Character
> ### Aliases: format.POSIXct format.POSIXlt strftime strptime
> ###   as.character.POSIXt
> ### Keywords: utilities chron
> 
> ### ** Examples
> 
> 
> cleanEx()
> nameEx("strrep")
> ### * strrep
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: strrep
> ### Title: Repeat the Elements of a Character Vector
> ### Aliases: strrep
> ### Keywords: character
> 
> ### ** Examples
> 
> strrep("ABC", 2)
[1] "ABCABC"
> strrep(c("A", "B", "C"), 1 : 3)
[1] "A"   "BB"  "CCC"
> ## Create vectors with the given numbers of spaces:
> strrep(" ", 1 : 5)
[1] " "     "  "    "   "   "    "  "     "
> 
> 
> 
> cleanEx()
> nameEx("strsplit")
> ### * strsplit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: strsplit
> ### Title: Split the Elements of a Character Vector
> ### Aliases: strsplit
> ### Keywords: character
> 
> ### ** Examples
> 
> noquote(strsplit("A text I want to display with spaces", NULL)[[1]])
 [1] A   t e x t   I   w a n t   t o   d i s p l a y   w i t h   s p a c e s
> 
> x <- c(as = "asfef", qu = "qwerty", "yuiop[", "b", "stuff.blah.yech")
> # split x on the letter e
> strsplit(x, "e")
$as
[1] "asf" "f"  

$qu
[1] "qw"  "rty"

[[3]]
[1] "yuiop["

[[4]]
[1] "b"

[[5]]
[1] "stuff.blah.y" "ch"          

> 
> unlist(strsplit("a.b.c", "."))
[1] "" "" "" "" ""
> ## [1] "" "" "" "" ""
> ## Note that 'split' is a regexp!
> ## If you really want to split on '.', use
> unlist(strsplit("a.b.c", "[.]"))
[1] "a" "b" "c"
> ## [1] "a" "b" "c"
> ## or
> unlist(strsplit("a.b.c", ".", fixed = TRUE))
[1] "a" "b" "c"
> 
> ## a useful function: rev() for strings
> strReverse <- function(x)
+         sapply(lapply(strsplit(x, NULL), rev), paste, collapse = "")
> strReverse(c("abc", "Statistics"))
[1] "cba"        "scitsitatS"
> 
> ## get the first names of the members of R-core
> a <- readLines(file.path(R.home("doc"),"AUTHORS"))[-(1:8)]
> a <- a[(0:2)-length(a)]
> (a <- sub(" .*","", a))
 [1] "Douglas"   "John"      "Peter"     "Robert"    "Kurt"      "Ross"     
 [7] "Tomas"     "Michael"   "Friedrich" "Uwe"       "Thomas"    "Martin"   
[13] "Martin"    "Paul"      "Martyn"    "Brian"     "Deepayan"  "Duncan"   
[19] "Luke"      "Simon"     ""          "plus"      "Stefano"   "up"       
[25] ""          ""          "Current"   "with"     
> # and reverse them
> strReverse(a)
 [1] "salguoD"   "nhoJ"      "reteP"     "treboR"    "truK"      "ssoR"     
 [7] "samoT"     "leahciM"   "hcirdeirF" "ewU"       "samohT"    "nitraM"   
[13] "nitraM"    "luaP"      "nytraM"    "nairB"     "nayapeeD"  "nacnuD"   
[19] "ekuL"      "nomiS"     ""          "sulp"      "onafetS"   "pu"       
[25] ""          ""          "tnerruC"   "htiw"     
> 
> ## Note that final empty strings are not produced:
> strsplit(paste(c("", "a", ""), collapse="#"), split="#")[[1]]
[1] ""  "a"
> # [1] ""  "a"
> ## and also an empty string is only produced before a definite match:
> strsplit("", " ")[[1]]    # character(0)
character(0)
> strsplit(" ", " ")[[1]]   # [1] ""
[1] ""
> 
> 
> 
> cleanEx()
> nameEx("strtoi")
> ### * strtoi
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: strtoi
> ### Title: Convert Strings to Integers
> ### Aliases: strtoi
> ### Keywords: classes character utilities
> 
> ### ** Examples
> 
> strtoi(c("0xff", "077", "123"))
[1] 255  63 123
> strtoi(c("ffff", "FFFF"), 16L)
[1] 65535 65535
> strtoi(c("177", "377"), 8L)
[1] 127 255
> 
> 
> 
> cleanEx()
> nameEx("strtrim")
> ### * strtrim
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: strtrim
> ### Title: Trim Character Strings to Specified Display Widths
> ### Aliases: strtrim
> ### Keywords: character utilities
> 
> ### ** Examples
> 
> strtrim(c("abcdef", "abcdef", "abcdef"), c(1,5,10))
[1] "a"      "abcde"  "abcdef"
> 
> 
> 
> cleanEx()
> nameEx("structure")
> ### * structure
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: structure
> ### Title: Attribute Specification
> ### Aliases: structure
> ### Keywords: attribute manip
> 
> ### ** Examples
> 
> structure(1:6, dim = 2:3)
     [,1] [,2] [,3]
[1,]    1    3    5
[2,]    2    4    6
> 
> 
> 
> cleanEx()
> nameEx("strwrap")
> ### * strwrap
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: strwrap
> ### Title: Wrap Character Strings to Format Paragraphs
> ### Aliases: strwrap
> ### Keywords: character
> 
> ### ** Examples
> 
> ## Read in file 'THANKS'.
> x <- paste(readLines(file.path(R.home("doc"), "THANKS")), collapse = "\n")
> ## Split into paragraphs and remove the first three ones
> x <- unlist(strsplit(x, "\n[ \t\n]*\n"))[-(1:3)]
> ## Join the rest
> x <- paste(x, collapse = "\n\n")
> ## Now for some fun:
> writeLines(strwrap(x, width = 60))
J. D. Beasley, David J. Best, Richard Brent, Kevin Buhr,
Michael A. Covington, Bill Cleveland, Robert Cleveland,, G.
W. Cran, C. G. Ding, Ulrich Drepper, Paul Eggert, J. O.
Evans, David M. Gay, H. Frick, G. W. Hill, Richard H.
Jones, Eric Grosse, Shelby Haberman, Bruno Haible, John
Hartigan, Andrew Harvey, Trevor Hastie, Min Long Lam,
George Marsaglia, K. J. Martin, Gordon Matzigkeit, C. R.
Mckenzie, Jean McRae, Cyrus Mehta, Fionn Murtagh, John C.
Nash, Finbarr O'Sullivan, R. E. Odeh, William Patefield,
Nitin Patel, Alan Richardson, D. E. Roberts, Patrick
Royston, Russell Lenth, Ming-Jen Shyu, Richard C.
Singleton, S. G. Springer, Supoj Sutanthavibul, Irma
Terpenning, G. E. Thomas, Rob Tibshirani, Wai Wan Tsang,
Berwin Turlach, Gary V. Vaughan, Michael Wichura, Jingbo
Wang, M. A. Wong, and the Free Software Foundation (for
autoconf code and utilities). See also files under
src/extras.

Many more, too numerous to mention here, have contributed
by sending bug reports and suggesting various improvements.

Simon Davies whilst at the University of Auckland wrote the
original version of glm().

Julian Harris and Wing Kwong (Tiki) Wan whilst at the
University of Auckland assisted Ross Ihaka with the
original Macintosh port.

R was inspired by the S environment which has been
principally developed by John Chambers, with substantial
input from Douglas Bates, Rick Becker, Bill Cleveland,
Trevor Hastie, Daryl Pregibon and Allan Wilks.

A special debt is owed to John Chambers who has graciously
contributed advice and encouragement in the early days of R
and later became a member of the core team.

Stefano Iacus (a former member of R Core) and Simon Urbanek
developed the macOS port, including the R.app GUI,
toolchains and packaging.

The Windows port was developed by Guido Masarotto (for a
while a member of R Core) and Brian Ripley, then Duncan
Murdoch (a former member of R Core) and currently by Jeroen
Ooms (base) and Uwe Ligges (packages).

Tomas Kalibera's work has been sponsored by Jan Vitek and
funded by his European Research Council grant "Evolving
Language Ecosystems (ELE)".

Computing support (including hardware, hosting and
infrastructure) has been provided/funded by the R
Foundation, employers of R-Core members (notably WU Wien,
ETH Zurich, U Oxford and U Iowa) and by Northeastern
University and the University of Kent.

Distributions of R contain the recommended packages, whose
authors/contributors are listed in their DESCRIPTION files.
> writeLines(strwrap(x, width = 60, indent = 5))
     J. D. Beasley, David J. Best, Richard Brent, Kevin
Buhr, Michael A. Covington, Bill Cleveland, Robert
Cleveland,, G. W. Cran, C. G. Ding, Ulrich Drepper, Paul
Eggert, J. O. Evans, David M. Gay, H. Frick, G. W. Hill,
Richard H. Jones, Eric Grosse, Shelby Haberman, Bruno
Haible, John Hartigan, Andrew Harvey, Trevor Hastie, Min
Long Lam, George Marsaglia, K. J. Martin, Gordon
Matzigkeit, C. R. Mckenzie, Jean McRae, Cyrus Mehta, Fionn
Murtagh, John C. Nash, Finbarr O'Sullivan, R. E. Odeh,
William Patefield, Nitin Patel, Alan Richardson, D. E.
Roberts, Patrick Royston, Russell Lenth, Ming-Jen Shyu,
Richard C. Singleton, S. G. Springer, Supoj Sutanthavibul,
Irma Terpenning, G. E. Thomas, Rob Tibshirani, Wai Wan
Tsang, Berwin Turlach, Gary V. Vaughan, Michael Wichura,
Jingbo Wang, M. A. Wong, and the Free Software Foundation
(for autoconf code and utilities). See also files under
src/extras.

     Many more, too numerous to mention here, have
contributed by sending bug reports and suggesting various
improvements.

     Simon Davies whilst at the University of Auckland
wrote the original version of glm().

     Julian Harris and Wing Kwong (Tiki) Wan whilst at the
University of Auckland assisted Ross Ihaka with the
original Macintosh port.

     R was inspired by the S environment which has been
principally developed by John Chambers, with substantial
input from Douglas Bates, Rick Becker, Bill Cleveland,
Trevor Hastie, Daryl Pregibon and Allan Wilks.

     A special debt is owed to John Chambers who has
graciously contributed advice and encouragement in the
early days of R and later became a member of the core team.

     Stefano Iacus (a former member of R Core) and Simon
Urbanek developed the macOS port, including the R.app GUI,
toolchains and packaging.

     The Windows port was developed by Guido Masarotto (for
a while a member of R Core) and Brian Ripley, then Duncan
Murdoch (a former member of R Core) and currently by Jeroen
Ooms (base) and Uwe Ligges (packages).

     Tomas Kalibera's work has been sponsored by Jan Vitek
and funded by his European Research Council grant "Evolving
Language Ecosystems (ELE)".

     Computing support (including hardware, hosting and
infrastructure) has been provided/funded by the R
Foundation, employers of R-Core members (notably WU Wien,
ETH Zurich, U Oxford and U Iowa) and by Northeastern
University and the University of Kent.

     Distributions of R contain the recommended packages,
whose authors/contributors are listed in their DESCRIPTION
files.
> writeLines(strwrap(x, width = 60, exdent = 5))
J. D. Beasley, David J. Best, Richard Brent, Kevin Buhr,
     Michael A. Covington, Bill Cleveland, Robert
     Cleveland,, G. W. Cran, C. G. Ding, Ulrich Drepper,
     Paul Eggert, J. O. Evans, David M. Gay, H. Frick, G.
     W. Hill, Richard H. Jones, Eric Grosse, Shelby
     Haberman, Bruno Haible, John Hartigan, Andrew Harvey,
     Trevor Hastie, Min Long Lam, George Marsaglia, K. J.
     Martin, Gordon Matzigkeit, C. R. Mckenzie, Jean McRae,
     Cyrus Mehta, Fionn Murtagh, John C. Nash, Finbarr
     O'Sullivan, R. E. Odeh, William Patefield, Nitin
     Patel, Alan Richardson, D. E. Roberts, Patrick
     Royston, Russell Lenth, Ming-Jen Shyu, Richard C.
     Singleton, S. G. Springer, Supoj Sutanthavibul, Irma
     Terpenning, G. E. Thomas, Rob Tibshirani, Wai Wan
     Tsang, Berwin Turlach, Gary V. Vaughan, Michael
     Wichura, Jingbo Wang, M. A. Wong, and the Free
     Software Foundation (for autoconf code and utilities).
     See also files under src/extras.

Many more, too numerous to mention here, have contributed
     by sending bug reports and suggesting various
     improvements.

Simon Davies whilst at the University of Auckland wrote the
     original version of glm().

Julian Harris and Wing Kwong (Tiki) Wan whilst at the
     University of Auckland assisted Ross Ihaka with the
     original Macintosh port.

R was inspired by the S environment which has been
     principally developed by John Chambers, with
     substantial input from Douglas Bates, Rick Becker,
     Bill Cleveland, Trevor Hastie, Daryl Pregibon and
     Allan Wilks.

A special debt is owed to John Chambers who has graciously
     contributed advice and encouragement in the early days
     of R and later became a member of the core team.

Stefano Iacus (a former member of R Core) and Simon Urbanek
     developed the macOS port, including the R.app GUI,
     toolchains and packaging.

The Windows port was developed by Guido Masarotto (for a
     while a member of R Core) and Brian Ripley, then
     Duncan Murdoch (a former member of R Core) and
     currently by Jeroen Ooms (base) and Uwe Ligges
     (packages).

Tomas Kalibera's work has been sponsored by Jan Vitek and
     funded by his European Research Council grant
     "Evolving Language Ecosystems (ELE)".

Computing support (including hardware, hosting and
     infrastructure) has been provided/funded by the R
     Foundation, employers of R-Core members (notably WU
     Wien, ETH Zurich, U Oxford and U Iowa) and by
     Northeastern University and the University of Kent.

Distributions of R contain the recommended packages, whose
     authors/contributors are listed in their DESCRIPTION
     files.
> writeLines(strwrap(x, prefix = "THANKS> "))
THANKS> J. D. Beasley, David J. Best, Richard Brent, Kevin Buhr,
THANKS> Michael A. Covington, Bill Cleveland, Robert Cleveland,, G. W.
THANKS> Cran, C. G. Ding, Ulrich Drepper, Paul Eggert, J. O. Evans,
THANKS> David M. Gay, H. Frick, G. W. Hill, Richard H. Jones, Eric
THANKS> Grosse, Shelby Haberman, Bruno Haible, John Hartigan, Andrew
THANKS> Harvey, Trevor Hastie, Min Long Lam, George Marsaglia, K. J.
THANKS> Martin, Gordon Matzigkeit, C. R. Mckenzie, Jean McRae, Cyrus
THANKS> Mehta, Fionn Murtagh, John C. Nash, Finbarr O'Sullivan, R. E.
THANKS> Odeh, William Patefield, Nitin Patel, Alan Richardson, D. E.
THANKS> Roberts, Patrick Royston, Russell Lenth, Ming-Jen Shyu, Richard
THANKS> C. Singleton, S. G. Springer, Supoj Sutanthavibul, Irma
THANKS> Terpenning, G. E. Thomas, Rob Tibshirani, Wai Wan Tsang, Berwin
THANKS> Turlach, Gary V. Vaughan, Michael Wichura, Jingbo Wang, M. A.
THANKS> Wong, and the Free Software Foundation (for autoconf code and
THANKS> utilities). See also files under src/extras.
THANKS> 
THANKS> Many more, too numerous to mention here, have contributed by
THANKS> sending bug reports and suggesting various improvements.
THANKS> 
THANKS> Simon Davies whilst at the University of Auckland wrote the
THANKS> original version of glm().
THANKS> 
THANKS> Julian Harris and Wing Kwong (Tiki) Wan whilst at the
THANKS> University of Auckland assisted Ross Ihaka with the original
THANKS> Macintosh port.
THANKS> 
THANKS> R was inspired by the S environment which has been principally
THANKS> developed by John Chambers, with substantial input from Douglas
THANKS> Bates, Rick Becker, Bill Cleveland, Trevor Hastie, Daryl
THANKS> Pregibon and Allan Wilks.
THANKS> 
THANKS> A special debt is owed to John Chambers who has graciously
THANKS> contributed advice and encouragement in the early days of R and
THANKS> later became a member of the core team.
THANKS> 
THANKS> Stefano Iacus (a former member of R Core) and Simon Urbanek
THANKS> developed the macOS port, including the R.app GUI, toolchains
THANKS> and packaging.
THANKS> 
THANKS> The Windows port was developed by Guido Masarotto (for a while
THANKS> a member of R Core) and Brian Ripley, then Duncan Murdoch (a
THANKS> former member of R Core) and currently by Jeroen Ooms (base)
THANKS> and Uwe Ligges (packages).
THANKS> 
THANKS> Tomas Kalibera's work has been sponsored by Jan Vitek and
THANKS> funded by his European Research Council grant "Evolving
THANKS> Language Ecosystems (ELE)".
THANKS> 
THANKS> Computing support (including hardware, hosting and
THANKS> infrastructure) has been provided/funded by the R Foundation,
THANKS> employers of R-Core members (notably WU Wien, ETH Zurich, U
THANKS> Oxford and U Iowa) and by Northeastern University and the
THANKS> University of Kent.
THANKS> 
THANKS> Distributions of R contain the recommended packages, whose
THANKS> authors/contributors are listed in their DESCRIPTION files.
> 
> ## Note that messages are wrapped AT the target column indicated by
> ## 'width' (and not beyond it).
> ## From an R-devel posting by J. Hosking <jh910@juno.com>.
> x <- paste(sapply(sample(10, 100, replace = TRUE),
+            function(x) substring("aaaaaaaaaa", 1, x)), collapse = " ")
> sapply(10:40,
+        function(m)
+        c(target = m, actual = max(nchar(strwrap(x, m)))))
       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13]
target   10   11   12   13   14   15   16   17   18    19    20    21    22
actual   10   10   11   12   13   14   15   16   17    18    19    20    21
       [,14] [,15] [,16] [,17] [,18] [,19] [,20] [,21] [,22] [,23] [,24] [,25]
target    23    24    25    26    27    28    29    30    31    32    33    34
actual    22    23    24    25    26    27    28    29    30    31    32    33
       [,26] [,27] [,28] [,29] [,30] [,31]
target    35    36    37    38    39    40
actual    34    35    36    37    38    39
> 
> 
> 
> cleanEx()
> nameEx("subset")
> ### * subset
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: subset
> ### Title: Subsetting Vectors, Matrices and Data Frames
> ### Aliases: subset subset.default subset.matrix subset.data.frame
> ### Keywords: manip
> 
> ### ** Examples
> 
> subset(airquality, Temp > 80, select = c(Ozone, Temp))
    Ozone Temp
29     45   81
35     NA   84
36     NA   85
38     29   82
39     NA   87
40     71   90
41     39   87
42     NA   93
43     NA   92
44     23   82
61     NA   83
62    135   84
63     49   85
64     32   81
65     NA   84
66     64   83
67     40   83
68     77   88
69     97   92
70     97   92
71     85   89
72     NA   82
74     27   81
75     NA   91
77     48   81
78     35   82
79     61   84
80     79   87
81     63   85
83     NA   81
84     NA   82
85     80   86
86    108   85
87     20   82
88     52   86
89     82   88
90     50   86
91     64   83
92     59   81
93     39   81
94      9   81
95     16   82
96     78   86
97     35   85
98     66   87
99    122   89
100    89   90
101   110   90
102    NA   92
103    NA   86
104    44   86
105    28   82
117   168   81
118    73   86
119    NA   88
120    76   97
121   118   94
122    84   96
123    85   94
124    96   91
125    78   92
126    73   93
127    91   93
128    47   87
129    32   84
134    44   81
143    16   82
146    36   81
> subset(airquality, Day == 1, select = -Temp)
    Ozone Solar.R Wind Month Day
1      41     190  7.4     5   1
32     NA     286  8.6     6   1
62    135     269  4.1     7   1
93     39      83  6.9     8   1
124    96     167  6.9     9   1
> subset(airquality, select = Ozone:Wind)
    Ozone Solar.R Wind
1      41     190  7.4
2      36     118  8.0
3      12     149 12.6
4      18     313 11.5
5      NA      NA 14.3
6      28      NA 14.9
7      23     299  8.6
8      19      99 13.8
9       8      19 20.1
10     NA     194  8.6
11      7      NA  6.9
12     16     256  9.7
13     11     290  9.2
14     14     274 10.9
15     18      65 13.2
16     14     334 11.5
17     34     307 12.0
18      6      78 18.4
19     30     322 11.5
20     11      44  9.7
21      1       8  9.7
22     11     320 16.6
23      4      25  9.7
24     32      92 12.0
25     NA      66 16.6
26     NA     266 14.9
27     NA      NA  8.0
28     23      13 12.0
29     45     252 14.9
30    115     223  5.7
31     37     279  7.4
32     NA     286  8.6
33     NA     287  9.7
34     NA     242 16.1
35     NA     186  9.2
36     NA     220  8.6
37     NA     264 14.3
38     29     127  9.7
39     NA     273  6.9
40     71     291 13.8
41     39     323 11.5
42     NA     259 10.9
43     NA     250  9.2
44     23     148  8.0
45     NA     332 13.8
46     NA     322 11.5
47     21     191 14.9
48     37     284 20.7
49     20      37  9.2
50     12     120 11.5
51     13     137 10.3
52     NA     150  6.3
53     NA      59  1.7
54     NA      91  4.6
55     NA     250  6.3
56     NA     135  8.0
57     NA     127  8.0
58     NA      47 10.3
59     NA      98 11.5
60     NA      31 14.9
61     NA     138  8.0
62    135     269  4.1
63     49     248  9.2
64     32     236  9.2
65     NA     101 10.9
66     64     175  4.6
67     40     314 10.9
68     77     276  5.1
69     97     267  6.3
70     97     272  5.7
71     85     175  7.4
72     NA     139  8.6
73     10     264 14.3
74     27     175 14.9
75     NA     291 14.9
76      7      48 14.3
77     48     260  6.9
78     35     274 10.3
79     61     285  6.3
80     79     187  5.1
81     63     220 11.5
82     16       7  6.9
83     NA     258  9.7
84     NA     295 11.5
85     80     294  8.6
86    108     223  8.0
87     20      81  8.6
88     52      82 12.0
89     82     213  7.4
90     50     275  7.4
91     64     253  7.4
92     59     254  9.2
93     39      83  6.9
94      9      24 13.8
95     16      77  7.4
96     78      NA  6.9
97     35      NA  7.4
98     66      NA  4.6
99    122     255  4.0
100    89     229 10.3
101   110     207  8.0
102    NA     222  8.6
103    NA     137 11.5
104    44     192 11.5
105    28     273 11.5
106    65     157  9.7
107    NA      64 11.5
108    22      71 10.3
109    59      51  6.3
110    23     115  7.4
111    31     244 10.9
112    44     190 10.3
113    21     259 15.5
114     9      36 14.3
115    NA     255 12.6
116    45     212  9.7
117   168     238  3.4
118    73     215  8.0
119    NA     153  5.7
120    76     203  9.7
121   118     225  2.3
122    84     237  6.3
123    85     188  6.3
124    96     167  6.9
125    78     197  5.1
126    73     183  2.8
127    91     189  4.6
128    47      95  7.4
129    32      92 15.5
130    20     252 10.9
131    23     220 10.3
132    21     230 10.9
133    24     259  9.7
134    44     236 14.9
135    21     259 15.5
136    28     238  6.3
137     9      24 10.9
138    13     112 11.5
139    46     237  6.9
140    18     224 13.8
141    13      27 10.3
142    24     238 10.3
143    16     201  8.0
144    13     238 12.6
145    23      14  9.2
146    36     139 10.3
147     7      49 10.3
148    14      20 16.6
149    30     193  6.9
150    NA     145 13.2
151    14     191 14.3
152    18     131  8.0
153    20     223 11.5
> 
> with(airquality, subset(Ozone, Temp > 80))
 [1]  45  NA  NA  29  NA  71  39  NA  NA  23  NA 135  49  32  NA  64  40  77  97
[20]  97  85  NA  27  NA  48  35  61  79  63  NA  NA  80 108  20  52  82  50  64
[39]  59  39   9  16  78  35  66 122  89 110  NA  NA  44  28 168  73  NA  76 118
[58]  84  85  96  78  73  91  47  32  44  16  36
> 
> ## sometimes requiring a logical 'subset' argument is a nuisance
> nm <- rownames(state.x77)
> start_with_M <- nm %in% grep("^M", nm, value = TRUE)
> subset(state.x77, start_with_M, Illiteracy:Murder)
              Illiteracy Life Exp Murder
Maine                0.7    70.39    2.7
Maryland             0.9    70.22    8.5
Massachusetts        1.1    71.83    3.3
Michigan             0.9    70.63   11.1
Minnesota            0.6    72.96    2.3
Mississippi          2.4    68.09   12.5
Missouri             0.8    70.69    9.3
Montana              0.6    70.56    5.0
> # but in recent versions of R this can simply be
> subset(state.x77, grepl("^M", nm), Illiteracy:Murder)
              Illiteracy Life Exp Murder
Maine                0.7    70.39    2.7
Maryland             0.9    70.22    8.5
Massachusetts        1.1    71.83    3.3
Michigan             0.9    70.63   11.1
Minnesota            0.6    72.96    2.3
Mississippi          2.4    68.09   12.5
Missouri             0.8    70.69    9.3
Montana              0.6    70.56    5.0
> 
> 
> 
> cleanEx()
> nameEx("substitute")
> ### * substitute
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: substitute
> ### Title: Substituting and Quoting Expressions
> ### Aliases: substitute quote enquote
> ### Keywords: programming data
> 
> ### ** Examples
> 
> require(graphics)
> (s.e <- substitute(expression(a + b), list(a = 1)))  #> expression(1 + b)
expression(1 + b)
> (s.s <- substitute( a + b,            list(a = 1)))  #> 1 + b
1 + b
> c(mode(s.e), typeof(s.e)) #  "call", "language"
[1] "call"     "language"
> c(mode(s.s), typeof(s.s)) #   (the same)
[1] "call"     "language"
> # but:
> (e.s.e <- eval(s.e))          #>  expression(1 + b)
expression(1 + b)
> c(mode(e.s.e), typeof(e.s.e)) #  "expression", "expression"
[1] "expression" "expression"
> 
> substitute(x <- x + 1, list(x = 1)) # nonsense
1 <- 1 + 1
> 
> myplot <- function(x, y)
+     plot(x, y, xlab = deparse1(substitute(x)),
+                ylab = deparse1(substitute(y)))
> 
> ## Simple examples about lazy evaluation, etc:
> 
> f1 <- function(x, y = x)             { x <- x + 1; y }
> s1 <- function(x, y = substitute(x)) { x <- x + 1; y }
> s2 <- function(x, y) { if(missing(y)) y <- substitute(x); x <- x + 1; y }
> a <- 10
> f1(a)  # 11
[1] 11
> s1(a)  # 11
[1] 11
> s2(a)  # a
a
> typeof(s2(a))  # "symbol"
[1] "symbol"
> 
> 
> 
> cleanEx()
> nameEx("substr")
> ### * substr
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: substr
> ### Title: Substrings of a Character Vector
> ### Aliases: substr substring substr<- substring<-
> ### Keywords: character
> 
> ### ** Examples
> 
> substr("abcdef", 2, 4)
[1] "bcd"
> substring("abcdef", 1:6, 1:6)
[1] "a" "b" "c" "d" "e" "f"
> ## strsplit is more efficient ...
> 
> substr(rep("abcdef", 4), 1:4, 4:5)
[1] "abcd" "bcde" "cd"   "de"  
> x <- c("asfef", "qwerty", "yuiop[", "b", "stuff.blah.yech")
> substr(x, 2, 5)
[1] "sfef" "wert" "uiop" ""     "tuff"
> substring(x, 2, 4:6)
[1] "sfe"   "wert"  "uiop[" ""      "tuff" 
> 
> substring(x, 2) <- c("..", "+++")
> x
[1] "a..ef"           "q+++ty"          "y..op["          "b"              
[5] "s..ff.blah.yech"
> 
> 
> 
> cleanEx()
> nameEx("sum")
> ### * sum
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sum
> ### Title: Sum of Vector Elements
> ### Aliases: sum
> ### Keywords: arith
> 
> ### ** Examples
> 
> ## Pass a vector to sum, and it will add the elements together.
> sum(1:5)
[1] 15
> 
> ## Pass several numbers to sum, and it also adds the elements.
> sum(1, 2, 3, 4, 5)
[1] 15
> 
> ## In fact, you can pass vectors into several arguments, and everything gets added.
> sum(1:2, 3:5)
[1] 15
> 
> ## If there are missing values, the sum is unknown, i.e., also missing, ....
> sum(1:5, NA)
[1] NA
> ## ... unless  we exclude missing values explicitly:
> sum(1:5, NA, na.rm = TRUE)
[1] 15
> 
> 
> 
> cleanEx()
> nameEx("summary")
> ### * summary
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: summary
> ### Title: Object Summaries
> ### Aliases: summary summary.default summary.data.frame summary.factor
> ###   summary.matrix format.summaryDefault print.summaryDefault
> ### Keywords: methods
> 
> ### ** Examples
> 
> summary(attenu, digits = 4) #-> summary.data.frame(...), default precision
     event            mag           station         dist       
 Min.   : 1.00   Min.   :5.000   117    :  5   Min.   :  0.50  
 1st Qu.: 9.00   1st Qu.:5.300   1028   :  4   1st Qu.: 11.32  
 Median :18.00   Median :6.100   113    :  4   Median : 23.40  
 Mean   :14.74   Mean   :6.084   112    :  3   Mean   : 45.60  
 3rd Qu.:20.00   3rd Qu.:6.600   135    :  3   3rd Qu.: 47.55  
 Max.   :23.00   Max.   :7.700   (Other):147   Max.   :370.00  
                                 NA's   : 16                   
     accel        
 Min.   :0.00300  
 1st Qu.:0.04425  
 Median :0.11300  
 Mean   :0.15422  
 3rd Qu.:0.21925  
 Max.   :0.81000  
                  
> summary(attenu $ station, maxsum = 20) #-> summary.factor(...)
    117    1028     113     112     135     475    1030    1083    1093    1095 
      5       4       4       3       3       3       2       2       2       2 
    111     116    1219    1299     130    1308    1377    1383 (Other)    NA's 
      2       2       2       2       2       2       2       2     120      16 
> 
> lst <- unclass(attenu$station) > 20 # logical with NAs
> ## summary.default() for logicals -- different from *.factor:
> summary(lst)
   Mode   FALSE    TRUE    NA's 
logical      28     138      16 
> summary(as.factor(lst))
FALSE  TRUE  NA's 
   28   138    16 
> 
> 
> 
> cleanEx()
> nameEx("svd")
> ### * svd
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: svd
> ### Title: Singular Value Decomposition of a Matrix
> ### Aliases: svd La.svd
> ### Keywords: algebra array
> 
> ### ** Examples
> 
> hilbert <- function(n) { i <- 1:n; 1 / outer(i - 1, i, "+") }
> X <- hilbert(9)[, 1:6]
> (s <- svd(X))
$d
[1] 1.668433e+00 2.773727e-01 2.223722e-02 1.084693e-03 3.243788e-05
[6] 5.234864e-07

$u
            [,1]       [,2]        [,3]        [,4]        [,5]        [,6]
 [1,] -0.7244999  0.6265620  0.27350003 -0.08526902  0.02074121 -0.00402455
 [2,] -0.4281556 -0.1298781 -0.64293597  0.55047428 -0.27253421  0.09281592
 [3,] -0.3121985 -0.2803679 -0.33633240 -0.31418014  0.61632113 -0.44090375
 [4,] -0.2478932 -0.3141885 -0.06931246 -0.44667149  0.02945426  0.53011986
 [5,] -0.2063780 -0.3140734  0.10786005 -0.30241655 -0.35566839  0.23703838
 [6,] -0.1771408 -0.3026808  0.22105904 -0.09041508 -0.38878613 -0.26044927
 [7,] -0.1553452 -0.2877310  0.29280775  0.11551327 -0.19285565 -0.42094482
 [8,] -0.1384280 -0.2721599  0.33783778  0.29312535  0.11633231 -0.16079025
 [9,] -0.1248940 -0.2571250  0.36542543  0.43884649  0.46496714  0.43459954

$v
           [,1]       [,2]       [,3]        [,4]        [,5]         [,6]
[1,] -0.7364928  0.6225002  0.2550021 -0.06976287  0.01328234 -0.001588146
[2,] -0.4432826 -0.1818705 -0.6866860  0.50860089 -0.19626669  0.041116974
[3,] -0.3274789 -0.3508553 -0.2611139 -0.50473697  0.61605641 -0.259215626
[4,] -0.2626469 -0.3921783  0.1043599 -0.43747940 -0.40833605  0.638901622
[5,] -0.2204199 -0.3945644  0.3509658  0.01612426 -0.46427916 -0.675826789
[6,] -0.1904420 -0.3831871  0.5110654  0.53856351  0.44663632  0.257248908

> D <- diag(s$d)
> s$u %*% D %*% t(s$v) #  X = U D V'
           [,1]      [,2]       [,3]       [,4]       [,5]       [,6]
 [1,] 1.0000000 0.5000000 0.33333333 0.25000000 0.20000000 0.16666667
 [2,] 0.5000000 0.3333333 0.25000000 0.20000000 0.16666667 0.14285714
 [3,] 0.3333333 0.2500000 0.20000000 0.16666667 0.14285714 0.12500000
 [4,] 0.2500000 0.2000000 0.16666667 0.14285714 0.12500000 0.11111111
 [5,] 0.2000000 0.1666667 0.14285714 0.12500000 0.11111111 0.10000000
 [6,] 0.1666667 0.1428571 0.12500000 0.11111111 0.10000000 0.09090909
 [7,] 0.1428571 0.1250000 0.11111111 0.10000000 0.09090909 0.08333333
 [8,] 0.1250000 0.1111111 0.10000000 0.09090909 0.08333333 0.07692308
 [9,] 0.1111111 0.1000000 0.09090909 0.08333333 0.07692308 0.07142857
> t(s$u) %*% X %*% s$v #  D = U' X V
              [,1]          [,2]          [,3]          [,4]          [,5]
[1,]  1.668433e+00  8.548803e-17  1.129034e-16 -6.417670e-17  6.659190e-17
[2,]  9.069240e-17  2.773727e-01 -1.097796e-17  2.601855e-17  3.041839e-17
[3,]  5.171880e-17 -2.288012e-17  2.223722e-02  4.595362e-18  9.353326e-18
[4,] -5.270342e-17 -3.839619e-17 -9.643362e-18  1.084693e-03 -1.265340e-17
[5,]  6.217477e-17  1.178536e-17  1.616207e-17 -1.039587e-17  3.243788e-05
[6,]  2.073608e-17 -4.177029e-17 -1.089009e-17 -6.870118e-18  2.005484e-18
              [,6]
[1,] -1.882206e-17
[2,] -1.048141e-17
[3,]  5.195472e-18
[4,] -4.560401e-18
[5,] -1.551598e-19
[6,]  5.234864e-07
> 
> 
> 
> cleanEx()
> nameEx("sweep")
> ### * sweep
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sweep
> ### Title: Sweep out Array Summaries
> ### Aliases: sweep
> ### Keywords: array iteration
> 
> ### ** Examples
> 
> require(stats) # for median
> med.att <- apply(attitude, 2, median)
> sweep(data.matrix(attitude), 2, med.att)  # subtract the column medians
      rating complaints privileges learning raises critical advance
 [1,]  -22.5        -14      -21.5    -17.5   -2.5     14.5       4
 [2,]   -2.5         -1       -0.5     -2.5   -0.5     -4.5       6
 [3,]    5.5          5       16.5     12.5   12.5      8.5       7
 [4,]   -4.5         -2       -6.5     -9.5   -9.5      6.5      -6
 [5,]   15.5         13        4.5      9.5    7.5      5.5       6
 [6,]  -22.5        -10       -2.5    -12.5   -9.5    -28.5      -7
 [7,]   -7.5          2       -9.5     -0.5    2.5     -9.5      -6
 [8,]    5.5         10       -1.5     -1.5    6.5    -11.5       0
 [9,]    6.5         17       20.5     10.5    7.5      5.5     -10
[10,]    1.5         -4       -6.5     -9.5   -1.5      2.5       0
[11,]   -1.5        -12        1.5      1.5   -5.5    -10.5      -7
[12,]    1.5         -5       -4.5    -17.5   -4.5     -3.5       0
[13,]    3.5         -3        5.5    -14.5   -8.5    -14.5     -16
[14,]    2.5         18       31.5    -11.5   -4.5     -0.5      -6
[15,]   11.5         12        2.5     15.5   15.5     -0.5       5
[16,]   15.5         25       -1.5     15.5   -3.5    -23.5      -5
[17,]    8.5         20       12.5     12.5   15.5      1.5      22
[18,]   -0.5         -5       13.5     18.5   -8.5      2.5      19
[19,]   -0.5          5       -5.5      0.5   11.5      7.5       5
[20,]  -15.5         -7       16.5     -2.5    0.5      0.5      11
[21,]  -15.5        -25      -18.5    -22.5  -20.5    -13.5      -8
[22,]   -1.5         -4        0.5      5.5    2.5      2.5       0
[23,]  -12.5          1        0.5     -6.5   -0.5      2.5      -4
[24,]  -25.5        -28       -9.5      1.5  -13.5    -20.5       8
[25,]   -2.5        -11       -9.5     -8.5    2.5     -2.5      -8
[26,]    0.5         12       14.5      6.5   24.5     -1.5      31
[27,]   12.5         10        6.5     17.5   16.5      0.5       8
[28,]  -17.5         -8       -7.5    -11.5  -12.5      5.5      -3
[29,]   19.5         20       19.5     14.5   13.5     -3.5      14
[30,]   16.5         17      -12.5      2.5    0.5      0.5      -2
> 
> ## More sweeping:
> A <- array(1:24, dim = 4:2)
> 
> ## no warnings in normal use
> sweep(A, 1, 5)
, , 1

     [,1] [,2] [,3]
[1,]   -4    0    4
[2,]   -3    1    5
[3,]   -2    2    6
[4,]   -1    3    7

, , 2

     [,1] [,2] [,3]
[1,]    8   12   16
[2,]    9   13   17
[3,]   10   14   18
[4,]   11   15   19

> (A.min <- apply(A, 1, min))  # == 1:4
[1] 1 2 3 4
> sweep(A, 1, A.min)
, , 1

     [,1] [,2] [,3]
[1,]    0    4    8
[2,]    0    4    8
[3,]    0    4    8
[4,]    0    4    8

, , 2

     [,1] [,2] [,3]
[1,]   12   16   20
[2,]   12   16   20
[3,]   12   16   20
[4,]   12   16   20

> sweep(A, 1:2, apply(A, 1:2, median))
, , 1

     [,1] [,2] [,3]
[1,]   -6   -6   -6
[2,]   -6   -6   -6
[3,]   -6   -6   -6
[4,]   -6   -6   -6

, , 2

     [,1] [,2] [,3]
[1,]    6    6    6
[2,]    6    6    6
[3,]    6    6    6
[4,]    6    6    6

> 
> ## warnings when mismatch
> sweep(A, 1, 1:3)  # STATS does not recycle
Warning in sweep(A, 1, 1:3) :
  STATS does not recycle exactly across MARGIN
, , 1

     [,1] [,2] [,3]
[1,]    0    3    6
[2,]    0    3    9
[3,]    0    6    9
[4,]    3    6    9

, , 2

     [,1] [,2] [,3]
[1,]   12   15   18
[2,]   12   15   21
[3,]   12   18   21
[4,]   15   18   21

> sweep(A, 1, 6:1)  # STATS is longer
Warning in sweep(A, 1, 6:1) :
  STATS is longer than the extent of 'dim(x)[MARGIN]'
, , 1

     [,1] [,2] [,3]
[1,]   -5    3    5
[2,]   -3    5    7
[3,]   -1    1    9
[4,]    1    3   11

, , 2

     [,1] [,2] [,3]
[1,]    7   15   17
[2,]    9   17   19
[3,]   11   13   21
[4,]   13   15   23

> 
> ## exact recycling:
> sweep(A, 1, 1:2)  # no warning
, , 1

     [,1] [,2] [,3]
[1,]    0    4    8
[2,]    0    4    8
[3,]    2    6   10
[4,]    2    6   10

, , 2

     [,1] [,2] [,3]
[1,]   12   16   20
[2,]   12   16   20
[3,]   14   18   22
[4,]   14   18   22

> sweep(A, 1, as.array(1:2))  # warning
Warning in sweep(A, 1, as.array(1:2)) :
  length(STATS) or dim(STATS) do not match dim(x)[MARGIN]
, , 1

     [,1] [,2] [,3]
[1,]    0    4    8
[2,]    0    4    8
[3,]    2    6   10
[4,]    2    6   10

, , 2

     [,1] [,2] [,3]
[1,]   12   16   20
[2,]   12   16   20
[3,]   14   18   22
[4,]   14   18   22

> 
> ## Using named dimnames
> 
> dimnames(A) <- list(fee=1:4, fie=1:3, fum=1:2)
> 
> mn_fum_fie <- apply(A, c("fum", "fie"), mean)
> mn_fum_fie
   fie
fum    1    2    3
  1  2.5  6.5 10.5
  2 14.5 18.5 22.5
> sweep(A, c("fum", "fie"), mn_fum_fie)
, , fum = 1

   fie
fee    1    2    3
  1 -1.5 -1.5 -1.5
  2 -0.5 -0.5 -0.5
  3  0.5  0.5  0.5
  4  1.5  1.5  1.5

, , fum = 2

   fie
fee    1    2    3
  1 -1.5 -1.5 -1.5
  2 -0.5 -0.5 -0.5
  3  0.5  0.5  0.5
  4  1.5  1.5  1.5

> 
> 
> 
> cleanEx()
> nameEx("switch")
> ### * switch
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: switch
> ### Title: Select One of a List of Alternatives
> ### Aliases: switch
> ### Keywords: programming
> 
> ### ** Examples
> 
> require(stats)
> centre <- function(x, type) {
+   switch(type,
+          mean = mean(x),
+          median = median(x),
+          trimmed = mean(x, trim = .1))
+ }
> x <- rcauchy(10)
> centre(x, "mean")
[1] -0.4844658
> centre(x, "median")
[1] -0.236111
> centre(x, "trimmed")
[1] -0.3632328
> 
> ccc <- c("b","QQ","a","A","bb")
> # note: cat() produces no output for NULL
> for(ch in ccc)
+     cat(ch,":", switch(EXPR = ch, a = 1, b = 2:3), "\n")
b : 2 3 
QQ : 
a : 1 
A : 
bb : 
> for(ch in ccc)
+     cat(ch,":", switch(EXPR = ch, a =, A = 1, b = 2:3, "Otherwise: last"),"\n")
b : 2 3 
QQ : Otherwise: last 
a : 1 
A : 1 
bb : Otherwise: last 
> 
> ## switch(f, *) with a factor f
> ff <- gl(3,1, labels=LETTERS[3:1])
> ff[1] # C
[1] C
Levels: C B A
> ## so one might expect " is C" here, but
> switch(ff[1], A = "I am A", B="Bb..", C=" is C")# -> "I am A"
Warning in switch(ff[1], A = "I am A", B = "Bb..", C = " is C") :
  EXPR is a "factor", treated as integer.
 Consider using 'switch(as.character( * ), ...)' instead.
[1] "I am A"
> ## so we give a warning
> 
> ## Numeric EXPR does not allow a default value to be specified
> ## -- it is always NULL
> for(i in c(-1:3, 9))  print(switch(i, 1, 2 , 3, 4))
NULL
NULL
[1] 1
[1] 2
[1] 3
NULL
> 
> ## visibility
> switch(1, invisible(pi), pi)
> switch(2, invisible(pi), pi)
[1] 3.141593
> 
> 
> 
> cleanEx()
> nameEx("sys.parent")
> ### * sys.parent
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sys.parent
> ### Title: Functions to Access the Function Call Stack
> ### Aliases: sys.parent sys.call sys.calls sys.frame sys.frames sys.nframe
> ###   sys.function sys.parents sys.on.exit sys.status parent.frame
> ### Keywords: programming data
> 
> ### ** Examples
> 
> 
> cleanEx()
> nameEx("sys.source")
> ### * sys.source
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sys.source
> ### Title: Parse and Evaluate Expressions from a File
> ### Aliases: sys.source
> ### Keywords: file utilities
> 
> ### ** Examples
> 
> ## a simple way to put some objects in an environment
> ## high on the search path
> tmp <- tempfile()
> writeLines("aaa <- pi", tmp)
> env <- attach(NULL, name = "myenv")
> sys.source(tmp, env)
> unlink(tmp)
> search()
 [1] ".GlobalEnv"        "myenv"             "CheckExEnv"       
 [4] "package:stats"     "package:graphics"  "package:grDevices"
 [7] "package:utils"     "package:datasets"  "package:methods"  
[10] "Autoloads"         "package:base"     
> aaa
[1] 3.141593
> detach("myenv")
> 
> 
> 
> cleanEx()
> nameEx("system")
> ### * system
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: system
> ### Title: Invoke a System Command
> ### Aliases: system shell
> ### Keywords: interface file utilities
> 
> ### ** Examples
> 
> # list all files in the current directory using the -F flag
> ## Not run: system("ls -F")
> 
> # t1 is a character vector, each element giving a line of output from who
> # (if the platform has who)
> t1 <- try(system("who", intern = TRUE))
> 
> try(system("ls fizzlipuzzli", intern = TRUE, ignore.stderr = TRUE))
Warning in system("ls fizzlipuzzli", intern = TRUE, ignore.stderr = TRUE) :
  running command 'ls fizzlipuzzli 2>/dev/null' had status 2
character(0)
attr(,"status")
[1] 2
> # zero-length result since file does not exist, and will give warning.
> 
> 
> 
> cleanEx()
> nameEx("system.file")
> ### * system.file
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: system.file
> ### Title: Find Names of R System Files
> ### Aliases: system.file
> ### Keywords: file utilities
> 
> ### ** Examples
> 
> system.file()                  # The root of the 'base' package
[1] "/usr/local/lib/R/library/base"
> system.file(package = "stats") # The root of package 'stats'
[1] "/usr/local/lib/R/library/stats"
> system.file("INDEX")
[1] "/usr/local/lib/R/library/base/INDEX"
> system.file("help", "AnIndex", package = "splines")
[1] "/usr/local/lib/R/library/splines/help/AnIndex"
> 
> 
> 
> cleanEx()
> nameEx("system.time")
> ### * system.time
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: system.time
> ### Title: CPU Time Used
> ### Aliases: system.time
> ### Keywords: utilities
> 
> ### ** Examples
> 
> require(stats)
> ## Not run: 
> ##D exT <- function(n = 10000) {
> ##D   # Purpose: Test if system.time works ok;   n: loop size
> ##D   system.time(for(i in 1:n) x <- mean(rt(1000, df = 4)))
> ##D }
> ##D #-- Try to interrupt one of the following (using Ctrl-C / Escape):
> ##D exT()                 #- about 4 secs on a 2.5GHz Xeon
> ##D system.time(exT())    #~ +/- same
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("t")
> ### * t
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: t
> ### Title: Matrix Transpose
> ### Aliases: t t.default t.data.frame
> ### Keywords: array
> 
> ### ** Examples
> 
> a <- matrix(1:30, 5, 6)
> ta <- t(a) ##-- i.e.,  a[i, j] == ta[j, i] for all i,j :
> for(j in seq(ncol(a)))
+   if(! all(a[, j] == ta[j, ])) stop("wrong transpose")
> 
> 
> 
> cleanEx()
> nameEx("table")
> ### * table
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: table
> ### Title: Cross Tabulation and Table Creation
> ### Aliases: table summary.table print.summary.table as.data.frame.table
> ###   as.table as.table.default is.table [.table
> ### Keywords: category
> 
> ### ** Examples
> 
> require(stats) # for rpois and xtabs
> ## Simple frequency distribution
> table(rpois(100, 5))

 1  2  3  4  5  6  7  8  9 11 
 2  7 12 22 15 16 15  7  3  1 
> ## Check the design:
> with(warpbreaks, table(wool, tension))
    tension
wool L M H
   A 9 9 9
   B 9 9 9
> table(state.division, state.region)
                    state.region
state.division       Northeast South North Central West
  New England                6     0             0    0
  Middle Atlantic            3     0             0    0
  South Atlantic             0     8             0    0
  East South Central         0     4             0    0
  West South Central         0     4             0    0
  East North Central         0     0             5    0
  West North Central         0     0             7    0
  Mountain                   0     0             0    8
  Pacific                    0     0             0    5
> 
> # simple two-way contingency table
> with(airquality, table(cut(Temp, quantile(Temp)), Month))
         Month
           5  6  7  8  9
  (56,72] 24  3  0  1 10
  (72,79]  5 15  2  9 10
  (79,85]  1  7 19  7  5
  (85,97]  0  5 10 14  5
> 
> a <- letters[1:3]
> table(a, sample(a))                    # dnn is c("a", "")
   
a   a b c
  a 1 0 0
  b 0 0 1
  c 0 1 0
> table(a, sample(a), deparse.level = 0) # dnn is c("", "")
   
    a b c
  a 0 0 1
  b 0 1 0
  c 1 0 0
> table(a, sample(a), deparse.level = 2) # dnn is c("a", "sample(a)")
   sample(a)
a   a b c
  a 1 0 0
  b 0 0 1
  c 0 1 0
> 
> ## xtabs() <-> as.data.frame.table() :
> UCBAdmissions ## already a contingency table
, , Dept = A

          Gender
Admit      Male Female
  Admitted  512     89
  Rejected  313     19

, , Dept = B

          Gender
Admit      Male Female
  Admitted  353     17
  Rejected  207      8

, , Dept = C

          Gender
Admit      Male Female
  Admitted  120    202
  Rejected  205    391

, , Dept = D

          Gender
Admit      Male Female
  Admitted  138    131
  Rejected  279    244

, , Dept = E

          Gender
Admit      Male Female
  Admitted   53     94
  Rejected  138    299

, , Dept = F

          Gender
Admit      Male Female
  Admitted   22     24
  Rejected  351    317

> DF <- as.data.frame(UCBAdmissions)
> class(tab <- xtabs(Freq ~ ., DF)) # xtabs & table
[1] "xtabs" "table"
> ## tab *is* "the same" as the original table:
> all(tab == UCBAdmissions)
[1] TRUE
> all.equal(dimnames(tab), dimnames(UCBAdmissions))
[1] TRUE
> 
> a <- rep(c(NA, 1/0:3), 10)
> table(a)                 # does not report NA's
a
0.333333333333333               0.5                 1               Inf 
               10                10                10                10 
> table(a, exclude = NULL) # reports NA's
a
0.333333333333333               0.5                 1               Inf 
               10                10                10                10 
             <NA> 
               10 
> b <- factor(rep(c("A","B","C"), 10))
> table(b)
b
 A  B  C 
10 10 10 
> table(b, exclude = "B")
b
 A  C 
10 10 
> d <- factor(rep(c("A","B","C"), 10), levels = c("A","B","C","D","E"))
> table(d, exclude = "B")
d
 A  C  D  E 
10 10  0  0 
> print(table(b, d), zero.print = ".")
   d
b    A  B  C D E
  A 10  .  . . .
  B  . 10  . . .
  C  .  . 10 . .
> 
> ## NA counting:
> is.na(d) <- 3:4
> d. <- addNA(d)
> d.[1:7]
[1] A    B    <NA> <NA> B    C    A   
Levels: A B C D E <NA>
> table(d.) # ", exclude = NULL" is not needed
d.
   A    B    C    D    E <NA> 
   9   10    9    0    0    2 
> ## i.e., if you want to count the NA's of 'd', use
> table(d, useNA = "ifany")
d
   A    B    C    D    E <NA> 
   9   10    9    0    0    2 
> 
> ## "pathological" case:
> d.patho <- addNA(c(1,NA,1:2,1:3))[-7]; is.na(d.patho) <- 3:4
> d.patho
[1] 1    <NA> <NA> <NA> 1    2   
Levels: 1 2 3 <NA>
> ## just 3 consecutive NA's ? --- well, have *two* kinds of NAs here :
> as.integer(d.patho) # 1 4 NA NA 1 2
[1]  1  4 NA NA  1  2
> ##
> ## In R >= 3.4.0, table() allows to differentiate:
> table(d.patho)                   # counts the "unusual" NA
d.patho
   1    2    3 <NA> 
   2    1    0    1 
> table(d.patho, useNA = "ifany")  # counts all three
d.patho
   1    2    3 <NA> 
   2    1    0    3 
> table(d.patho, exclude = NULL)   #  (ditto)
d.patho
   1    2    3 <NA> 
   2    1    0    3 
> table(d.patho, exclude = NA)     # counts none
d.patho
1 2 3 
2 1 0 
> 
> ## Two-way tables with NA counts. The 3rd variant is absurd, but shows
> ## something that cannot be done using exclude or useNA.
> with(airquality,
+    table(OzHi = Ozone > 80, Month, useNA = "ifany"))
       Month
OzHi     5  6  7  8  9
  FALSE 25  9 20 19 27
  TRUE   1  0  6  7  2
  <NA>   5 21  5  5  1
> with(airquality,
+    table(OzHi = Ozone > 80, Month, useNA = "always"))
       Month
OzHi     5  6  7  8  9 <NA>
  FALSE 25  9 20 19 27    0
  TRUE   1  0  6  7  2    0
  <NA>   5 21  5  5  1    0
> with(airquality,
+    table(OzHi = Ozone > 80, addNA(Month)))
       
OzHi     5  6  7  8  9 <NA>
  FALSE 25  9 20 19 27    0
  TRUE   1  0  6  7  2    0
> 
> 
> 
> cleanEx()
> nameEx("tabulate")
> ### * tabulate
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: tabulate
> ### Title: Tabulation for Vectors
> ### Aliases: tabulate
> ### Keywords: arith
> 
> ### ** Examples
> 
> tabulate(c(2,3,5))
[1] 0 1 1 0 1
> tabulate(c(2,3,3,5), nbins = 10)
 [1] 0 1 2 0 1 0 0 0 0 0
> tabulate(c(-2,0,2,3,3,5))  # -2 and 0 are ignored
[1] 0 1 2 0 1
> tabulate(c(-2,0,2,3,3,5), nbins = 3)
[1] 0 1 2
> tabulate(factor(letters[1:10]))
 [1] 1 1 1 1 1 1 1 1 1 1
> 
> 
> 
> cleanEx()
> nameEx("tapply")
> ### * tapply
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: tapply
> ### Title: Apply a Function Over a Ragged Array
> ### Aliases: tapply
> ### Keywords: iteration category
> 
> ### ** Examples
> 
> require(stats)
> groups <- as.factor(rbinom(32, n = 5, prob = 0.4))
> tapply(groups, groups, length) #- is almost the same as
10 11 12 13 17 
 1  1  1  1  1 
> table(groups)
groups
10 11 12 13 17 
 1  1  1  1  1 
> 
> ## contingency table from data.frame : array with named dimnames
> tapply(warpbreaks$breaks, warpbreaks[,-1], sum)
    tension
wool   L   M   H
   A 401 216 221
   B 254 259 169
> tapply(warpbreaks$breaks, warpbreaks[, 3, drop = FALSE], sum)
tension
  L   M   H 
655 475 390 
> 
> n <- 17; fac <- factor(rep_len(1:3, n), levels = 1:5)
> table(fac)
fac
1 2 3 4 5 
6 6 5 0 0 
> tapply(1:n, fac, sum)
 1  2  3  4  5 
51 57 45 NA NA 
> tapply(1:n, fac, sum, default = 0) # maybe more desirable
 1  2  3  4  5 
51 57 45  0  0 
> tapply(1:n, fac, sum, simplify = FALSE)
$`1`
[1] 51

$`2`
[1] 57

$`3`
[1] 45

$`4`
NULL

$`5`
NULL

> tapply(1:n, fac, range)
$`1`
[1]  1 16

$`2`
[1]  2 17

$`3`
[1]  3 15

$`4`
NULL

$`5`
NULL

> tapply(1:n, fac, quantile)
$`1`
   0%   25%   50%   75%  100% 
 1.00  4.75  8.50 12.25 16.00 

$`2`
   0%   25%   50%   75%  100% 
 2.00  5.75  9.50 13.25 17.00 

$`3`
  0%  25%  50%  75% 100% 
   3    6    9   12   15 

$`4`
NULL

$`5`
NULL

> tapply(1:n, fac, length) ## NA's
 1  2  3  4  5 
 6  6  5 NA NA 
> tapply(1:n, fac, length, default = 0) # == table(fac)
1 2 3 4 5 
6 6 5 0 0 
> ## Don't show: 
> stopifnot(all.equal(
+   unname(unclass(table(fac))),
+   unname(        tapply(1:n, fac, length, default = 0))))
> ## End(Don't show)
> ## example of ... argument: find quarterly means
> tapply(presidents, cycle(presidents), mean, na.rm = TRUE)
       1        2        3        4 
58.44828 56.43333 57.22222 53.07143 
> 
> ind <- list(c(1, 2, 2), c("A", "A", "B"))
> table(ind)
     ind.2
ind.1 A B
    1 1 0
    2 1 1
> tapply(1:3, ind) #-> the split vector
[1] 1 2 4
> tapply(1:3, ind, sum)
  A  B
1 1 NA
2 2  3
> 
> ## Some assertions (not held by all patch propsals):
> nq <- names(quantile(1:5))
> stopifnot(
+   identical(tapply(1:3, ind), c(1L, 2L, 4L)),
+   identical(tapply(1:3, ind, sum),
+             matrix(c(1L, 2L, NA, 3L), 2, dimnames = list(c("1", "2"), c("A", "B")))),
+   identical(tapply(1:n, fac, quantile)[-1],
+             array(list(`2` = structure(c(2, 5.75, 9.5, 13.25, 17), .Names = nq),
+                  `3` = structure(c(3, 6, 9, 12, 15), .Names = nq),
+                  `4` = NULL, `5` = NULL), dim=4, dimnames=list(as.character(2:5)))))
> 
> 
> 
> cleanEx()
> nameEx("taskCallback")
> ### * taskCallback
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: taskCallback
> ### Title: Add or Remove a Top-Level Task Callback
> ### Aliases: addTaskCallback removeTaskCallback
> ### Keywords: environment
> 
> ### ** Examples
> 
> times <- function(total = 3, str = "Task a") {
+   ctr <- 0
+   function(expr, value, ok, visible) {
+     ctr <<- ctr + 1
+     cat(str, ctr, "\n")
+     keep.me <- (ctr < total)
+     if (!keep.me)
+       cat("handler removing itself\n")
+ 
+     # return
+     keep.me
+   }
+ }
> 
> # add the callback that will work for
> # 4 top-level tasks and then remove itself.
> n <- addTaskCallback(times(4))
Task a 1 
> 
> # now remove it, assuming it is still first in the list.
> removeTaskCallback(n)
[1] TRUE
> 
> ## See how the handler is called every time till "self destruction":
> 
> addTaskCallback(times(4)) # counts as once already
1 
1 
Task a 1 
> 
> sum(1:10) ; mean(1:3) # two more
[1] 55
Task a 2 
[1] 2
Task a 3 
> sinpi(1)              # 4th - and "done"
[1] 0
Task a 4 
handler removing itself
> cospi(1)
[1] -1
> tanpi(1)
[1] 0
> 
> 
> 
> cleanEx()
> nameEx("taskCallbackManager")
> ### * taskCallbackManager
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: taskCallbackManager
> ### Title: Create an R-level Task Callback Manager
> ### Aliases: taskCallbackManager
> ### Keywords: environment
> 
> ### ** Examples
> 
> # create the manager
> h <- taskCallbackManager()
> 
> # add a callback
> h$add(function(expr, value, ok, visible) {
+                        cat("In handler\n")
+                        return(TRUE)
+                      }, name = "simpleHandler")
[1] "simpleHandler"
In handler
> 
> # look at the internal callbacks.
> getTaskCallbackNames()
[1] "R-taskCallbackManager"
In handler
> 
> # look at the R-level callbacks
> names(h$callbacks())
[1] "simpleHandler"
In handler
> 
> removeTaskCallback("R-taskCallbackManager")
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("taskCallbackNames")
> ### * taskCallbackNames
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: taskCallbackNames
> ### Title: Query the Names of the Current Internal Top-Level Task Callbacks
> ### Aliases: getTaskCallbackNames
> ### Keywords: environment
> 
> ### ** Examples
> 
>  n <- addTaskCallback(function(expr, value, ok, visible) {
+                         cat("In handler\n")
+                         return(TRUE)
+                       }, name = "simpleHandler")
In handler
> 
>  getTaskCallbackNames()
[1] "simpleHandler"
In handler
> 
>    # now remove it by name
>  removeTaskCallback("simpleHandler")
[1] TRUE
> 
> 
>  h <- taskCallbackManager()
>  h$add(function(expr, value, ok, visible) {
+                         cat("In handler\n")
+                         return(TRUE)
+                       }, name = "simpleHandler")
[1] "simpleHandler"
In handler
>  getTaskCallbackNames()
[1] "R-taskCallbackManager"
In handler
>  removeTaskCallback("R-taskCallbackManager")
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("tempfile")
> ### * tempfile
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: tempfile
> ### Title: Create Names for Temporary Files
> ### Aliases: tempfile tempdir
> ### Keywords: file
> 
> ### ** Examples
> 
> ## Show how 'check' is working on some platforms:
> if(exists("I'm brave") && `I'm brave` &&
+    identical(.Platform$OS.type, "unix") && grepl("^/tmp/", tempdir())) {
+   cat("Current tempdir(): ", tempdir(), "\n")
+   cat("Removing it :", file.remove(tempdir()),
+       "; dir.exists(tempdir()):", dir.exists(tempdir()), "\n")
+   cat("and now  tempdir(check = TRUE) :", tempdir(check = TRUE),"\n")
+ }
> 
> 
> 
> 
> cleanEx()
> nameEx("textconnections")
> ### * textconnections
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: textConnection
> ### Title: Text Connections
> ### Aliases: textConnection textConnectionValue
> ### Keywords: file connection
> 
> ### ** Examples
> 
> zz <- textConnection(LETTERS)
> readLines(zz, 2)
[1] "A" "B"
> scan(zz, "", 4)
Read 4 items
[1] "C" "D" "E" "F"
> pushBack(c("aa", "bb"), zz)
> scan(zz, "", 4)
Read 4 items
[1] "aa" "bb" "G"  "H" 
> close(zz)
> 
> zz <- textConnection("foo", "w")
> writeLines(c("testit1", "testit2"), zz)
> cat("testit3 ", file = zz)
> isIncomplete(zz)
[1] TRUE
> cat("testit4\n", file = zz)
> isIncomplete(zz)
[1] FALSE
> close(zz)
> foo
[1] "testit1"         "testit2"         "testit3 testit4"
> 
> 
> 
> 
> cleanEx()
> nameEx("timezones")
> ### * timezones
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: timezones
> ### Title: Time Zones
> ### Aliases: Sys.timezone OlsonNames timezone timezones 'time zone' 'time
> ###   zones' TZ TZDIR .sys.timezone
> ### Keywords: utilities chron
> 
> ### ** Examples
> 
> Sys.timezone()
[1] "Etc/UTC"
> 
> str(OlsonNames()) ## typically close to 600 hundred names,
 chr [1:607] "Africa/Abidjan" "Africa/Accra" "Africa/Addis_Ababa" ...
> ## typically some acronyms/aliases such as "UTC", "NZ", "MET", "Eire", ..., but
> ## mostly pairs (and triplets) such as "Pacific/Auckland"
> table(sl <- grepl("/", OlsonNames()))

FALSE  TRUE 
   45   562 
> OlsonNames()[ !sl ] # the simple ones
 [1] "CET"       "CST6CDT"   "Cuba"      "EET"       "Egypt"     "Eire"     
 [7] "EST"       "EST5EDT"   "Factory"   "GB"        "GB-Eire"   "GMT"      
[13] "GMT-0"     "GMT+0"     "GMT0"      "Greenwich" "Hongkong"  "HST"      
[19] "Iceland"   "Iran"      "Israel"    "Jamaica"   "Japan"     "Kwajalein"
[25] "Libya"     "MET"       "MST"       "MST7MDT"   "Navajo"    "NZ"       
[31] "NZ-CHAT"   "Poland"    "Portugal"  "PRC"       "PST8PDT"   "ROC"      
[37] "ROK"       "Singapore" "Turkey"    "UCT"       "Universal" "UTC"      
[43] "W-SU"      "WET"       "Zulu"     
> head(Osl <- strsplit(OlsonNames()[sl], "/"))
[[1]]
[1] "Africa"  "Abidjan"

[[2]]
[1] "Africa" "Accra" 

[[3]]
[1] "Africa"      "Addis_Ababa"

[[4]]
[1] "Africa"  "Algiers"

[[5]]
[1] "Africa" "Asmara"

[[6]]
[1] "Africa" "Asmera"

> (tOS1 <- table(vapply(Osl, `[[`, "", 1))) # Continents, countries, ...

    Africa    America Antarctica     Arctic       Asia   Atlantic  Australia 
        54        167         12          1         99         12         23 
    Brazil     Canada      Chile        Etc     Europe     Indian     Mexico 
         4          8          2         35         63         11          3 
   Pacific    SystemV         US 
        43         13         12 
> table(lengths(Osl))# most are pairs, some triplets

  2   3 
536  26 
> str(Osl[lengths(Osl) >= 3])# "America" South and North ...
List of 26
 $ : chr [1:3] "America" "Argentina" "Buenos_Aires"
 $ : chr [1:3] "America" "Argentina" "Catamarca"
 $ : chr [1:3] "America" "Argentina" "ComodRivadavia"
 $ : chr [1:3] "America" "Argentina" "Cordoba"
 $ : chr [1:3] "America" "Argentina" "Jujuy"
 $ : chr [1:3] "America" "Argentina" "La_Rioja"
 $ : chr [1:3] "America" "Argentina" "Mendoza"
 $ : chr [1:3] "America" "Argentina" "Rio_Gallegos"
 $ : chr [1:3] "America" "Argentina" "Salta"
 $ : chr [1:3] "America" "Argentina" "San_Juan"
 $ : chr [1:3] "America" "Argentina" "San_Luis"
 $ : chr [1:3] "America" "Argentina" "Tucuman"
 $ : chr [1:3] "America" "Argentina" "Ushuaia"
 $ : chr [1:3] "America" "Indiana" "Indianapolis"
 $ : chr [1:3] "America" "Indiana" "Knox"
 $ : chr [1:3] "America" "Indiana" "Marengo"
 $ : chr [1:3] "America" "Indiana" "Petersburg"
 $ : chr [1:3] "America" "Indiana" "Tell_City"
 $ : chr [1:3] "America" "Indiana" "Vevay"
 $ : chr [1:3] "America" "Indiana" "Vincennes"
 $ : chr [1:3] "America" "Indiana" "Winamac"
 $ : chr [1:3] "America" "Kentucky" "Louisville"
 $ : chr [1:3] "America" "Kentucky" "Monticello"
 $ : chr [1:3] "America" "North_Dakota" "Beulah"
 $ : chr [1:3] "America" "North_Dakota" "Center"
 $ : chr [1:3] "America" "North_Dakota" "New_Salem"
> 
> 
> 
> cleanEx()
> nameEx("toString")
> ### * toString
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: toString
> ### Title: Convert an R Object to a Character String
> ### Aliases: toString toString.default
> ### Keywords: utilities
> 
> ### ** Examples
> 
> x <- c("a", "b", "aaaaaaaaaaa")
> toString(x)
[1] "a, b, aaaaaaaaaaa"
> toString(x, width = 8)
[1] "a, b...."
> 
> 
> 
> cleanEx()
> nameEx("trace")
> ### * trace
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: trace
> ### Title: Interactive Tracing and Debugging of Calls to a Function or
> ###   Method
> ### Aliases: trace untrace tracingState .doTrace returnValue
> ### Keywords: programming debugging
> 
> ### ** Examples
> 
> require(stats)
> 
> ##  Very simple use
> trace(sum)
> hist(rnorm(100)) # shows about 3-4 calls to sum()
trace: sum
trace: sum
trace: sum
> untrace(sum)
> 
> ## Show how pt() is called from inside power.t.test():
> if(FALSE)
+   trace(pt) ## would show ~20 calls, but we want to see more:
> trace(pt, tracer = quote(cat(sprintf("tracing pt(*, ncp = %.15g)\n", ncp))),
+       print = FALSE) # <- not showing typical extra
Tracing function "pt" in package "stats"
[1] "pt"
> power.t.test(20, 1, power=0.8, sd=NULL)  ##--> showing the ncp root finding:
tracing pt(*, ncp = 31622776.6016838)
tracing pt(*, ncp = 3.16227766016838e-07)
tracing pt(*, ncp = 1.54161033083713e-06)
tracing pt(*, ncp = 7.51534968562983e-06)
tracing pt(*, ncp = 3.66373136232471e-05)
tracing pt(*, ncp = 0.000178606521414343)
tracing pt(*, ncp = 0.000870697700373358)
tracing pt(*, ncp = 0.00424443508523481)
tracing pt(*, ncp = 0.0206864667531106)
tracing pt(*, ncp = 0.100722153608784)
tracing pt(*, ncp = 0.48783816205104)
tracing pt(*, ncp = 2.27122420983028)
tracing pt(*, ncp = 4.54127936549001)
tracing pt(*, ncp = 3.04551810443699)
tracing pt(*, ncp = 2.82497901757656)
tracing pt(*, ncp = 2.87564199633926)
tracing pt(*, ncp = 2.87492378604085)
tracing pt(*, ncp = 2.87476426843053)
tracing pt(*, ncp = 2.87492378604085)

     Two-sample t test power calculation 

              n = 20
          delta = 1
             sd = 1.099952
      sig.level = 0.05
          power = 0.8
    alternative = two.sided

NOTE: n is number in *each* group

> untrace(pt)
Untracing function "pt" in package "stats"
> 
> f <- function(x, y) {
+     y <- pmax(y, 0.001)
+     if (x > 0) x ^ y else stop("x must be positive")
+ }
> 
> ## arrange to call the browser on entering and exiting
> ## function f
> trace("f", quote(browser(skipCalls = 4)),
+       exit = quote(browser(skipCalls = 4)))
[1] "f"
> 
> ## instead, conditionally assign some data, and then browse
> ## on exit, but only then.  Don't bother me otherwise
> 
> trace("f", quote(if(any(y < 0)) yOrig <- y),
+       exit = quote(if(exists("yOrig")) browser(skipCalls = 4)),
+       print = FALSE)
[1] "f"
> 
> ## Enter the browser just before stop() is called.  First, find
> ## the step numbers
> 
> untrace(f) # (as it has changed f's body !)
> as.list(body(f))
[[1]]
`{`

[[2]]
y <- pmax(y, 0.001)

[[3]]
if (x > 0) x^y else stop("x must be positive")

> as.list(body(f)[[3]]) # -> stop(..) is [[4]]
[[1]]
`if`

[[2]]
x > 0

[[3]]
x^y

[[4]]
stop("x must be positive")

> 
> ## Now call the browser there
> 
> trace("f", quote(browser(skipCalls = 4)), at = list(c(3,4)))
[1] "f"
> ## Not run: 
> ##D f(-1,2) # --> enters browser just before stop(..)
> ## End(Not run)
> 
> ## trace a utility function, with recover so we
> ## can browse in the calling functions as well.
> 
> trace("as.matrix", recover)
Tracing function "as.matrix" in package "base"
[1] "as.matrix"
> 
> ## turn off the tracing (that happened above)
> 
> untrace(c("f", "as.matrix"))
Untracing function "as.matrix" in package "base"
> 
> ## Not run: 
> ##D ## Useful to find how system2() is called in a higher-up function:
> ##D trace(base::system2, quote(print(ls.str())))
> ## End(Not run)
> 
> ##-------- Tracing hidden functions : need 'where = *'
> ##
> ## 'where' can be a function whose environment is meant:
> trace(quote(ar.yw.default), where = ar)
Tracing function "ar.yw.default" as seen from package "stats"
[1] "ar.yw.default"
> a <- ar(rnorm(100)) # "Tracing ..."
Tracing ar.yw.default(x, aic = aic, order.max = order.max, na.action = na.action,  .... on entry 
> untrace(quote(ar.yw.default), where = ar)
Untracing function "ar.yw.default" as seen from package "stats"
> 
> ## trace() more than one function simultaneously:
> ##         expression(E1, E2, ...)  here is equivalent to
> ##          c(quote(E1), quote(E2), quote(.*), ..)
> trace(expression(ar.yw, ar.yw.default), where = ar)
Tracing function "ar.yw" in package "namespace:stats"
Tracing function "ar.yw.default" in package "namespace:stats"
[1] "ar.yw"         "ar.yw.default"
> a <- ar(rnorm(100)) # --> 2 x "Tracing ..."
Tracing ar.yw(x, aic = aic, order.max = order.max, na.action = na.action,  .... on entry 
Tracing ar.yw.default(x, aic = aic, order.max = order.max, na.action = na.action,  .... on entry 
> # and turn it off:
> untrace(expression(ar.yw, ar.yw.default), where = ar)
Untracing function "ar.yw" in package "namespace:stats"
Untracing function "ar.yw.default" in package "namespace:stats"
> 
> 
> ## Not run: 
> ##D ## trace calls to the function lm() that come from
> ##D ## the nlme package.
> ##D ## (The function nlme is in that package, and the package
> ##D ## has a namespace, so the where= argument must be used
> ##D ## to get the right version of lm)
> ##D 
> ##D trace(lm, exit = recover, where = asNamespace("nlme"))
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("traceback")
> ### * traceback
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: traceback
> ### Title: Get and Print Call Stacks
> ### Aliases: traceback .traceback .Traceback
> ### Keywords: programming
> 
> ### ** Examples
> 
> foo <- function(x) { print(1); bar(2) }
> bar <- function(x) { x + a.variable.which.does.not.exist }
> ## Not run: 
> ##D foo(2) # gives a strange error
> ##D traceback()
> ## End(Not run)
> ## 2: bar(2)
> ## 1: foo(2)
> bar
function (x) 
{
    x + a.variable.which.does.not.exist
}
> ## Ah, this is the culprit ...
> 
> ## This will print the stack trace at the time of the error.
> options(error = function() traceback(3))
> 
> 
> 
> cleanEx()
> nameEx("tracemem")
> ### * tracemem
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: tracemem
> ### Title: Trace Copying of Objects
> ### Aliases: tracemem untracemem retracemem
> ### Keywords: utilities
> 
> ### ** Examples
> ## Not run: 
> ##D a <- 1:10
> ##D tracemem(a)
> ##D ## b and a share memory
> ##D b <- a
> ##D b[1] <- 1
> ##D untracemem(a)
> ##D 
> ##D ## copying in lm: less than R <= 2.15.0
> ##D d <- stats::rnorm(10)
> ##D tracemem(d)
> ##D lm(d ~ a+log(b))
> ##D 
> ##D ## f is not a copy and is not traced
> ##D f <- d[-1]
> ##D f+1
> ##D ## indicate that f should be traced as a copy of d
> ##D retracemem(f, retracemem(d))
> ##D f+1
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("transform")
> ### * transform
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: transform
> ### Title: Transform an Object, for Example a Data Frame
> ### Aliases: transform transform.default transform.data.frame
> ### Keywords: manip
> 
> ### ** Examples
> 
> transform(airquality, Ozone = -Ozone)
    Ozone Solar.R Wind Temp Month Day
1     -41     190  7.4   67     5   1
2     -36     118  8.0   72     5   2
3     -12     149 12.6   74     5   3
4     -18     313 11.5   62     5   4
5      NA      NA 14.3   56     5   5
6     -28      NA 14.9   66     5   6
7     -23     299  8.6   65     5   7
8     -19      99 13.8   59     5   8
9      -8      19 20.1   61     5   9
10     NA     194  8.6   69     5  10
11     -7      NA  6.9   74     5  11
12    -16     256  9.7   69     5  12
13    -11     290  9.2   66     5  13
14    -14     274 10.9   68     5  14
15    -18      65 13.2   58     5  15
16    -14     334 11.5   64     5  16
17    -34     307 12.0   66     5  17
18     -6      78 18.4   57     5  18
19    -30     322 11.5   68     5  19
20    -11      44  9.7   62     5  20
21     -1       8  9.7   59     5  21
22    -11     320 16.6   73     5  22
23     -4      25  9.7   61     5  23
24    -32      92 12.0   61     5  24
25     NA      66 16.6   57     5  25
26     NA     266 14.9   58     5  26
27     NA      NA  8.0   57     5  27
28    -23      13 12.0   67     5  28
29    -45     252 14.9   81     5  29
30   -115     223  5.7   79     5  30
31    -37     279  7.4   76     5  31
32     NA     286  8.6   78     6   1
33     NA     287  9.7   74     6   2
34     NA     242 16.1   67     6   3
35     NA     186  9.2   84     6   4
36     NA     220  8.6   85     6   5
37     NA     264 14.3   79     6   6
38    -29     127  9.7   82     6   7
39     NA     273  6.9   87     6   8
40    -71     291 13.8   90     6   9
41    -39     323 11.5   87     6  10
42     NA     259 10.9   93     6  11
43     NA     250  9.2   92     6  12
44    -23     148  8.0   82     6  13
45     NA     332 13.8   80     6  14
46     NA     322 11.5   79     6  15
47    -21     191 14.9   77     6  16
48    -37     284 20.7   72     6  17
49    -20      37  9.2   65     6  18
50    -12     120 11.5   73     6  19
51    -13     137 10.3   76     6  20
52     NA     150  6.3   77     6  21
53     NA      59  1.7   76     6  22
54     NA      91  4.6   76     6  23
55     NA     250  6.3   76     6  24
56     NA     135  8.0   75     6  25
57     NA     127  8.0   78     6  26
58     NA      47 10.3   73     6  27
59     NA      98 11.5   80     6  28
60     NA      31 14.9   77     6  29
61     NA     138  8.0   83     6  30
62   -135     269  4.1   84     7   1
63    -49     248  9.2   85     7   2
64    -32     236  9.2   81     7   3
65     NA     101 10.9   84     7   4
66    -64     175  4.6   83     7   5
67    -40     314 10.9   83     7   6
68    -77     276  5.1   88     7   7
69    -97     267  6.3   92     7   8
70    -97     272  5.7   92     7   9
71    -85     175  7.4   89     7  10
72     NA     139  8.6   82     7  11
73    -10     264 14.3   73     7  12
74    -27     175 14.9   81     7  13
75     NA     291 14.9   91     7  14
76     -7      48 14.3   80     7  15
77    -48     260  6.9   81     7  16
78    -35     274 10.3   82     7  17
79    -61     285  6.3   84     7  18
80    -79     187  5.1   87     7  19
81    -63     220 11.5   85     7  20
82    -16       7  6.9   74     7  21
83     NA     258  9.7   81     7  22
84     NA     295 11.5   82     7  23
85    -80     294  8.6   86     7  24
86   -108     223  8.0   85     7  25
87    -20      81  8.6   82     7  26
88    -52      82 12.0   86     7  27
89    -82     213  7.4   88     7  28
90    -50     275  7.4   86     7  29
91    -64     253  7.4   83     7  30
92    -59     254  9.2   81     7  31
93    -39      83  6.9   81     8   1
94     -9      24 13.8   81     8   2
95    -16      77  7.4   82     8   3
96    -78      NA  6.9   86     8   4
97    -35      NA  7.4   85     8   5
98    -66      NA  4.6   87     8   6
99   -122     255  4.0   89     8   7
100   -89     229 10.3   90     8   8
101  -110     207  8.0   90     8   9
102    NA     222  8.6   92     8  10
103    NA     137 11.5   86     8  11
104   -44     192 11.5   86     8  12
105   -28     273 11.5   82     8  13
106   -65     157  9.7   80     8  14
107    NA      64 11.5   79     8  15
108   -22      71 10.3   77     8  16
109   -59      51  6.3   79     8  17
110   -23     115  7.4   76     8  18
111   -31     244 10.9   78     8  19
112   -44     190 10.3   78     8  20
113   -21     259 15.5   77     8  21
114    -9      36 14.3   72     8  22
115    NA     255 12.6   75     8  23
116   -45     212  9.7   79     8  24
117  -168     238  3.4   81     8  25
118   -73     215  8.0   86     8  26
119    NA     153  5.7   88     8  27
120   -76     203  9.7   97     8  28
121  -118     225  2.3   94     8  29
122   -84     237  6.3   96     8  30
123   -85     188  6.3   94     8  31
124   -96     167  6.9   91     9   1
125   -78     197  5.1   92     9   2
126   -73     183  2.8   93     9   3
127   -91     189  4.6   93     9   4
128   -47      95  7.4   87     9   5
129   -32      92 15.5   84     9   6
130   -20     252 10.9   80     9   7
131   -23     220 10.3   78     9   8
132   -21     230 10.9   75     9   9
133   -24     259  9.7   73     9  10
134   -44     236 14.9   81     9  11
135   -21     259 15.5   76     9  12
136   -28     238  6.3   77     9  13
137    -9      24 10.9   71     9  14
138   -13     112 11.5   71     9  15
139   -46     237  6.9   78     9  16
140   -18     224 13.8   67     9  17
141   -13      27 10.3   76     9  18
142   -24     238 10.3   68     9  19
143   -16     201  8.0   82     9  20
144   -13     238 12.6   64     9  21
145   -23      14  9.2   71     9  22
146   -36     139 10.3   81     9  23
147    -7      49 10.3   69     9  24
148   -14      20 16.6   63     9  25
149   -30     193  6.9   70     9  26
150    NA     145 13.2   77     9  27
151   -14     191 14.3   75     9  28
152   -18     131  8.0   76     9  29
153   -20     223 11.5   68     9  30
> transform(airquality, new = -Ozone, Temp = (Temp-32)/1.8)
    Ozone Solar.R Wind     Temp Month Day  new
1      41     190  7.4 19.44444     5   1  -41
2      36     118  8.0 22.22222     5   2  -36
3      12     149 12.6 23.33333     5   3  -12
4      18     313 11.5 16.66667     5   4  -18
5      NA      NA 14.3 13.33333     5   5   NA
6      28      NA 14.9 18.88889     5   6  -28
7      23     299  8.6 18.33333     5   7  -23
8      19      99 13.8 15.00000     5   8  -19
9       8      19 20.1 16.11111     5   9   -8
10     NA     194  8.6 20.55556     5  10   NA
11      7      NA  6.9 23.33333     5  11   -7
12     16     256  9.7 20.55556     5  12  -16
13     11     290  9.2 18.88889     5  13  -11
14     14     274 10.9 20.00000     5  14  -14
15     18      65 13.2 14.44444     5  15  -18
16     14     334 11.5 17.77778     5  16  -14
17     34     307 12.0 18.88889     5  17  -34
18      6      78 18.4 13.88889     5  18   -6
19     30     322 11.5 20.00000     5  19  -30
20     11      44  9.7 16.66667     5  20  -11
21      1       8  9.7 15.00000     5  21   -1
22     11     320 16.6 22.77778     5  22  -11
23      4      25  9.7 16.11111     5  23   -4
24     32      92 12.0 16.11111     5  24  -32
25     NA      66 16.6 13.88889     5  25   NA
26     NA     266 14.9 14.44444     5  26   NA
27     NA      NA  8.0 13.88889     5  27   NA
28     23      13 12.0 19.44444     5  28  -23
29     45     252 14.9 27.22222     5  29  -45
30    115     223  5.7 26.11111     5  30 -115
31     37     279  7.4 24.44444     5  31  -37
32     NA     286  8.6 25.55556     6   1   NA
33     NA     287  9.7 23.33333     6   2   NA
34     NA     242 16.1 19.44444     6   3   NA
35     NA     186  9.2 28.88889     6   4   NA
36     NA     220  8.6 29.44444     6   5   NA
37     NA     264 14.3 26.11111     6   6   NA
38     29     127  9.7 27.77778     6   7  -29
39     NA     273  6.9 30.55556     6   8   NA
40     71     291 13.8 32.22222     6   9  -71
41     39     323 11.5 30.55556     6  10  -39
42     NA     259 10.9 33.88889     6  11   NA
43     NA     250  9.2 33.33333     6  12   NA
44     23     148  8.0 27.77778     6  13  -23
45     NA     332 13.8 26.66667     6  14   NA
46     NA     322 11.5 26.11111     6  15   NA
47     21     191 14.9 25.00000     6  16  -21
48     37     284 20.7 22.22222     6  17  -37
49     20      37  9.2 18.33333     6  18  -20
50     12     120 11.5 22.77778     6  19  -12
51     13     137 10.3 24.44444     6  20  -13
52     NA     150  6.3 25.00000     6  21   NA
53     NA      59  1.7 24.44444     6  22   NA
54     NA      91  4.6 24.44444     6  23   NA
55     NA     250  6.3 24.44444     6  24   NA
56     NA     135  8.0 23.88889     6  25   NA
57     NA     127  8.0 25.55556     6  26   NA
58     NA      47 10.3 22.77778     6  27   NA
59     NA      98 11.5 26.66667     6  28   NA
60     NA      31 14.9 25.00000     6  29   NA
61     NA     138  8.0 28.33333     6  30   NA
62    135     269  4.1 28.88889     7   1 -135
63     49     248  9.2 29.44444     7   2  -49
64     32     236  9.2 27.22222     7   3  -32
65     NA     101 10.9 28.88889     7   4   NA
66     64     175  4.6 28.33333     7   5  -64
67     40     314 10.9 28.33333     7   6  -40
68     77     276  5.1 31.11111     7   7  -77
69     97     267  6.3 33.33333     7   8  -97
70     97     272  5.7 33.33333     7   9  -97
71     85     175  7.4 31.66667     7  10  -85
72     NA     139  8.6 27.77778     7  11   NA
73     10     264 14.3 22.77778     7  12  -10
74     27     175 14.9 27.22222     7  13  -27
75     NA     291 14.9 32.77778     7  14   NA
76      7      48 14.3 26.66667     7  15   -7
77     48     260  6.9 27.22222     7  16  -48
78     35     274 10.3 27.77778     7  17  -35
79     61     285  6.3 28.88889     7  18  -61
80     79     187  5.1 30.55556     7  19  -79
81     63     220 11.5 29.44444     7  20  -63
82     16       7  6.9 23.33333     7  21  -16
83     NA     258  9.7 27.22222     7  22   NA
84     NA     295 11.5 27.77778     7  23   NA
85     80     294  8.6 30.00000     7  24  -80
86    108     223  8.0 29.44444     7  25 -108
87     20      81  8.6 27.77778     7  26  -20
88     52      82 12.0 30.00000     7  27  -52
89     82     213  7.4 31.11111     7  28  -82
90     50     275  7.4 30.00000     7  29  -50
91     64     253  7.4 28.33333     7  30  -64
92     59     254  9.2 27.22222     7  31  -59
93     39      83  6.9 27.22222     8   1  -39
94      9      24 13.8 27.22222     8   2   -9
95     16      77  7.4 27.77778     8   3  -16
96     78      NA  6.9 30.00000     8   4  -78
97     35      NA  7.4 29.44444     8   5  -35
98     66      NA  4.6 30.55556     8   6  -66
99    122     255  4.0 31.66667     8   7 -122
100    89     229 10.3 32.22222     8   8  -89
101   110     207  8.0 32.22222     8   9 -110
102    NA     222  8.6 33.33333     8  10   NA
103    NA     137 11.5 30.00000     8  11   NA
104    44     192 11.5 30.00000     8  12  -44
105    28     273 11.5 27.77778     8  13  -28
106    65     157  9.7 26.66667     8  14  -65
107    NA      64 11.5 26.11111     8  15   NA
108    22      71 10.3 25.00000     8  16  -22
109    59      51  6.3 26.11111     8  17  -59
110    23     115  7.4 24.44444     8  18  -23
111    31     244 10.9 25.55556     8  19  -31
112    44     190 10.3 25.55556     8  20  -44
113    21     259 15.5 25.00000     8  21  -21
114     9      36 14.3 22.22222     8  22   -9
115    NA     255 12.6 23.88889     8  23   NA
116    45     212  9.7 26.11111     8  24  -45
117   168     238  3.4 27.22222     8  25 -168
118    73     215  8.0 30.00000     8  26  -73
119    NA     153  5.7 31.11111     8  27   NA
120    76     203  9.7 36.11111     8  28  -76
121   118     225  2.3 34.44444     8  29 -118
122    84     237  6.3 35.55556     8  30  -84
123    85     188  6.3 34.44444     8  31  -85
124    96     167  6.9 32.77778     9   1  -96
125    78     197  5.1 33.33333     9   2  -78
126    73     183  2.8 33.88889     9   3  -73
127    91     189  4.6 33.88889     9   4  -91
128    47      95  7.4 30.55556     9   5  -47
129    32      92 15.5 28.88889     9   6  -32
130    20     252 10.9 26.66667     9   7  -20
131    23     220 10.3 25.55556     9   8  -23
132    21     230 10.9 23.88889     9   9  -21
133    24     259  9.7 22.77778     9  10  -24
134    44     236 14.9 27.22222     9  11  -44
135    21     259 15.5 24.44444     9  12  -21
136    28     238  6.3 25.00000     9  13  -28
137     9      24 10.9 21.66667     9  14   -9
138    13     112 11.5 21.66667     9  15  -13
139    46     237  6.9 25.55556     9  16  -46
140    18     224 13.8 19.44444     9  17  -18
141    13      27 10.3 24.44444     9  18  -13
142    24     238 10.3 20.00000     9  19  -24
143    16     201  8.0 27.77778     9  20  -16
144    13     238 12.6 17.77778     9  21  -13
145    23      14  9.2 21.66667     9  22  -23
146    36     139 10.3 27.22222     9  23  -36
147     7      49 10.3 20.55556     9  24   -7
148    14      20 16.6 17.22222     9  25  -14
149    30     193  6.9 21.11111     9  26  -30
150    NA     145 13.2 25.00000     9  27   NA
151    14     191 14.3 23.88889     9  28  -14
152    18     131  8.0 24.44444     9  29  -18
153    20     223 11.5 20.00000     9  30  -20
> 
> attach(airquality)
> transform(Ozone, logOzone = log(Ozone)) # marginally interesting ...
    X_data logOzone
1       41 3.713572
2       36 3.583519
3       12 2.484907
4       18 2.890372
5       NA       NA
6       28 3.332205
7       23 3.135494
8       19 2.944439
9        8 2.079442
10      NA       NA
11       7 1.945910
12      16 2.772589
13      11 2.397895
14      14 2.639057
15      18 2.890372
16      14 2.639057
17      34 3.526361
18       6 1.791759
19      30 3.401197
20      11 2.397895
21       1 0.000000
22      11 2.397895
23       4 1.386294
24      32 3.465736
25      NA       NA
26      NA       NA
27      NA       NA
28      23 3.135494
29      45 3.806662
30     115 4.744932
31      37 3.610918
32      NA       NA
33      NA       NA
34      NA       NA
35      NA       NA
36      NA       NA
37      NA       NA
38      29 3.367296
39      NA       NA
40      71 4.262680
41      39 3.663562
42      NA       NA
43      NA       NA
44      23 3.135494
45      NA       NA
46      NA       NA
47      21 3.044522
48      37 3.610918
49      20 2.995732
50      12 2.484907
51      13 2.564949
52      NA       NA
53      NA       NA
54      NA       NA
55      NA       NA
56      NA       NA
57      NA       NA
58      NA       NA
59      NA       NA
60      NA       NA
61      NA       NA
62     135 4.905275
63      49 3.891820
64      32 3.465736
65      NA       NA
66      64 4.158883
67      40 3.688879
68      77 4.343805
69      97 4.574711
70      97 4.574711
71      85 4.442651
72      NA       NA
73      10 2.302585
74      27 3.295837
75      NA       NA
76       7 1.945910
77      48 3.871201
78      35 3.555348
79      61 4.110874
80      79 4.369448
81      63 4.143135
82      16 2.772589
83      NA       NA
84      NA       NA
85      80 4.382027
86     108 4.682131
87      20 2.995732
88      52 3.951244
89      82 4.406719
90      50 3.912023
91      64 4.158883
92      59 4.077537
93      39 3.663562
94       9 2.197225
95      16 2.772589
96      78 4.356709
97      35 3.555348
98      66 4.189655
99     122 4.804021
100     89 4.488636
101    110 4.700480
102     NA       NA
103     NA       NA
104     44 3.784190
105     28 3.332205
106     65 4.174387
107     NA       NA
108     22 3.091042
109     59 4.077537
110     23 3.135494
111     31 3.433987
112     44 3.784190
113     21 3.044522
114      9 2.197225
115     NA       NA
116     45 3.806662
117    168 5.123964
118     73 4.290459
119     NA       NA
120     76 4.330733
121    118 4.770685
122     84 4.430817
123     85 4.442651
124     96 4.564348
125     78 4.356709
126     73 4.290459
127     91 4.510860
128     47 3.850148
129     32 3.465736
130     20 2.995732
131     23 3.135494
132     21 3.044522
133     24 3.178054
134     44 3.784190
135     21 3.044522
136     28 3.332205
137      9 2.197225
138     13 2.564949
139     46 3.828641
140     18 2.890372
141     13 2.564949
142     24 3.178054
143     16 2.772589
144     13 2.564949
145     23 3.135494
146     36 3.583519
147      7 1.945910
148     14 2.639057
149     30 3.401197
150     NA       NA
151     14 2.639057
152     18 2.890372
153     20 2.995732
> detach(airquality)
> 
> 
> 
> cleanEx()
> nameEx("trimws")
> ### * trimws
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: trimws
> ### Title: Remove Leading/Trailing Whitespace
> ### Aliases: trimws
> ### Keywords: character
> 
> ### ** Examples
> 
> x <- "  Some text. "
> x
[1] "  Some text. "
> trimws(x)
[1] "Some text."
> trimws(x, "l")
[1] "Some text. "
> trimws(x, "r")
[1] "  Some text."
> 
> ## Unicode --> need "stronger" 'whitespace' to match all :
> tt <- "text with unicode 'non breakable space'."
> xu <- paste(" \t\v", tt, "\u00a0 \n\r")
> (tu <- trimws(xu, whitespace = "[\\h\\v]"))
[1] "text with unicode 'non breakable space'."
> stopifnot(identical(tu, tt))
> 
> 
> 
> cleanEx()
> nameEx("try")
> ### * try
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: try
> ### Title: Try an Expression Allowing Error Recovery
> ### Aliases: try
> ### Keywords: programming
> 
> ### ** Examples
> 
> ## this example will not work correctly in example(try), but
> ## it does work correctly if pasted in
> options(show.error.messages = FALSE)
> try(log("a"))
> print(.Last.value)
[1] "Error in log(\"a\") : non-numeric argument to mathematical function\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in log("a"): non-numeric argument to mathematical function>
> options(show.error.messages = TRUE)
> 
> ## alternatively,
> print(try(log("a"), TRUE))
[1] "Error in log(\"a\") : non-numeric argument to mathematical function\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in log("a"): non-numeric argument to mathematical function>
> 
> ## run a simulation, keep only the results that worked.
> set.seed(123)
> x <- stats::rnorm(50)
> doit <- function(x)
+ {
+     x <- sample(x, replace = TRUE)
+     if(length(unique(x)) > 30) mean(x)
+     else stop("too few unique points")
+ }
> ## alternative 1
> res <- lapply(1:100, function(i) try(doit(x), TRUE))
> ## alternative 2
> ## Not run: 
> ##D res <- vector("list", 100)
> ##D for(i in 1:100) res[[i]] <- try(doit(x), TRUE)
> ## End(Not run)
> unlist(res[sapply(res, function(x) !inherits(x, "try-error"))])
 [1]  0.1038462937  0.2203698307 -0.0596661593  0.3708669961  0.0665046900
 [6]  0.0792881652  0.0663761369  0.1141272652 -0.0643349711 -0.0216906885
[11] -0.1626084595 -0.0566880329  0.0886473556  0.1004842418  0.2831906261
[16] -0.0065789682 -0.1581928697 -0.1387666562  0.2048116508  0.1802423172
[21]  0.0437778643  0.0472314668  0.2720474611 -0.0164757286  0.1039084397
[26] -0.1371396827  0.0674041227  0.1104542059 -0.0134320967 -0.0601724607
[31] -0.0224327307 -0.0342157765  0.0480507372  0.0513758611 -0.0131174373
[36]  0.0470753156  0.3035483106  0.1515867000 -0.1677659486 -0.0482878061
[41] -0.1799587591 -0.1861287551  0.0845282836 -0.1096289736  0.1102887424
[46]  0.0643370194 -0.0139319224 -0.0879206273 -0.0309095587 -0.0416872956
[51]  0.2262913312  0.1147464101  0.1933621895  0.2255084914  0.0005507262
[56]  0.1285301322  0.0456429498 -0.1236476876 -0.1356975337  0.0235302138
[61]  0.1952604720 -0.0593417165 -0.0271823531 -0.1626786990  0.2038705988
[66] -0.0348928444  0.2576927806  0.2842287938 -0.1718551174  0.0904757090
> 
> 
> 
> cleanEx()
> nameEx("typeof")
> ### * typeof
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: typeof
> ### Title: The Type of an Object
> ### Aliases: typeof type
> ### Keywords: attribute
> 
> ### ** Examples
> 
> typeof(2)
[1] "double"
> mode(2)
[1] "numeric"
> 
> 
> 
> cleanEx()
> nameEx("unique")
> ### * unique
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: unique
> ### Title: Extract Unique Elements
> ### Aliases: unique unique.default unique.data.frame unique.matrix
> ###   unique.array
> ### Keywords: manip logic
> 
> ### ** Examples
> 
> x <- c(3:5, 11:8, 8 + 0:5)
> (ux <- unique(x))
[1]  3  4  5 11 10  9  8 12 13
> (u2 <- unique(x, fromLast = TRUE)) # different order
[1]  3  4  5  8  9 10 11 12 13
> stopifnot(identical(sort(ux), sort(u2)))
> 
> length(unique(sample(100, 100, replace = TRUE)))
[1] 60
> ## approximately 100(1 - 1/e) = 63.21
> 
> unique(iris)
    Sepal.Length Sepal.Width Petal.Length Petal.Width    Species
1            5.1         3.5          1.4         0.2     setosa
2            4.9         3.0          1.4         0.2     setosa
3            4.7         3.2          1.3         0.2     setosa
4            4.6         3.1          1.5         0.2     setosa
5            5.0         3.6          1.4         0.2     setosa
6            5.4         3.9          1.7         0.4     setosa
7            4.6         3.4          1.4         0.3     setosa
8            5.0         3.4          1.5         0.2     setosa
9            4.4         2.9          1.4         0.2     setosa
10           4.9         3.1          1.5         0.1     setosa
11           5.4         3.7          1.5         0.2     setosa
12           4.8         3.4          1.6         0.2     setosa
13           4.8         3.0          1.4         0.1     setosa
14           4.3         3.0          1.1         0.1     setosa
15           5.8         4.0          1.2         0.2     setosa
16           5.7         4.4          1.5         0.4     setosa
17           5.4         3.9          1.3         0.4     setosa
18           5.1         3.5          1.4         0.3     setosa
19           5.7         3.8          1.7         0.3     setosa
20           5.1         3.8          1.5         0.3     setosa
21           5.4         3.4          1.7         0.2     setosa
22           5.1         3.7          1.5         0.4     setosa
23           4.6         3.6          1.0         0.2     setosa
24           5.1         3.3          1.7         0.5     setosa
25           4.8         3.4          1.9         0.2     setosa
26           5.0         3.0          1.6         0.2     setosa
27           5.0         3.4          1.6         0.4     setosa
28           5.2         3.5          1.5         0.2     setosa
29           5.2         3.4          1.4         0.2     setosa
30           4.7         3.2          1.6         0.2     setosa
31           4.8         3.1          1.6         0.2     setosa
32           5.4         3.4          1.5         0.4     setosa
33           5.2         4.1          1.5         0.1     setosa
34           5.5         4.2          1.4         0.2     setosa
35           4.9         3.1          1.5         0.2     setosa
36           5.0         3.2          1.2         0.2     setosa
37           5.5         3.5          1.3         0.2     setosa
38           4.9         3.6          1.4         0.1     setosa
39           4.4         3.0          1.3         0.2     setosa
40           5.1         3.4          1.5         0.2     setosa
41           5.0         3.5          1.3         0.3     setosa
42           4.5         2.3          1.3         0.3     setosa
43           4.4         3.2          1.3         0.2     setosa
44           5.0         3.5          1.6         0.6     setosa
45           5.1         3.8          1.9         0.4     setosa
46           4.8         3.0          1.4         0.3     setosa
47           5.1         3.8          1.6         0.2     setosa
48           4.6         3.2          1.4         0.2     setosa
49           5.3         3.7          1.5         0.2     setosa
50           5.0         3.3          1.4         0.2     setosa
51           7.0         3.2          4.7         1.4 versicolor
52           6.4         3.2          4.5         1.5 versicolor
53           6.9         3.1          4.9         1.5 versicolor
54           5.5         2.3          4.0         1.3 versicolor
55           6.5         2.8          4.6         1.5 versicolor
56           5.7         2.8          4.5         1.3 versicolor
57           6.3         3.3          4.7         1.6 versicolor
58           4.9         2.4          3.3         1.0 versicolor
59           6.6         2.9          4.6         1.3 versicolor
60           5.2         2.7          3.9         1.4 versicolor
61           5.0         2.0          3.5         1.0 versicolor
62           5.9         3.0          4.2         1.5 versicolor
63           6.0         2.2          4.0         1.0 versicolor
64           6.1         2.9          4.7         1.4 versicolor
65           5.6         2.9          3.6         1.3 versicolor
66           6.7         3.1          4.4         1.4 versicolor
67           5.6         3.0          4.5         1.5 versicolor
68           5.8         2.7          4.1         1.0 versicolor
69           6.2         2.2          4.5         1.5 versicolor
70           5.6         2.5          3.9         1.1 versicolor
71           5.9         3.2          4.8         1.8 versicolor
72           6.1         2.8          4.0         1.3 versicolor
73           6.3         2.5          4.9         1.5 versicolor
74           6.1         2.8          4.7         1.2 versicolor
75           6.4         2.9          4.3         1.3 versicolor
76           6.6         3.0          4.4         1.4 versicolor
77           6.8         2.8          4.8         1.4 versicolor
78           6.7         3.0          5.0         1.7 versicolor
79           6.0         2.9          4.5         1.5 versicolor
80           5.7         2.6          3.5         1.0 versicolor
81           5.5         2.4          3.8         1.1 versicolor
82           5.5         2.4          3.7         1.0 versicolor
83           5.8         2.7          3.9         1.2 versicolor
84           6.0         2.7          5.1         1.6 versicolor
85           5.4         3.0          4.5         1.5 versicolor
86           6.0         3.4          4.5         1.6 versicolor
87           6.7         3.1          4.7         1.5 versicolor
88           6.3         2.3          4.4         1.3 versicolor
89           5.6         3.0          4.1         1.3 versicolor
90           5.5         2.5          4.0         1.3 versicolor
91           5.5         2.6          4.4         1.2 versicolor
92           6.1         3.0          4.6         1.4 versicolor
93           5.8         2.6          4.0         1.2 versicolor
94           5.0         2.3          3.3         1.0 versicolor
95           5.6         2.7          4.2         1.3 versicolor
96           5.7         3.0          4.2         1.2 versicolor
97           5.7         2.9          4.2         1.3 versicolor
98           6.2         2.9          4.3         1.3 versicolor
99           5.1         2.5          3.0         1.1 versicolor
100          5.7         2.8          4.1         1.3 versicolor
101          6.3         3.3          6.0         2.5  virginica
102          5.8         2.7          5.1         1.9  virginica
103          7.1         3.0          5.9         2.1  virginica
104          6.3         2.9          5.6         1.8  virginica
105          6.5         3.0          5.8         2.2  virginica
106          7.6         3.0          6.6         2.1  virginica
107          4.9         2.5          4.5         1.7  virginica
108          7.3         2.9          6.3         1.8  virginica
109          6.7         2.5          5.8         1.8  virginica
110          7.2         3.6          6.1         2.5  virginica
111          6.5         3.2          5.1         2.0  virginica
112          6.4         2.7          5.3         1.9  virginica
113          6.8         3.0          5.5         2.1  virginica
114          5.7         2.5          5.0         2.0  virginica
115          5.8         2.8          5.1         2.4  virginica
116          6.4         3.2          5.3         2.3  virginica
117          6.5         3.0          5.5         1.8  virginica
118          7.7         3.8          6.7         2.2  virginica
119          7.7         2.6          6.9         2.3  virginica
120          6.0         2.2          5.0         1.5  virginica
121          6.9         3.2          5.7         2.3  virginica
122          5.6         2.8          4.9         2.0  virginica
123          7.7         2.8          6.7         2.0  virginica
124          6.3         2.7          4.9         1.8  virginica
125          6.7         3.3          5.7         2.1  virginica
126          7.2         3.2          6.0         1.8  virginica
127          6.2         2.8          4.8         1.8  virginica
128          6.1         3.0          4.9         1.8  virginica
129          6.4         2.8          5.6         2.1  virginica
130          7.2         3.0          5.8         1.6  virginica
131          7.4         2.8          6.1         1.9  virginica
132          7.9         3.8          6.4         2.0  virginica
133          6.4         2.8          5.6         2.2  virginica
134          6.3         2.8          5.1         1.5  virginica
135          6.1         2.6          5.6         1.4  virginica
136          7.7         3.0          6.1         2.3  virginica
137          6.3         3.4          5.6         2.4  virginica
138          6.4         3.1          5.5         1.8  virginica
139          6.0         3.0          4.8         1.8  virginica
140          6.9         3.1          5.4         2.1  virginica
141          6.7         3.1          5.6         2.4  virginica
142          6.9         3.1          5.1         2.3  virginica
144          6.8         3.2          5.9         2.3  virginica
145          6.7         3.3          5.7         2.5  virginica
146          6.7         3.0          5.2         2.3  virginica
147          6.3         2.5          5.0         1.9  virginica
148          6.5         3.0          5.2         2.0  virginica
149          6.2         3.4          5.4         2.3  virginica
150          5.9         3.0          5.1         1.8  virginica
> 
> 
> 
> cleanEx()
> nameEx("unlist")
> ### * unlist
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: unlist
> ### Title: Flatten Lists
> ### Aliases: unlist
> ### Keywords: list manip
> 
> ### ** Examples
> 
> unlist(options())
$add.smooth
[1] TRUE

$bitmapType
[1] "cairo"

$browser
[1] "xdg-open"

$browserNLdisabled
[1] FALSE

$CBoundsCheck
[1] FALSE

$check.bounds
[1] FALSE

$citation.bibtex.max
[1] 1

$continue
[1] "+ "

$contrasts.unordered
[1] "contr.treatment"

$contrasts.ordered
[1] "contr.poly"

$defaultPackages1
[1] "datasets"

$defaultPackages2
[1] "utils"

$defaultPackages3
[1] "grDevices"

$defaultPackages4
[1] "graphics"

$defaultPackages5
[1] "stats"

$defaultPackages6
[1] "methods"

$demo.ask
[1] "default"

$deparse.cutoff
[1] 60

$device
function (file = if (onefile) "Rplots.pdf" else "Rplot%03d.pdf", 
    width, height, onefile, family, title, fonts, version, paper, 
    encoding, bg, fg, pointsize, pagecentre, colormodel, useDingbats, 
    useKerning, fillOddEven, compress) 
{
    initPSandPDFfonts()
    new <- list()
    if (!missing(width)) 
        new$width <- width
    if (!missing(height)) 
        new$height <- height
    if (!missing(onefile)) 
        new$onefile <- onefile
    if (!missing(title)) 
        new$title <- title
    if (!missing(fonts)) 
        new$fonts <- fonts
    if (!missing(version)) 
        new$version <- version
    if (!missing(paper)) 
        new$paper <- paper
    if (!missing(encoding)) 
        new$encoding <- encoding
    if (!missing(bg)) 
        new$bg <- bg
    if (!missing(fg)) 
        new$fg <- fg
    if (!missing(pointsize)) 
        new$pointsize <- pointsize
    if (!missing(pagecentre)) 
        new$pagecentre <- pagecentre
    if (!missing(colormodel)) 
        new$colormodel <- colormodel
    if (!missing(useDingbats)) 
        new$useDingbats <- useDingbats
    if (!missing(useKerning)) 
        new$useKerning <- useKerning
    if (!missing(fillOddEven)) 
        new$fillOddEven <- fillOddEven
    if (!missing(compress)) 
        new$compress <- compress
    old <- check.options(new, name.opt = ".PDF.Options", envir = .PSenv)
    if (!missing(family) && (inherits(family, "Type1Font") || 
        inherits(family, "CIDFont"))) {
        enc <- family$encoding
        if (inherits(family, "Type1Font") && !is.null(enc) && 
            enc != "default" && (is.null(old$encoding) || old$encoding == 
            "default")) 
            old$encoding <- enc
        family <- family$metrics
    }
    if (is.null(old$encoding) || old$encoding == "default") 
        old$encoding <- guessEncoding()
    if (!missing(family)) {
        if (length(family) == 4L) {
            family <- c(family, "Symbol.afm")
        }
        else if (length(family) == 5L) {
        }
        else if (length(family) == 1L) {
            pf <- pdfFonts(family)[[1L]]
            if (is.null(pf)) 
                stop(gettextf("unknown family '%s'", family), 
                  domain = NA)
            matchFont(pf, old$encoding)
        }
        else stop("invalid 'family' argument")
        old$family <- family
    }
    version <- old$version
    versions <- c("1.1", "1.2", "1.3", "1.4", "1.5", "1.6", "1.7", 
        "2.0")
    if (version %in% versions) 
        version <- as.integer(strsplit(version, "[.]")[[1L]])
    else stop("invalid PDF version")
    onefile <- old$onefile
    if (!checkIntFormat(file)) 
        stop(gettextf("invalid 'file' argument '%s'", file), 
            domain = NA)
    .External(C_PDF, file, old$paper, old$family, old$encoding, 
        old$bg, old$fg, old$width, old$height, old$pointsize, 
        onefile, old$pagecentre, old$title, old$fonts, version[1L], 
        version[2L], old$colormodel, old$useDingbats, old$useKerning, 
        old$fillOddEven, old$compress)
    invisible()
}
<bytecode: 0x55b753302f00>
<environment: namespace:grDevices>

$device.ask.default
[1] FALSE

$digits
[1] 7

$dvipscmd
[1] "dvips"

$echo
[1] TRUE

$editor
[1] "vi"

$encoding
[1] "native.enc"

$error
(function () 
traceback(3))()

$example.ask
[1] "default"

$expressions
[1] 5000

$help.search.types1
[1] "vignette"

$help.search.types2
[1] "demo"

$help.search.types3
[1] "help"

$help.try.all.packages
[1] FALSE

$HTTPUserAgent
[1] "R (4.0.3 x86_64-pc-linux-gnu x86_64 linux-gnu)"

$internet.info
[1] 2

$keep.parse.data
[1] TRUE

$keep.parse.data.pkgs
[1] FALSE

$keep.source
[1] FALSE

$keep.source.pkgs
[1] FALSE

$locatorBell
[1] TRUE

$mailer
[1] "mailto"

$matprod
[1] "default"

$max.print
[1] 99999

$menu.graphics
[1] TRUE

$na.action
[1] "na.omit"

$nwarnings
[1] 50

$OutDec
[1] "."

$pager
[1] "/usr/local/lib/R/bin/pager"

$papersize
[1] "letter"

$PCRE_limit_recursion
[1] NA

$PCRE_study
[1] FALSE

$PCRE_use_JIT
[1] TRUE

$pdfviewer
[1] "/usr/bin/xdg-open"

$pkgType
[1] "source"

$printcmd
[1] "/usr/bin/lpr"

$prompt
[1] "> "

$repos.CRAN
[1] "@CRAN@"

$rl_word_breaks
[1] " \t\n\"\\'`><=%;,|&{()}"

$save.defaults.ascii
[1] TRUE

$save.defaults.safe
[1] FALSE

$scipen
[1] 0

$show.coef.Pvalues
[1] TRUE

$show.error.messages
[1] TRUE

$show.signif.stars
[1] TRUE

$showErrorCalls
[1] TRUE

$str.strict.width
[1] "no"

$str.digits.d
[1] 3

$str.vec.len
[1] 4

$str.list.len
[1] 99

$str.drop.deparse.attr
[1] TRUE

$str.formatNum
function (x, ...) 
format(x, trim = TRUE, drop0trailing = TRUE, ...)
<environment: 0x55b753e8c2e0>

$str.dendrogram.last
[1] "`"

$stringsAsFactors
[1] FALSE

$texi2dvi
[1] "/usr/bin/texi2dvi"

$timeout
[1] 60

$ts.eps
[1] 1e-05

$ts.S.compat
[1] FALSE

$unzip
[1] "/usr/bin/unzip"

$useFancyQuotes
[1] TRUE

$verbose
[1] FALSE

$warn
[1] 1

$warning.length
[1] 1000

$warnPartialMatchDollar
[1] FALSE

$width
[1] 80

> unlist(options(), use.names = FALSE)
[[1]]
[1] TRUE

[[2]]
[1] "cairo"

[[3]]
[1] "xdg-open"

[[4]]
[1] FALSE

[[5]]
[1] FALSE

[[6]]
[1] FALSE

[[7]]
[1] 1

[[8]]
[1] "+ "

[[9]]
[1] "contr.treatment"

[[10]]
[1] "contr.poly"

[[11]]
[1] "datasets"

[[12]]
[1] "utils"

[[13]]
[1] "grDevices"

[[14]]
[1] "graphics"

[[15]]
[1] "stats"

[[16]]
[1] "methods"

[[17]]
[1] "default"

[[18]]
[1] 60

[[19]]
function (file = if (onefile) "Rplots.pdf" else "Rplot%03d.pdf", 
    width, height, onefile, family, title, fonts, version, paper, 
    encoding, bg, fg, pointsize, pagecentre, colormodel, useDingbats, 
    useKerning, fillOddEven, compress) 
{
    initPSandPDFfonts()
    new <- list()
    if (!missing(width)) 
        new$width <- width
    if (!missing(height)) 
        new$height <- height
    if (!missing(onefile)) 
        new$onefile <- onefile
    if (!missing(title)) 
        new$title <- title
    if (!missing(fonts)) 
        new$fonts <- fonts
    if (!missing(version)) 
        new$version <- version
    if (!missing(paper)) 
        new$paper <- paper
    if (!missing(encoding)) 
        new$encoding <- encoding
    if (!missing(bg)) 
        new$bg <- bg
    if (!missing(fg)) 
        new$fg <- fg
    if (!missing(pointsize)) 
        new$pointsize <- pointsize
    if (!missing(pagecentre)) 
        new$pagecentre <- pagecentre
    if (!missing(colormodel)) 
        new$colormodel <- colormodel
    if (!missing(useDingbats)) 
        new$useDingbats <- useDingbats
    if (!missing(useKerning)) 
        new$useKerning <- useKerning
    if (!missing(fillOddEven)) 
        new$fillOddEven <- fillOddEven
    if (!missing(compress)) 
        new$compress <- compress
    old <- check.options(new, name.opt = ".PDF.Options", envir = .PSenv)
    if (!missing(family) && (inherits(family, "Type1Font") || 
        inherits(family, "CIDFont"))) {
        enc <- family$encoding
        if (inherits(family, "Type1Font") && !is.null(enc) && 
            enc != "default" && (is.null(old$encoding) || old$encoding == 
            "default")) 
            old$encoding <- enc
        family <- family$metrics
    }
    if (is.null(old$encoding) || old$encoding == "default") 
        old$encoding <- guessEncoding()
    if (!missing(family)) {
        if (length(family) == 4L) {
            family <- c(family, "Symbol.afm")
        }
        else if (length(family) == 5L) {
        }
        else if (length(family) == 1L) {
            pf <- pdfFonts(family)[[1L]]
            if (is.null(pf)) 
                stop(gettextf("unknown family '%s'", family), 
                  domain = NA)
            matchFont(pf, old$encoding)
        }
        else stop("invalid 'family' argument")
        old$family <- family
    }
    version <- old$version
    versions <- c("1.1", "1.2", "1.3", "1.4", "1.5", "1.6", "1.7", 
        "2.0")
    if (version %in% versions) 
        version <- as.integer(strsplit(version, "[.]")[[1L]])
    else stop("invalid PDF version")
    onefile <- old$onefile
    if (!checkIntFormat(file)) 
        stop(gettextf("invalid 'file' argument '%s'", file), 
            domain = NA)
    .External(C_PDF, file, old$paper, old$family, old$encoding, 
        old$bg, old$fg, old$width, old$height, old$pointsize, 
        onefile, old$pagecentre, old$title, old$fonts, version[1L], 
        version[2L], old$colormodel, old$useDingbats, old$useKerning, 
        old$fillOddEven, old$compress)
    invisible()
}
<bytecode: 0x55b753302f00>
<environment: namespace:grDevices>

[[20]]
[1] FALSE

[[21]]
[1] 7

[[22]]
[1] "dvips"

[[23]]
[1] TRUE

[[24]]
[1] "vi"

[[25]]
[1] "native.enc"

[[26]]
(function () 
traceback(3))()

[[27]]
[1] "default"

[[28]]
[1] 5000

[[29]]
[1] "vignette"

[[30]]
[1] "demo"

[[31]]
[1] "help"

[[32]]
[1] FALSE

[[33]]
[1] "R (4.0.3 x86_64-pc-linux-gnu x86_64 linux-gnu)"

[[34]]
[1] 2

[[35]]
[1] TRUE

[[36]]
[1] FALSE

[[37]]
[1] FALSE

[[38]]
[1] FALSE

[[39]]
[1] TRUE

[[40]]
[1] "mailto"

[[41]]
[1] "default"

[[42]]
[1] 99999

[[43]]
[1] TRUE

[[44]]
[1] "na.omit"

[[45]]
[1] 50

[[46]]
[1] "."

[[47]]
[1] "/usr/local/lib/R/bin/pager"

[[48]]
[1] "letter"

[[49]]
[1] NA

[[50]]
[1] FALSE

[[51]]
[1] TRUE

[[52]]
[1] "/usr/bin/xdg-open"

[[53]]
[1] "source"

[[54]]
[1] "/usr/bin/lpr"

[[55]]
[1] "> "

[[56]]
[1] "@CRAN@"

[[57]]
[1] " \t\n\"\\'`><=%;,|&{()}"

[[58]]
[1] TRUE

[[59]]
[1] FALSE

[[60]]
[1] 0

[[61]]
[1] TRUE

[[62]]
[1] TRUE

[[63]]
[1] TRUE

[[64]]
[1] TRUE

[[65]]
[1] "no"

[[66]]
[1] 3

[[67]]
[1] 4

[[68]]
[1] 99

[[69]]
[1] TRUE

[[70]]
function (x, ...) 
format(x, trim = TRUE, drop0trailing = TRUE, ...)
<environment: 0x55b753e8c2e0>

[[71]]
[1] "`"

[[72]]
[1] FALSE

[[73]]
[1] "/usr/bin/texi2dvi"

[[74]]
[1] 60

[[75]]
[1] 1e-05

[[76]]
[1] FALSE

[[77]]
[1] "/usr/bin/unzip"

[[78]]
[1] TRUE

[[79]]
[1] FALSE

[[80]]
[1] 1

[[81]]
[1] 1000

[[82]]
[1] FALSE

[[83]]
[1] 80

> 
> l.ex <- list(a = list(1:5, LETTERS[1:5]), b = "Z", c = NA)
> unlist(l.ex, recursive = FALSE)
$a1
[1] 1 2 3 4 5

$a2
[1] "A" "B" "C" "D" "E"

$b
[1] "Z"

$c
[1] NA

> unlist(l.ex, recursive = TRUE)
 a1  a2  a3  a4  a5  a6  a7  a8  a9 a10   b   c 
"1" "2" "3" "4" "5" "A" "B" "C" "D" "E" "Z"  NA 
> 
> l1 <- list(a = "a", b = 2, c = pi+2i)
> unlist(l1) # a character vector
                    a                     b                     c 
                  "a"                   "2" "3.14159265358979+2i" 
> l2 <- list(a = "a", b = as.name("b"), c = pi+2i)
> unlist(l2) # remains a list
$a
[1] "a"

$b
b

$c
[1] 3.141593+2i

> 
> ll <- list(as.name("sinc"), quote( a + b ), 1:10, letters, expression(1+x))
> utils::str(ll)
List of 5
 $ : symbol sinc
 $ : language a + b
 $ : int [1:10] 1 2 3 4 5 6 7 8 9 10
 $ : chr [1:26] "a" "b" "c" "d" ...
 $ :  expression(1 + x)
> for(x in ll)
+   stopifnot(identical(x, unlist(x)))
> 
> 
> 
> cleanEx()
> nameEx("unname")
> ### * unname
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: unname
> ### Title: Remove 'names' or 'dimnames'
> ### Aliases: unname
> ### Keywords: utilities
> 
> ### ** Examples
> 
> require(graphics); require(stats)
> 
> ## Answering a question on R-help (14 Oct 1999):
> col3 <- 750+ 100*rt(1500, df = 3)
> breaks <- factor(cut(col3, breaks = 360+5*(0:155)))
> z <- table(breaks)
> z[1:5] # The names are larger than the data ...
breaks
(360,365] (370,375] (375,380] (380,385] (390,395] 
        2         1         1         2         1 
> barplot(unname(z), axes = FALSE)
> 
> 
> 
> cleanEx()
> nameEx("userhooks")
> ### * userhooks
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: userhooks
> ### Title: Functions to Get and Set Hooks for Load, Attach, Detach and
> ###   Unload
> ### Aliases: getHook setHook packageEvent .userHooksEnv
> ### Keywords: utilities
> 
> ### ** Examples
> 
> setHook(packageEvent("grDevices", "onLoad"),
+         function(...) grDevices::ps.options(horizontal = FALSE))
> 
> 
> 
> cleanEx()
> nameEx("utf8Conversion")
> ### * utf8Conversion
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: utf8Conversion
> ### Title: Convert Integer Vectors to or from UTF-8-encoded Character
> ###   Vectors
> ### Aliases: utf8ToInt intToUtf8 Unicode 'code point'
> ### Keywords: character utilities
> 
> ### ** Examples
> utf8ToInt("bi\u00dfchen")
[1]  98 105 223  99 104 101 110
> utf8ToInt("\xfa\xb4\xbf\xbf\x9f")
[1] NA
> 
> ## A valid UTF-16 surrogate pair (for U+10437)
> x <- c(0xD801, 0xDC37)
> intToUtf8(x)
[1] NA
> intToUtf8(x, TRUE)
[1] NA NA
> (xx <- intToUtf8(x, , TRUE)) # will only display in some locales and fonts
[1] "𐐷"
> charToRaw(xx)
[1] f0 90 90 b7
> 
> ## Not run: 
> ##D ## An example of how surrogate pairs might occur
> ##D x <- "\U10437"
> ##D charToRaw(x)
> ##D foo <- tempfile()
> ##D writeLines(x, file(foo, encoding = "UTF-16LE"))
> ##D ## next two are OS-specific, but are mandated by POSIX
> ##D system(paste("od -x", foo)) # 2-byte units, correct on little-endian platform
> ##D system(paste("od -t x1", foo)) # single bytes as hex
> ##D y <- readBin(foo, "integer", 2, 2, FALSE, endian = "little")
> ##D sprintf("%X", y)
> ##D intToUtf8(y, , TRUE)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("validUTF8")
> ### * validUTF8
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: validUTF8
> ### Title: Check if a Character Vector is Validly Encoded
> ### Aliases: validUTF8 validEnc
> 
> ### ** Examples
> 
> x <-
+   ## from example(text)
+ c("Jetz", "no", "chli", "z\xc3\xbcrit\xc3\xbc\xc3\xbctsch:",
+   "(noch", "ein", "bi\xc3\x9fchen", "Z\xc3\xbc", "deutsch)",
+    ## from a CRAN check log
+    "\xfa\xb4\xbf\xbf\x9f")
> validUTF8(x)
 [1]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE
> validEnc(x) # depends on the locale
 [1]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE
> Encoding(x) <-"UTF-8"
> validEnc(x) # typically the last, x[10], is invalid
 [1]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE
> 
> ## Maybe advantageous to declare it "unknown":
> G <- x ; Encoding(G[!validEnc(G)]) <- "unknown"
> try( substr(x, 1,1) ) # gives 'invalid multibyte string' error
Error in substr(x, 1, 1) : invalid multibyte string, element 10
> try( substr(G, 1,1) ) # works
 [1] "J"          "n"          "c"          "z"          "("         
 [6] "e"          "b"          "Z"          "d"          "\U02d3ffdf"
> nchar(G) # fine, too
 [1]  4  2  4 12  5  3  7  2  8  1
> ## but it is not "more valid" typically:
> all.equal(validEnc(x),
+           validEnc(G)) # typically TRUE
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("vector")
> ### * vector
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: vector
> ### Title: Vectors
> ### Aliases: vector as.vector as.vector.factor is.vector atomic
> ### Keywords: classes
> 
> ### ** Examples
> 
> df <- data.frame(x = 1:3, y = 5:7)
> ## Error:
> try(as.vector(data.frame(x = 1:3, y = 5:7), mode = "numeric"))
Error in as.vector(data.frame(x = 1:3, y = 5:7), mode = "numeric") : 
  'list' object cannot be coerced to type 'double'
> 
> x <- c(a = 1, b = 2)
> is.vector(x)
[1] TRUE
> as.vector(x)
[1] 1 2
> all.equal(x, as.vector(x)) ## FALSE
[1] "names for target but not for current"
> 
> 
> ###-- All the following are TRUE:
> is.list(df)
[1] TRUE
> ! is.vector(df)
[1] TRUE
> ! is.vector(df, mode = "list")
[1] TRUE
> 
> is.vector(list(), mode = "list")
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("warning")
> ### * warning
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: warning
> ### Title: Warning Messages
> ### Aliases: warning suppressWarnings
> ### Keywords: programming error
> 
> ### ** Examples
> 
> ## Don't show: 
> oldopt <- options(warn = 1)
> ## End(Don't show)
> testit <- function() warning("testit")
> testit() ## shows call
Warning in testit() : testit
> testit <- function() warning("problem in testit", call. = FALSE)
> testit() ## no call
Warning: problem in testit
> suppressWarnings(warning("testit"))
> ## Don't show: 
> eigenval <- 10 ^ -stats::rnorm(1, mean = 6)
> if(eigenval < 1.e-7) warning("system near singular")
> options(oldopt)
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("warnings")
> ### * warnings
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: warnings
> ### Title: Print Warning Messages
> ### Aliases: warnings last.warning print.warnings [.warnings c.warnings
> ###   duplicated.warnings unique.warnings summary.warnings
> ###   print.summary.warnings
> ### Keywords: programming error
> 
> ### ** Examples
> 
> ## NB this example is intended to be pasted in,
> ##    rather than run by example()
> ow <- options("warn")
> for(w in -1:1) {
+    options(warn = w); cat("\n warn =", w, "\n")
+    for(i in 1:3) { cat(i,"..\n"); m <- matrix(1:7, 3,4) }
+    cat("--=--=--\n")
+ }

 warn = -1 
1 ..
2 ..
3 ..
--=--=--

 warn = 0 
1 ..
2 ..
3 ..
--=--=--

 warn = 1 
1 ..
Warning in matrix(1:7, 3, 4) :
  data length [7] is not a sub-multiple or multiple of the number of rows [3]
2 ..
Warning in matrix(1:7, 3, 4) :
  data length [7] is not a sub-multiple or multiple of the number of rows [3]
3 ..
Warning in matrix(1:7, 3, 4) :
  data length [7] is not a sub-multiple or multiple of the number of rows [3]
--=--=--
Warning messages:
1: In matrix(1:7, 3, 4) :
  data length [7] is not a sub-multiple or multiple of the number of rows [3]
2: In matrix(1:7, 3, 4) :
  data length [7] is not a sub-multiple or multiple of the number of rows [3]
3: In matrix(1:7, 3, 4) :
  data length [7] is not a sub-multiple or multiple of the number of rows [3]
> ## at the end prints all three warnings, from the 'option(warn = 0)' above
> options(ow) # reset to previous, typically 'warn = 0'
> tail(warnings(), 2) # see the last two warnings only (via '[' method)
Warning messages:
1: In matrix(1:7, 3, 4) :
  data length [7] is not a sub-multiple or multiple of the number of rows [3]
2: In matrix(1:7, 3, 4) :
  data length [7] is not a sub-multiple or multiple of the number of rows [3]
> 
> ## Often the most useful way to look at many warnings:
> summary(warnings())
3 identical warnings:
In matrix(1:7, 3, 4) :
  data length [7] is not a sub-multiple or multiple of the number of rows [3]
> ## Don't show: 
> ww <- warnings()
> uw <- unique(ww)
> sw <- summary(ww)
> stopifnot(identical(c(ww[1], ww[3]), ww[c(1, 3)]),
+           length(uw) == 1, nchar(names(uw)) > 10,
+           length(sw) == 1, attr(sw, "counts") == 3)
> ## End(Don't show)
> op <- options(nwarnings = 10000) ## <- get "full statistics"
> x <- 1:36; for(n in 1:13) for(m in 1:12) A <- matrix(x, n,m) # There were 105 warnings ...
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of columns [5]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of columns [7]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of columns [8]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of columns [10]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of columns [11]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of columns [5]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of columns [7]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of columns [8]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of columns [10]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of columns [11]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of columns [5]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of columns [7]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of columns [8]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of columns [10]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of columns [11]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of columns [5]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of columns [7]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of columns [8]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of columns [10]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of columns [11]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of rows [5]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of rows [5]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of rows [5]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of rows [5]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of rows [5]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of rows [5]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of rows [5]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of rows [5]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of rows [5]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of rows [5]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of rows [5]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of rows [5]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of columns [5]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of columns [7]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of columns [8]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of columns [10]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of columns [11]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of rows [7]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of rows [7]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of rows [7]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of rows [7]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of rows [7]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of rows [7]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of rows [7]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of rows [7]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of rows [7]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of rows [7]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of rows [7]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of rows [7]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of rows [8]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of rows [8]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of rows [8]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of rows [8]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of rows [8]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of rows [8]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of rows [8]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of rows [8]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of rows [8]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of rows [8]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of rows [8]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of columns [5]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of columns [7]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of columns [10]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of columns [11]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of rows [10]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of rows [10]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of rows [10]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of rows [10]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of rows [10]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of rows [10]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of rows [10]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of rows [10]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of rows [10]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of rows [10]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of rows [10]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of rows [10]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of rows [11]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of rows [11]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of rows [11]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of rows [11]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of rows [11]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of rows [11]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of rows [11]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of rows [11]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of rows [11]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of rows [11]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of rows [11]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of rows [11]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of columns [5]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of columns [7]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of columns [8]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of columns [10]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of columns [11]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of rows [13]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of rows [13]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of rows [13]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of rows [13]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of rows [13]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of rows [13]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of rows [13]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of rows [13]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of rows [13]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of rows [13]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of rows [13]
Warning in matrix(x, n, m) :
  data length [36] is not a sub-multiple or multiple of the number of rows [13]
> summary(warnings())
3 identical warnings:
In matrix(1:7, 3, 4) :
  data length [7] is not a sub-multiple or multiple of the number of rows [3]
> options(op) # revert to previous (keeping 50 messages by default)
> 
> 
> 
> cleanEx()
> nameEx("weekday.POSIXt")
> ### * weekday.POSIXt
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: weekdays
> ### Title: Extract Parts of a POSIXt or Date Object
> ### Aliases: weekdays weekdays.POSIXt weekdays.Date months months.POSIXt
> ###   months.Date quarters quarters.POSIXt quarters.Date julian
> ###   julian.POSIXt julian.Date
> ### Keywords: chron
> 
> ### ** Examples
> 
> 
> cleanEx()
> nameEx("which")
> ### * which
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: which
> ### Title: Which indices are TRUE?
> ### Aliases: which arrayInd
> ### Keywords: logic attribute
> 
> ### ** Examples
> 
> which(LETTERS == "R")
[1] 18
> which(ll <- c(TRUE, FALSE, TRUE, NA, FALSE, FALSE, TRUE)) #> 1 3 7
[1] 1 3 7
> names(ll) <- letters[seq(ll)]
> which(ll)
a c g 
1 3 7 
> which((1:12)%%2 == 0) # which are even?
[1]  2  4  6  8 10 12
> which(1:10 > 3, arr.ind = TRUE)
[1]  4  5  6  7  8  9 10
> 
> ( m <- matrix(1:12, 3, 4) )
     [,1] [,2] [,3] [,4]
[1,]    1    4    7   10
[2,]    2    5    8   11
[3,]    3    6    9   12
> div.3 <- m %% 3 == 0
> which(div.3)
[1]  3  6  9 12
> which(div.3, arr.ind = TRUE)
     row col
[1,]   3   1
[2,]   3   2
[3,]   3   3
[4,]   3   4
> rownames(m) <- paste("Case", 1:3, sep = "_")
> which(m %% 5 == 0, arr.ind = TRUE)
       row col
Case_2   2   2
Case_1   1   4
> 
> dim(m) <- c(2, 2, 3); m
, , 1

     [,1] [,2]
[1,]    1    3
[2,]    2    4

, , 2

     [,1] [,2]
[1,]    5    7
[2,]    6    8

, , 3

     [,1] [,2]
[1,]    9   11
[2,]   10   12

> which(div.3, arr.ind = FALSE)
[1]  3  6  9 12
> which(div.3, arr.ind = TRUE)
     row col
[1,]   3   1
[2,]   3   2
[3,]   3   3
[4,]   3   4
> 
> vm <- c(m)
> dim(vm) <- length(vm) #-- funny thing with  length(dim(...)) == 1
> which(div.3, arr.ind = TRUE)
     row col
[1,]   3   1
[2,]   3   2
[3,]   3   3
[4,]   3   4
> ## Don't show: 
> dimnames(m) <- list(X = c("U", "V"), Z = c("y","z"), three = LETTERS[1:3])
> wm <- which(m %% 3 == 0, arr.ind = TRUE)
> vn <- vm; dimnames(vn) <- list(LETTERS[1:12])
> wv <- which(vn %% 3 == 0, arr.ind = TRUE)
> 
> stopifnot(identical(wv, array(3L*(1:4), dim = c(4, 1),
+                               dimnames = list(c("C", "F", "I", "L"), "dim1"))),
+           identical(wm, array(c(1:2, 1:2, 2:1, 1:2, 1:3, 3L),
+                               dim = 4:3,
+                               dimnames = list(rep(c("U","V"),2),
+                                               c("X", "Z", "three"))))
+ )
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("which.min")
> ### * which.min
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: which.min
> ### Title: Where is the Min() or Max() or first TRUE or FALSE ?
> ### Aliases: which.min which.max
> ### Keywords: utilities
> 
> ### ** Examples
> 
> x <- c(1:4, 0:5, 11)
> which.min(x)
[1] 5
> which.max(x)
[1] 11
> 
> ## it *does* work with NA's present, by discarding them:
> presidents[1:30]
 [1] NA 87 82 75 63 50 43 32 35 60 54 55 36 39 NA NA 69 57 57 51 45 37 46 39 36
[26] 24 32 23 25 32
> range(presidents, na.rm = TRUE)
[1] 23 87
> which.min(presidents) # 28
[1] 28
> which.max(presidents) #  2
[1] 2
> 
> ## Find the first occurrence, i.e. the first TRUE, if there is at least one:
> x <- rpois(10000, lambda = 10); x[sample.int(50, 20)] <- NA
> ## where is the first value >= 20 ?
> which.max(x >= 20)
[1] 340
> 
> ## Also works for lists (which can be coerced to numeric vectors):
> which.min(list(A = 7, pi = pi)) ##  ->  c(pi = 2L)
pi 
 2 
> ## Don't show: 
> stopifnot(identical(which.min(list(A = 7, pi = pi)), c(pi = 2L)))
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("with")
> ### * with
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: with
> ### Title: Evaluate an Expression in a Data Environment
> ### Aliases: with with.default within within.list within.data.frame
> ### Keywords: data programming
> 
> ### ** Examples
> 
> with(mtcars, mpg[cyl == 8  &  disp > 350])
[1] 18.7 14.3 10.4 10.4 14.7 19.2 15.8
>     # is the same as, but nicer than
> mtcars$mpg[mtcars$cyl == 8  &  mtcars$disp > 350]
[1] 18.7 14.3 10.4 10.4 14.7 19.2 15.8
> 
> require(stats); require(graphics)
> 
> # examples from glm:
> with(data.frame(u = c(5,10,15,20,30,40,60,80,100),
+                 lot1 = c(118,58,42,35,27,25,21,19,18),
+                 lot2 = c(69,35,26,21,18,16,13,12,12)),
+     list(summary(glm(lot1 ~ log(u), family = Gamma)),
+          summary(glm(lot2 ~ log(u), family = Gamma))))
[[1]]

Call:
glm(formula = lot1 ~ log(u), family = Gamma)

Deviance Residuals: 
     Min        1Q    Median        3Q       Max  
-0.04008  -0.03756  -0.02637   0.02905   0.08641  

Coefficients:
              Estimate Std. Error t value Pr(>|t|)    
(Intercept) -0.0165544  0.0009275  -17.85 4.28e-07 ***
log(u)       0.0153431  0.0004150   36.98 2.75e-09 ***
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

(Dispersion parameter for Gamma family taken to be 0.002446059)

    Null deviance: 3.51283  on 8  degrees of freedom
Residual deviance: 0.01673  on 7  degrees of freedom
AIC: 37.99

Number of Fisher Scoring iterations: 3


[[2]]

Call:
glm(formula = lot2 ~ log(u), family = Gamma)

Deviance Residuals: 
     Min        1Q    Median        3Q       Max  
-0.05574  -0.02925   0.01030   0.01714   0.06371  

Coefficients:
              Estimate Std. Error t value Pr(>|t|)    
(Intercept) -0.0239085  0.0013265  -18.02 4.00e-07 ***
log(u)       0.0235992  0.0005768   40.91 1.36e-09 ***
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

(Dispersion parameter for Gamma family taken to be 0.001813354)

    Null deviance: 3.118557  on 8  degrees of freedom
Residual deviance: 0.012672  on 7  degrees of freedom
AIC: 27.032

Number of Fisher Scoring iterations: 3


> 
> aq <- within(airquality, {     # Notice that multiple vars can be changed
+     lOzone <- log(Ozone)
+     Month <- factor(month.abb[Month])
+     cTemp <- round((Temp - 32) * 5/9, 1) # From Fahrenheit to Celsius
+     S.cT <- Solar.R / cTemp  # using the newly created variable
+     rm(Day, Temp)
+ })
> head(aq)
  Ozone Solar.R Wind Month      S.cT cTemp   lOzone
1    41     190  7.4   May  9.793814  19.4 3.713572
2    36     118  8.0   May  5.315315  22.2 3.583519
3    12     149 12.6   May  6.394850  23.3 2.484907
4    18     313 11.5   May 18.742515  16.7 2.890372
5    NA      NA 14.3   May        NA  13.3       NA
6    28      NA 14.9   May        NA  18.9 3.332205
> 
> 
> 
> 
> # example from boxplot:
> with(ToothGrowth, {
+     boxplot(len ~ dose, boxwex = 0.25, at = 1:3 - 0.2,
+             subset = (supp == "VC"), col = "yellow",
+             main = "Guinea Pigs' Tooth Growth",
+             xlab = "Vitamin C dose mg",
+             ylab = "tooth length", ylim = c(0, 35))
+     boxplot(len ~ dose, add = TRUE, boxwex = 0.25, at = 1:3 + 0.2,
+             subset = supp == "OJ", col = "orange")
+     legend(2, 9, c("Ascorbic acid", "Orange juice"),
+            fill = c("yellow", "orange"))
+ })
> 
> # alternate form that avoids subset argument:
> with(subset(ToothGrowth, supp == "VC"),
+      boxplot(len ~ dose, boxwex = 0.25, at = 1:3 - 0.2,
+              col = "yellow", main = "Guinea Pigs' Tooth Growth",
+              xlab = "Vitamin C dose mg",
+              ylab = "tooth length", ylim = c(0, 35)))
> with(subset(ToothGrowth,  supp == "OJ"),
+      boxplot(len ~ dose, add = TRUE, boxwex = 0.25, at = 1:3 + 0.2,
+              col = "orange"))
> legend(2, 9, c("Ascorbic acid", "Orange juice"),
+        fill = c("yellow", "orange"))
> 
> 
> 
> cleanEx()
> nameEx("withVisible")
> ### * withVisible
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: withVisible
> ### Title: Return both a Value and its Visibility
> ### Aliases: withVisible
> ### Keywords: programming
> 
> ### ** Examples
> 
> x <- 1
> withVisible(x <- 1) # *$visible is FALSE
$value
[1] 1

$visible
[1] FALSE

> x
[1] 1
> withVisible(x)      # *$visible is TRUE
$value
[1] 1

$visible
[1] TRUE

> 
> # Wrap the call in evalq() for special handling
> 
> df <- data.frame(a = 1:5, b = 1:5)
> evalq(withVisible(a + b), envir = df)
$value
[1]  2  4  6  8 10

$visible
[1] TRUE

> 
> 
> 
> cleanEx()
> nameEx("write")
> ### * write
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: write
> ### Title: Write Data to a File
> ### Aliases: write
> ### Keywords: file connection
> 
> ### ** Examples
> 
> # create a 2 by 5 matrix
> x <- matrix(1:10, ncol = 5)
> 
> fil <- tempfile("data")
> # the file data contains x, two rows, five cols
> # 1 3 5 7 9 will form the first row
> write(t(x), fil)
> if(interactive()) file.show(fil)
> unlink(fil) # tidy up
> 
> # Writing to the "console" 'tab-delimited'
> # two rows, five cols but the first row is 1 2 3 4 5
> write(x, "", sep = "\t")
1	2	3	4	5
6	7	8	9	10
> 
> 
> 
> cleanEx()
> nameEx("zMachine")
> ### * zMachine
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: .Machine
> ### Title: Numerical Characteristics of the Machine
> ### Aliases: .Machine
> ### Keywords: sysdata programming math
> 
> ### ** Examples
> 
> .Machine
$double.eps
[1] 2.220446e-16

$double.neg.eps
[1] 1.110223e-16

$double.xmin
[1] 2.225074e-308

$double.xmax
[1] 1.797693e+308

$double.base
[1] 2

$double.digits
[1] 53

$double.rounding
[1] 5

$double.guard
[1] 0

$double.ulp.digits
[1] -52

$double.neg.ulp.digits
[1] -53

$double.exponent
[1] 11

$double.min.exp
[1] -1022

$double.max.exp
[1] 1024

$integer.max
[1] 2147483647

$sizeof.long
[1] 8

$sizeof.longlong
[1] 8

$sizeof.longdouble
[1] 16

$sizeof.pointer
[1] 8

$longdouble.eps
[1] 1.084202e-19

$longdouble.neg.eps
[1] 5.421011e-20

$longdouble.digits
[1] 64

$longdouble.rounding
[1] 5

$longdouble.guard
[1] 0

$longdouble.ulp.digits
[1] -63

$longdouble.neg.ulp.digits
[1] -64

$longdouble.exponent
[1] 15

$longdouble.min.exp
[1] -16382

$longdouble.max.exp
[1] 16384

> ## or for a neat printout
> noquote(unlist(format(.Machine)))
               double.eps            double.neg.eps               double.xmin 
             2.220446e-16              1.110223e-16             2.225074e-308 
              double.xmax               double.base             double.digits 
            1.797693e+308                         2                        53 
          double.rounding              double.guard         double.ulp.digits 
                        5                         0                       -52 
    double.neg.ulp.digits           double.exponent            double.min.exp 
                      -53                        11                     -1022 
           double.max.exp               integer.max               sizeof.long 
                     1024                2147483647                         8 
          sizeof.longlong         sizeof.longdouble            sizeof.pointer 
                        8                        16                         8 
           longdouble.eps        longdouble.neg.eps         longdouble.digits 
             1.084202e-19              5.421011e-20                        64 
      longdouble.rounding          longdouble.guard     longdouble.ulp.digits 
                        5                         0                       -63 
longdouble.neg.ulp.digits       longdouble.exponent        longdouble.min.exp 
                      -64                        15                    -16382 
       longdouble.max.exp 
                    16384 
> 
> 
> 
> cleanEx()
> nameEx("zapsmall")
> ### * zapsmall
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: zapsmall
> ### Title: Rounding of Numbers: Zapping Small Ones to Zero
> ### Aliases: zapsmall
> ### Keywords: arith
> 
> ### ** Examples
> 
> x2 <- pi * 100^(-1:3)
> print(x2 / 1000, digits = 4)
[1] 3.142e-05 3.142e-03 3.142e-01 3.142e+01 3.142e+03
> zapsmall(x2 / 1000, digits = 4)
[1]    0.0    0.0    0.3   31.4 3141.6
> 
> zapsmall(exp(1i*0:4*pi/2))
[1]  1+0i  0+1i -1+0i  0-1i  1+0i
> 
> 
> 
> cleanEx()
> nameEx("zpackages")
> ### * zpackages
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: zpackages
> ### Title: Listing of Packages
> ### Aliases: .packages
> ### Keywords: data
> 
> ### ** Examples
> 
> (.packages())               # maybe just "base"
[1] "stats"     "graphics"  "grDevices" "utils"     "datasets"  "methods"  
[7] "base"     
> .packages(all.available = TRUE) # return all available as character vector
 [1] "base64enc"  "cli"        "crayon"     "digest"     "dplyr"     
 [6] "ellipsis"   "evaluate"   "fansi"      "fastmap"    "generics"  
[11] "glue"       "highr"      "htmltools"  "jsonlite"   "knitr"     
[16] "lifecycle"  "magrittr"   "markdown"   "mime"       "pillar"    
[21] "pkgconfig"  "purrr"      "R6"         "rlang"      "rmarkdown" 
[26] "stringi"    "stringr"    "tibble"     "tidyselect" "tinytex"   
[31] "utf8"       "vctrs"      "xfun"       "yaml"       "base"      
[36] "boot"       "class"      "cluster"    "codetools"  "compiler"  
[41] "datasets"   "foreign"    "graphics"   "grDevices"  "grid"      
[46] "KernSmooth" "lattice"    "MASS"       "Matrix"     "methods"   
[51] "mgcv"       "nlme"       "nnet"       "parallel"   "rpart"     
[56] "spatial"    "splines"    "stats"      "stats4"     "survival"  
[61] "tcltk"      "tools"      "utils"     
> require(splines)
Loading required package: splines
> (.packages())               # "splines", too
[1] "splines"   "stats"     "graphics"  "grDevices" "utils"     "datasets" 
[7] "methods"   "base"     
> detach("package:splines")
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  3.665 0.779 6.678 0.023 0.011 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
