
R version 4.0.3 (2020-10-10) -- "Bunny-Wunnies Freak Out"
Copyright (C) 2020 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "utils"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('utils')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("DLL.version")
> ### * DLL.version
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: DLL.version
> ### Title: DLL Version Information on MS Windows
> ### Aliases: DLL.version
> ### Keywords: utilities
> 
> ### ** Examples
> 
> if(.Platform$OS.type == "windows") withAutoprint({
+   DLL.version(file.path(R.home("bin"), "R.dll"))
+   DLL.version(file.path(R.home(), "library/stats/libs", .Platform$r_arch, "stats.dll"))
+ })
> 
> 
> 
> cleanEx()
> nameEx("LINK")
> ### * LINK
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: LINK
> ### Title: Create Executable Programs on Unix-alikes
> ### Aliases: LINK
> ### Keywords: utilities
> 
> ### ** Examples
> ## Not run: 
> ##D ## examples of front-ends linked against R.
> ##D ## First a C program
> ##D CC=`R CMD config CC`
> ##D R CMD LINK $CC -o foo foo.o `R CMD config --ldflags`
> ##D 
> ##D ## if Fortran code has been compiled into ForFoo.o
> ##D FLIBS=`R CMD config FLIBS`
> ##D R CMD LINK $CC -o foo foo.o ForFoo.o `R CMD config --ldflags` $FLIBS
> ##D 
> ##D ## And for a C++ front-end
> ##D CXX=`R CMD config CXX`
> ##D R CMD COMPILE foo.cc
> ##D R CMD LINK $CXX -o foo foo.o `R CMD config --ldflags`
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("Question")
> ### * Question
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Question
> ### Title: Documentation Shortcuts
> ### Aliases: Question ?
> ### Keywords: documentation
> 
> ### ** Examples
> 
> ?lapply
lapply                  package:base                   R Documentation

_A_p_p_l_y _a _F_u_n_c_t_i_o_n _o_v_e_r _a _L_i_s_t _o_r _V_e_c_t_o_r

_D_e_s_c_r_i_p_t_i_o_n:

     ‘lapply’ returns a list of the same length as ‘X’, each element of
     which is the result of applying ‘FUN’ to the corresponding element
     of ‘X’.

     ‘sapply’ is a user-friendly version and wrapper of ‘lapply’ by
     default returning a vector, matrix or, if ‘simplify = "array"’, an
     array if appropriate, by applying ‘simplify2array()’.  ‘sapply(x,
     f, simplify = FALSE, USE.NAMES = FALSE)’ is the same as ‘lapply(x,
     f)’.

     ‘vapply’ is similar to ‘sapply’, but has a pre-specified type of
     return value, so it can be safer (and sometimes faster) to use.

     ‘replicate’ is a wrapper for the common use of ‘sapply’ for
     repeated evaluation of an expression (which will usually involve
     random number generation).

     ‘simplify2array()’ is the utility called from ‘sapply()’ when
     ‘simplify’ is not false and is similarly called from ‘mapply()’.

_U_s_a_g_e:

     lapply(X, FUN, ...)
     
     sapply(X, FUN, ..., simplify = TRUE, USE.NAMES = TRUE)
     
     vapply(X, FUN, FUN.VALUE, ..., USE.NAMES = TRUE)
     
     replicate(n, expr, simplify = "array")
     
     simplify2array(x, higher = TRUE)
     
_A_r_g_u_m_e_n_t_s:

       X: a vector (atomic or list) or an ‘expression’ object.  Other
          objects (including classed objects) will be coerced by
          ‘base::as.list’.

     FUN: the function to be applied to each element of ‘X’: see
          ‘Details’.  In the case of functions like ‘+’, ‘%*%’, the
          function name must be backquoted or quoted.

     ...: optional arguments to ‘FUN’.

simplify: logical or character string; should the result be simplified
          to a vector, matrix or higher dimensional array if possible?
          For ‘sapply’ it must be named and not abbreviated.  The
          default value, ‘TRUE’, returns a vector or matrix if
          appropriate, whereas if ‘simplify = "array"’ the result may
          be an ‘array’ of “rank” (=‘length(dim(.))’) one higher than
          the result of ‘FUN(X[[i]])’.

USE.NAMES: logical; if ‘TRUE’ and if ‘X’ is character, use ‘X’ as
          ‘names’ for the result unless it had names already.  Since
          this argument follows ‘...’ its name cannot be abbreviated.

FUN.VALUE: a (generalized) vector; a template for the return value from
          FUN.  See ‘Details’.

       n: integer: the number of replications.

    expr: the expression (a language object, usually a call) to
          evaluate repeatedly.

       x: a list, typically returned from ‘lapply()’.

  higher: logical; if true, ‘simplify2array()’ will produce a (“higher
          rank”) array when appropriate, whereas ‘higher = FALSE’ would
          return a matrix (or vector) only.  These two cases correspond
          to ‘sapply(*, simplify = "array")’ or ‘simplify = TRUE’,
          respectively.

_D_e_t_a_i_l_s:

     ‘FUN’ is found by a call to ‘match.fun’ and typically is specified
     as a function or a symbol (e.g., a backquoted name) or a character
     string specifying a function to be searched for from the
     environment of the call to ‘lapply’.

     Function ‘FUN’ must be able to accept as input any of the elements
     of ‘X’.  If the latter is an atomic vector, ‘FUN’ will always be
     passed a length-one vector of the same type as ‘X’.

     Arguments in ‘...’ cannot have the same name as any of the other
     arguments, and care may be needed to avoid partial matching to
     ‘FUN’.  In general-purpose code it is good practice to name the
     first two arguments ‘X’ and ‘FUN’ if ‘...’ is passed through: this
     both avoids partial matching to ‘FUN’ and ensures that a sensible
     error message is given if arguments named ‘X’ or ‘FUN’ are passed
     through ‘...’.

     Simplification in ‘sapply’ is only attempted if ‘X’ has length
     greater than zero and if the return values from all elements of
     ‘X’ are all of the same (positive) length.  If the common length
     is one the result is a vector, and if greater than one is a matrix
     with a column corresponding to each element of ‘X’.

     Simplification is always done in ‘vapply’.  This function checks
     that all values of ‘FUN’ are compatible with the ‘FUN.VALUE’, in
     that they must have the same length and type.  (Types may be
     promoted to a higher type within the ordering logical < integer <
     double < complex, but not demoted.)

     Users of S4 classes should pass a list to ‘lapply’ and ‘vapply’:
     the internal coercion is done by the ‘as.list’ in the base
     namespace and not one defined by a user (e.g., by setting S4
     methods on the base function).

_V_a_l_u_e:

     For ‘lapply’, ‘sapply(simplify = FALSE)’ and ‘replicate(simplify =
     FALSE)’, a list.

     For ‘sapply(simplify = TRUE)’ and ‘replicate(simplify = TRUE)’: if
     ‘X’ has length zero or ‘n = 0’, an empty list.  Otherwise an
     atomic vector or matrix or list of the same length as ‘X’ (of
     length ‘n’ for ‘replicate’).  If simplification occurs, the output
     type is determined from the highest type of the return values in
     the hierarchy NULL < raw < logical < integer < double < complex <
     character < list < expression, after coercion of pairlists to
     lists.

     ‘vapply’ returns a vector or array of type matching the
     ‘FUN.VALUE’.  If ‘length(FUN.VALUE) == 1’ a vector of the same
     length as ‘X’ is returned, otherwise an array.  If ‘FUN.VALUE’ is
     not an ‘array’, the result is a matrix with ‘length(FUN.VALUE)’
     rows and ‘length(X)’ columns, otherwise an array ‘a’ with ‘dim(a)
     == c(dim(FUN.VALUE), length(X))’.

     The (Dim)names of the array value are taken from the ‘FUN.VALUE’
     if it is named, otherwise from the result of the first function
     call.  Column names of the matrix or more generally the names of
     the last dimension of the array value or names of the vector value
     are set from ‘X’ as in ‘sapply’.

_N_o_t_e:

     ‘sapply(*, simplify = FALSE, USE.NAMES = FALSE)’ is equivalent to
     ‘lapply(*)’.

     For historical reasons, the calls created by ‘lapply’ are
     unevaluated, and code has been written (e.g., ‘bquote’) that
     relies on this.  This means that the recorded call is always of
     the form ‘FUN(X[[i]], ...)’, with ‘i’ replaced by the current
     (integer or double) index.  This is not normally a problem, but it
     can be if ‘FUN’ uses ‘sys.call’ or ‘match.call’ or if it is a
     primitive function that makes use of the call.  This means that it
     is often safer to call primitive functions with a wrapper, so that
     e.g. ‘lapply(ll, function(x) is.numeric(x))’ is required to ensure
     that method dispatch for ‘is.numeric’ occurs correctly.

     If ‘expr’ is a function call, be aware of assumptions about where
     it is evaluated, and in particular what ‘...’ might refer to.  You
     can pass additional named arguments to a function call as
     additional named arguments to ‘replicate’: see ‘Examples’.

_R_e_f_e_r_e_n_c_e_s:

     Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988) _The New S
     Language_.  Wadsworth & Brooks/Cole.

_S_e_e _A_l_s_o:

     ‘apply’, ‘tapply’, ‘mapply’ for applying a function to *m*ultiple
     arguments, and ‘rapply’ for a *r*ecursive version of ‘lapply()’,
     ‘eapply’ for applying a function to each entry in an
     ‘environment’.

_E_x_a_m_p_l_e_s:

     require(stats); require(graphics)
     
     x <- list(a = 1:10, beta = exp(-3:3), logic = c(TRUE,FALSE,FALSE,TRUE))
     # compute the list mean for each list element
     lapply(x, mean)
     # median and quartiles for each list element
     lapply(x, quantile, probs = 1:3/4)
     sapply(x, quantile)
     i39 <- sapply(3:9, seq) # list of vectors
     sapply(i39, fivenum)
     vapply(i39, fivenum,
            c(Min. = 0, "1st Qu." = 0, Median = 0, "3rd Qu." = 0, Max. = 0))
     
     ## sapply(*, "array") -- artificial example
     (v <- structure(10*(5:8), names = LETTERS[1:4]))
     f2 <- function(x, y) outer(rep(x, length.out = 3), y)
     (a2 <- sapply(v, f2, y = 2*(1:5), simplify = "array"))
     a.2 <- vapply(v, f2, outer(1:3, 1:5), y = 2*(1:5))
     stopifnot(dim(a2) == c(3,5,4), all.equal(a2, a.2),
               identical(dimnames(a2), list(NULL,NULL,LETTERS[1:4])))
     
     hist(replicate(100, mean(rexp(10))))
     
     ## use of replicate() with parameters:
     foo <- function(x = 1, y = 2) c(x, y)
     # does not work: bar <- function(n, ...) replicate(n, foo(...))
     bar <- function(n, x) replicate(n, foo(x = x))
     bar(5, x = 3)
     

> 
> ?"for"                  # but quotes/backticks are needed
Control                  package:base                  R Documentation

_C_o_n_t_r_o_l _F_l_o_w

_D_e_s_c_r_i_p_t_i_o_n:

     These are the basic control-flow constructs of the R language.
     They function in much the same way as control statements in any
     Algol-like language.  They are all reserved words.

_U_s_a_g_e:

     if(cond) expr
     if(cond) cons.expr  else  alt.expr
     
     for(var in seq) expr
     while(cond) expr
     repeat expr
     break
     next
     
_A_r_g_u_m_e_n_t_s:

    cond: A length-one logical vector that is not ‘NA’.  Conditions of
          length greater than one are currently accepted with a
          warning, but only the first element is used.  An error is
          signalled instead when the environment variable
          ‘_R_CHECK_LENGTH_1_CONDITION_’ is set to true.  Other types
          are coerced to logical if possible, ignoring any class.

     var: A syntactical name for a variable.

     seq: An expression evaluating to a vector (including a list and an
          expression) or to a pairlist or ‘NULL’.  A factor value will
          be coerced to a character vector.  As from R 4.0.0 this can
          be a long vector.

expr, cons.expr, alt.expr: An _expression_ in a formal sense.  This is
          either a simple expression or a so-called _compound
          expression_, usually of the form ‘{ expr1 ; expr2 }’.

_D_e_t_a_i_l_s:

     ‘break’ breaks out of a ‘for’, ‘while’ or ‘repeat’ loop; control
     is transferred to the first statement outside the inner-most loop.
     ‘next’ halts the processing of the current iteration and advances
     the looping index.  Both ‘break’ and ‘next’ apply only to the
     innermost of nested loops.

     Note that it is a common mistake to forget to put braces (‘{ ..
     }’) around your statements, e.g., after ‘if(..)’ or ‘for(....)’.
     In particular, you should not have a newline between ‘}’ and
     ‘else’ to avoid a syntax error in entering a ‘if ... else’
     construct at the keyboard or via ‘source’.  For that reason, one
     (somewhat extreme) attitude of defensive programming is to always
     use braces, e.g., for ‘if’ clauses.

     The ‘seq’ in a ‘for’ loop is evaluated at the start of the loop;
     changing it subsequently does not affect the loop.  If ‘seq’ has
     length zero the body of the loop is skipped. Otherwise the
     variable ‘var’ is assigned in turn the value of each element of
     ‘seq’. You can assign to ‘var’ within the body of the loop, but
     this will not affect the next iteration.  When the loop
     terminates, ‘var’ remains as a variable containing its latest
     value.

_V_a_l_u_e:

     ‘if’ returns the value of the expression evaluated, or ‘NULL’
     invisibly if none was (which may happen if there is no ‘else’).

     ‘for’, ‘while’ and ‘repeat’ return ‘NULL’ invisibly.  ‘for’ sets
     ‘var’ to the last used element of ‘seq’, or to ‘NULL’ if it was of
     length zero.

     ‘break’ and ‘next’ do not return a value as they transfer control
     within the loop.

_R_e_f_e_r_e_n_c_e_s:

     Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988) _The New S
     Language_.  Wadsworth & Brooks/Cole.

_S_e_e _A_l_s_o:

     ‘Syntax’ for the basic R syntax and operators, ‘Paren’ for
     parentheses and braces.

     ‘ifelse’, ‘switch’ for other ways to control flow.

_E_x_a_m_p_l_e_s:

     for(i in 1:5) print(1:i)
     for(n in c(2,5,10,20,50)) {
        x <- stats::rnorm(n)
        cat(n, ": ", sum(x^2), "\n", sep = "")
     }
     f <- factor(sample(letters[1:5], 10, replace = TRUE))
     for(i in unique(f)) print(i)
     

> ?`+`
Arithmetic                package:base                 R Documentation

_A_r_i_t_h_m_e_t_i_c _O_p_e_r_a_t_o_r_s

_D_e_s_c_r_i_p_t_i_o_n:

     These unary and binary operators perform arithmetic on numeric or
     complex vectors (or objects which can be coerced to them).

_U_s_a_g_e:

     + x
     - x
     x + y
     x - y
     x * y
     x / y
     x ^ y
     x %% y
     x %/% y
     
_A_r_g_u_m_e_n_t_s:

    x, y: numeric or complex vectors or objects which can be coerced to
          such, or other objects for which methods have been written.

_D_e_t_a_i_l_s:

     The unary and binary arithmetic operators are generic functions:
     methods can be written for them individually or via the ‘Ops’
     group generic function.  (See ‘Ops’ for how dispatch is computed.)

     If applied to arrays the result will be an array if this is
     sensible (for example it will not if the recycling rule has been
     invoked).

     Logical vectors will be coerced to integer or numeric vectors,
     ‘FALSE’ having value zero and ‘TRUE’ having value one.

     ‘1 ^ y’ and ‘y ^ 0’ are ‘1’, _always_.  ‘x ^ y’ should also give
     the proper limit result when either (numeric) argument is infinite
     (one of ‘Inf’ or ‘-Inf’).

     Objects such as arrays or time-series can be operated on this way
     provided they are conformable.

     For double arguments, ‘%%’ can be subject to catastrophic loss of
     accuracy if ‘x’ is much larger than ‘y’, and a warning is given if
     this is detected.

     ‘%%’ and ‘x %/% y’ can be used for non-integer ‘y’, e.g. ‘1 %/%
     0.2’, but the results are subject to representation error and so
     may be platform-dependent.  Because the IEC 60559 representation
     of ‘0.2’ is a binary fraction slightly larger than ‘0.2’, the
     answer to ‘1 %/% 0.2’ should be ‘4’ but most platforms give ‘5’.

     Users are sometimes surprised by the value returned, for example
     why ‘(-8)^(1/3)’ is ‘NaN’.  For double inputs, R makes use of IEC
     60559 arithmetic on all platforms, together with the C system
     function ‘pow’ for the ‘^’ operator.  The relevant standards
     define the result in many corner cases.  In particular, the result
     in the example above is mandated by the C99 standard.  On many
     Unix-alike systems the command ‘man pow’ gives details of the
     values in a large number of corner cases.

     Arithmetic on type double in R is supposed to be done in ‘round to
     nearest, ties to even’ mode, but this does depend on the compiler
     and FPU being set up correctly.

_V_a_l_u_e:

     Unary ‘+’ and unary ‘-’ return a numeric or complex vector.  All
     attributes (including class) are preserved if there is no
     coercion: logical ‘x’ is coerced to integer and names, dims and
     dimnames are preserved.

     The binary operators return vectors containing the result of the
     element by element operations.  If involving a zero-length vector
     the result has length zero.  Otherwise, the elements of shorter
     vectors are recycled as necessary (with a ‘warning’ when they are
     recycled only _fractionally_).  The operators are ‘+’ for
     addition, ‘-’ for subtraction, ‘*’ for multiplication, ‘/’ for
     division and ‘^’ for exponentiation.

     ‘%%’ indicates ‘x mod y’ (“x modulo y”) and ‘%/%’ indicates
     integer division.  It is guaranteed that

     ‘ x == (x %% y) + y * (x %/% y) ’ (up to rounding error)

     unless ‘y == 0’ where the result of ‘%%’ is ‘NA_integer_’ or ‘NaN’
     (depending on the ‘typeof’ of the arguments) or for some
     non-finite arguments, e.g., when the RHS of the identity above
     amounts to ‘Inf - Inf’.

     If either argument is complex the result will be complex,
     otherwise if one or both arguments are numeric, the result will be
     numeric.  If both arguments are of type integer, the type of the
     result of ‘/’ and ‘^’ is numeric and for the other operators it is
     integer (with overflow, which occurs at +/- (2^31 - 1), returned
     as ‘NA_integer_’ with a warning).

     The rules for determining the attributes of the result are rather
     complicated.  Most attributes are taken from the longer argument.
     Names will be copied from the first if it is the same length as
     the answer, otherwise from the second if that is.  If the
     arguments are the same length, attributes will be copied from
     both, with those of the first argument taking precedence when the
     same attribute is present in both arguments. For time series,
     these operations are allowed only if the series are compatible,
     when the class and ‘tsp’ attribute of whichever is a time series
     (the same, if both are) are used.  For arrays (and an array
     result) the dimensions and dimnames are taken from first argument
     if it is an array, otherwise the second.

_S_4 _m_e_t_h_o_d_s:

     These operators are members of the S4 ‘Arith’ group generic, and
     so methods can be written for them individually as well as for the
     group generic (or the ‘Ops’ group generic), with arguments ‘c(e1,
     e2)’ (with ‘e2’ missing for a unary operator).

_I_m_p_l_e_m_e_n_t_a_t_i_o_n _l_i_m_i_t_s:

     R is dependent on OS services (and they on FPUs) for
     floating-point arithmetic.  On all current R platforms IEC 60559
     (also known as IEEE 754) arithmetic is used, but some things in
     those standards are optional.  In particular, the support for
     _denormal_ aka _subnormal_ numbers (those outside the range given
     by ‘.Machine’) may differ between platforms and even between
     calculations on a single platform.

     Another potential issue is signed zeroes: on IEC 60559 platforms
     there are two zeroes with internal representations differing by
     sign.  Where possible R treats them as the same, but for example
     direct output from C code often does not do so and may output
     ‘-0.0’ (and on Windows whether it does so or not depends on the
     version of Windows).  One place in R where the difference might be
     seen is in division by zero: ‘1/x’ is ‘Inf’ or ‘-Inf’ depending on
     the sign of zero ‘x’.  Another place is ‘identical(0, -0, num.eq =
     FALSE)’.

_N_o_t_e:

     All logical operations involving a zero-length vector have a
     zero-length result.

     The binary operators are sometimes called as functions as e.g.
     ‘`&`(x, y)’: see the description of how argument-matching is done
     in ‘Ops’.

     ‘**’ is translated in the parser to ‘^’, but this was undocumented
     for many years.  It appears as an index entry in Becker _et al_
     (1988), pointing to the help for ‘Deprecated’ but is not actually
     mentioned on that page.  Even though it had been deprecated in S
     for 20 years, it was still accepted in R in 2008.

_R_e_f_e_r_e_n_c_e_s:

     Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988) _The New S
     Language_.  Wadsworth & Brooks/Cole.

     D. Goldberg (1991).  What Every Computer Scientist Should Know
     about Floating-Point Arithmetic.  _ACM Computing Surveys_,
     *23*(1), 5-48.  doi: 10.1145/103162.103163 (URL:
     https://doi.org/10.1145/103162.103163).

     Postscript version available at <URL:
     http://www.validlab.com/goldberg/paper.ps>.  Extended PDF version
     at <URL: http://www.validlab.com/goldberg/paper.pdf>.

     For the IEC 60559 (aka IEEE 754) standard: <URL:
     https://www.iso.org/standard/57469.html> and <URL:
     https://en.wikipedia.org/wiki/IEEE_754>.

_S_e_e _A_l_s_o:

     ‘sqrt’ for miscellaneous and ‘Special’ for special mathematical
     functions.

     ‘Syntax’ for operator precedence.

     ‘%*%’ for matrix multiplication.

_E_x_a_m_p_l_e_s:

     x <- -1:12
     x + 1
     2 * x + 3
     x %% 2 #-- is periodic
     x %/% 5
     x %% Inf # now is defined by limit (gave NaN in earlier versions of R)
     

> 
> ?women                  # information about data set "women"
women                 package:datasets                 R Documentation

_A_v_e_r_a_g_e _H_e_i_g_h_t_s _a_n_d _W_e_i_g_h_t_s _f_o_r _A_m_e_r_i_c_a_n _W_o_m_e_n

_D_e_s_c_r_i_p_t_i_o_n:

     This data set gives the average heights and weights for American
     women aged 30-39.

_U_s_a_g_e:

     women
     
_F_o_r_m_a_t:

     A data frame with 15 observations on 2 variables.

       ‘[,1]’  ‘height’  numeric  Height (in)  
       ‘[,2]’  ‘weight’  numeric  Weight (lbs) 
      
_D_e_t_a_i_l_s:

     The data set appears to have been taken from the American Society
     of Actuaries _Build and Blood Pressure Study_ for some (unknown to
     us) earlier year.

     The World Almanac notes: “The figures represent weights in
     ordinary indoor clothing and shoes, and heights with shoes”.

_S_o_u_r_c_e:

     The World Almanac and Book of Facts, 1975.

_R_e_f_e_r_e_n_c_e_s:

     McNeil, D. R. (1977) _Interactive Data Analysis_.  Wiley.

_E_x_a_m_p_l_e_s:

     require(graphics)
     plot(women, xlab = "Height (in)", ylab = "Weight (lb)",
          main = "women data: American women aged 30-39")
     

> 
> ## Not run: 
> ##D require(methods)
> ##D ## define a S4 generic function and some methods
> ##D combo <- function(x, y) c(x, y)
> ##D setGeneric("combo")
> ##D setMethod("combo", c("numeric", "numeric"), function(x, y) x+y)
> ##D 
> ##D ## assume we have written some documentation
> ##D ## for combo, and its methods ....
> ##D 
> ##D ?combo  # produces the function documentation
> ##D 
> ##D methods?combo  # looks for the overall methods documentation
> ##D 
> ##D method?combo("numeric", "numeric")  # documentation for the method above
> ##D 
> ##D ?combo(1:10, rnorm(10))  # ... the same method, selected according to
> ##D                          # the arguments (one integer, the other numeric)
> ##D 
> ##D ?combo(1:10, letters)    # documentation for the default method
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("RShowDoc")
> ### * RShowDoc
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: RShowDoc
> ### Title: Show R Manuals and Other Documentation
> ### Aliases: RShowDoc
> ### Keywords: documentation
> 
> ### ** Examples
> 
> 
> cleanEx()
> nameEx("RSiteSearch")
> ### * RSiteSearch
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: RSiteSearch
> ### Title: Search for Key Words or Phrases in Documentation
> ### Aliases: RSiteSearch
> ### Keywords: utilities documentation
> 
> ### ** Examples
> 
> 
> cleanEx()
> nameEx("Rconsole")
> ### * Rconsole
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Rwin configuration
> ### Title: R for Windows Configuration
> ### Aliases: Rconsole Rdevga loadRconsole
> ### Keywords: utilities
> 
> ### ** Examples
> 
> if(.Platform$OS.type == "windows") withAutoprint({
+   ruser <- Sys.getenv("R_USER")
+   cat("\n\nLocation for personal configuration files is\n   R_USER = ",
+       ruser, "\n\n", sep = "")
+   ## see if there are personal configuration files
+   file.exists(file.path(ruser, c("Rconsole", "Rdevga")))
+ 
+   ## show the configuration files used
+   showConfig <- function(file)
+   {
+       ruser <- Sys.getenv("R_USER")
+       path <- file.path(ruser, file)
+       if(!file.exists(path)) path <- file.path(R.home(), "etc", file)
+       file.show(path, header = path)
+   }
+   showConfig("Rconsole")
+ })
> 
> 
> 
> cleanEx()
> nameEx("Rprof")
> ### * Rprof
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Rprof
> ### Title: Enable Profiling of R's Execution
> ### Aliases: Rprof
> ### Keywords: utilities
> 
> ### ** Examples
> 
> ## Not run: 
> ##D Rprof()
> ##D ## some code to be profiled
> ##D Rprof(NULL)
> ##D ## some code NOT to be profiled
> ##D Rprof(append = TRUE)
> ##D ## some code to be profiled
> ##D Rprof(NULL)
> ##D ...
> ##D ## Now post-process the output as described in Details
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("Rprofmem")
> ### * Rprofmem
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Rprofmem
> ### Title: Enable Profiling of R's Memory Use
> ### Aliases: Rprofmem
> ### Keywords: utilities
> 
> ### ** Examples
> ## Not run: 
> ##D ## not supported unless R is compiled to support it.
> ##D Rprofmem("Rprofmem.out", threshold = 1000)
> ##D example(glm)
> ##D Rprofmem(NULL)
> ##D noquote(readLines("Rprofmem.out", n = 5))
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("Rscript")
> ### * Rscript
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Rscript
> ### Title: Scripting Front-End for R
> ### Aliases: Rscript
> ### Keywords: utilities
> 
> ### ** Examples
> ## Not run: 
> ##D Rscript -e 'date()' -e 'format(Sys.time(), "%a %b %d %X %Y")'
> ##D 
> ##D # Get the same initial packages in the same order as default R:
> ##D Rscript --default-packages=methods,datasets,utils,grDevices,graphics,stats -e 'sessionInfo()'
> ##D 
> ##D ## example #! script for a Unix-alike
> ##D 
> ##D #! /path/to/Rscript --vanilla --default-packages=utils
> ##D args <- commandArgs(TRUE)
> ##D res <- try(install.packages(args))
> ##D if(inherits(res, "try-error")) q(status=1) else q()
> ##D 
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("Rtangle")
> ### * Rtangle
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Rtangle
> ### Title: R Driver for Stangle
> ### Aliases: Rtangle RtangleSetup
> ### Keywords: utilities
> 
> ### ** Examples
> 
> nmRnw <- "example-1.Rnw"
> exfile <- system.file("Sweave", nmRnw, package = "utils")
> ## Create R source file
> Stangle(exfile)
Writing to file example-1.R 
> nmR <- sub("Rnw$", "R", nmRnw) # the (default) R output file name
> if(interactive()) file.show("example-1.R")
> ## Don't show: 
> file.rename("example-1.R", "example-1_def.R")
[1] TRUE
> ## End(Don't show)
> ## Smaller R source file with custom annotation:
> my.Ann <- function(options, chunk, output) {
+   cat("### chunk #", options$chunknr, ": ",
+       if(!is.null(ol <- options$label)) ol else .RtangleCodeLabel(chunk),
+       if(!options$eval) " (eval = FALSE)", "\n",
+       file = output, sep = "")
+ }
> Stangle(exfile, annotate = my.Ann)
Writing to file example-1.R 
> if(interactive()) file.show("example-1.R")
> ## Don't show: 
> file.rename("example-1.R", "example-1_myA.R")
[1] TRUE
> ## End(Don't show)
> Stangle(exfile, annotate = my.Ann, drop.evalFALSE=TRUE)
Writing to file example-1.R 
> if(interactive()) file.show("example-1.R")
> ## Don't show: 
> file.rename("example-1.R", "example-1_myA-noF.R")
[1] TRUE
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("SHLIB")
> ### * SHLIB
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: SHLIB
> ### Title: Build Shared Object/DLL for Dynamic Loading
> ### Aliases: SHLIB
> ### Keywords: utilities
> 
> ### ** Examples
> ## Not run: 
> ##D # To link against a library not on the system library paths:
> ##D R CMD SHLIB -o mylib.so a.f b.f -L/opt/acml3.5.0/gnu64/lib -lacml
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("Sweave")
> ### * Sweave
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Sweave
> ### Title: Automatic Generation of Reports
> ### Aliases: Sweave Stangle SweaveSyntaxLatex SweaveSyntaxNoweb
> ### Keywords: utilities
> 
> ### ** Examples
> 
> testfile <- system.file("Sweave", "Sweave-test-1.Rnw", package = "utils")
> ## Don't show: 
> oldwd <- setwd(tempdir()) # so we will write only to a temp directory
> ## End(Don't show)
> 
> ## enforce par(ask = FALSE)
> options(device.ask.default = FALSE)
> 
> ## create a LaTeX file - in the current working directory, getwd():
> Sweave(testfile)
Writing to file Sweave-test-1.tex
Processing code chunks with options ...
 1 : keep.source print term verbatim (Sweave-test-1.Rnw:15)
 2 : keep.source term hide (Sweave-test-1.Rnw:17)
 3 : echo keep.source print term verbatim (Sweave-test-1.Rnw:22)
 4 : keep.source term verbatim (Sweave-test-1.Rnw:30)
 5 : echo keep.source term verbatim (Sweave-test-1.Rnw:45)
 6 : echo keep.source term verbatim pdf  (Sweave-test-1.Rnw:53)
 7 : echo keep.source term verbatim pdf  (Sweave-test-1.Rnw:63)

You can now run (pdf)latex on ‘Sweave-test-1.tex’
> 
> ## This can be compiled to PDF by
> ## tools::texi2pdf("Sweave-test-1.tex")
> 
> ## or outside R by
> ##
> ## 	R CMD texi2pdf Sweave-test-1.tex
> ## on Unix-alikes which sets the appropriate TEXINPUTS path.
> ##
> ## On Windows,
> ##      Rcmd texify --pdf Sweave-test-1.tex
> ## if MiKTeX is available.
> 
> ## create an R source file from the code chunks
> Stangle(testfile)
Writing to file Sweave-test-1.R 
> ## which can be sourced, e.g.
> source("Sweave-test-1.R")
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20
 [1]  0.91897737  0.78213630  0.07456498 -1.98935170  0.61982575 -0.05612874
 [7] -0.15579551 -1.47075238 -0.47815006  0.41794156  1.35867955 -0.10278773
[13]  0.38767161 -0.05380504 -1.37705956 -0.41499456 -0.39428995 -0.05931340
[19]  1.10002537  0.76317575

	One Sample t-test

data:  x
t = -0.033214, df = 19, p-value = 0.9739
alternative hypothesis: true mean is not equal to 0
95 percent confidence interval:
 -0.414283  0.401340
sample estimates:
   mean of x 
-0.006471519 

> 
> ## Don't show: 
> if(!interactive()) unlink("Sweave-test-1*")
> setwd(oldwd)
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("SweaveSyntConv")
> ### * SweaveSyntConv
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: SweaveSyntConv
> ### Title: Convert Sweave Syntax
> ### Aliases: SweaveSyntConv
> ### Keywords: utilities
> 
> ### ** Examples
> 
> testfile <- system.file("Sweave", "Sweave-test-1.Rnw", package = "utils")
> ## Don't show: 
> oldwd <- setwd(tempdir())
> ## End(Don't show)
> 
> ## convert the file to latex syntax
> SweaveSyntConv(testfile, SweaveSyntaxLatex)
Wrote file Sweave-test-1.Stex 
> 
> ## and run it through Sweave
> Sweave("Sweave-test-1.Stex")
Writing to file Sweave-test-1.tex
Processing code chunks with options ...
 1 : keep.source print term verbatim (Sweave-test-1.Stex:15)
 2 : keep.source term hide (Sweave-test-1.Stex:17)
 3 : echo keep.source print term verbatim (Sweave-test-1.Stex:22)
 4 : keep.source term verbatim (Sweave-test-1.Stex:30)
 5 : echo keep.source term verbatim (Sweave-test-1.Stex:45)
 6 : echo keep.source term verbatim pdf  (Sweave-test-1.Stex:53)
 7 : echo keep.source term verbatim pdf  (Sweave-test-1.Stex:63)

You can now run (pdf)latex on ‘Sweave-test-1.tex’
> 
> ## Don't show: 
>  if(!interactive()) unlink("Sweave-test-1*") ; setwd(oldwd) 
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("URLencode")
> ### * URLencode
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: URLencode
> ### Title: Encode or Decode a (partial) URL
> ### Aliases: URLencode URLdecode
> ### Keywords: utilities
> 
> ### ** Examples
> 
> (y <- URLencode("a url with spaces and / and @"))
[1] "a%20url%20with%20spaces%20and%20/%20and%20@"
> URLdecode(y)
[1] "a url with spaces and / and @"
> (y <- URLencode("a url with spaces and / and @", reserved = TRUE))
[1] "a%20url%20with%20spaces%20and%20%2F%20and%20%40"
> URLdecode(y)
[1] "a url with spaces and / and @"
> 
> URLdecode(z <- "ab%20cd")
[1] "ab cd"
> c(URLencode(z), URLencode(z, repeated = TRUE)) # first is usually wanted
[1] "ab%20cd"   "ab%2520cd"
> 
> 
> 
> cleanEx()
> nameEx("adist")
> ### * adist
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: adist
> ### Title: Approximate String Distances
> ### Aliases: adist
> ### Keywords: character
> 
> ### ** Examples
> 
> ## Cf. https://en.wikipedia.org/wiki/Levenshtein_distance
> adist("kitten", "sitting")
     [,1]
[1,]    3
> ## To see the transformation counts for the Levenshtein distance:
> drop(attr(adist("kitten", "sitting", counts = TRUE), "counts"))
ins del sub 
  1   0   2 
> ## To see the transformation sequences:
> attr(adist(c("kitten", "sitting"), counts = TRUE), "trafos")
     [,1]      [,2]     
[1,] "MMMMMM"  "SMMMSMI"
[2,] "SMMMSMD" "MMMMMMM"
> 
> ## Cf. the examples for agrep:
> adist("lasy", "1 lazy 2")
     [,1]
[1,]    5
> ## For a "partial approximate match" (as used for agrep):
> adist("lasy", "1 lazy 2", partial = TRUE)
     [,1]
[1,]    1
> 
> 
> 
> cleanEx()
> nameEx("alarm")
> ### * alarm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: alarm
> ### Title: Alert the User
> ### Aliases: alarm
> ### Keywords: utilities
> 
> ### ** Examples
> 
> alarm()
> 
> 
> 
> cleanEx()
> nameEx("apropos")
> ### * apropos
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: apropos
> ### Title: Find Objects by (Partial) Name
> ### Aliases: apropos find
> ### Keywords: data documentation environment
> 
> ### ** Examples
> 
> require(stats)
> 
> ## Not run: apropos("lm")
> apropos("GLM")                      # several
[1] "glm"           "glm.control"   "glm.fit"       "predict.glm"  
[5] "residuals.glm" "summary.glm"  
> apropos("GLM", ignore.case = FALSE) # not one
character(0)
> apropos("lq")
[1] "evalq"       "evalqOnLoad"
> 
> cor <- 1:pi
> find("cor")                         #> ".GlobalEnv"   "package:stats"
[1] ".GlobalEnv"    "package:stats"
> find("cor", numeric = TRUE)                     # numbers with these names
   .GlobalEnv package:stats 
            1             3 
> find("cor", numeric = TRUE, mode = "function")  # only the second one
package:stats 
            3 
> rm(cor)
> 
> ## Not run: apropos(".", mode="list")  # a long list
> 
> # need a DOUBLE backslash '\\' (in case you don't see it anymore)
> apropos("\\[")
 [1] "["                    "[.AsIs"               "[.data.frame"        
 [4] "[.Date"               "[.difftime"           "[.Dlist"             
 [7] "[.DLLInfoList"        "[.factor"             "[.hexmode"           
[10] "[.listof"             "[.noquote"            "[.numeric_version"   
[13] "[.octmode"            "[.POSIXct"            "[.POSIXlt"           
[16] "[.simple.list"        "[.table"              "[.warnings"          
[19] "[["                   "[[.data.frame"        "[[.Date"             
[22] "[[.factor"            "[[.numeric_version"   "[[.POSIXct"          
[25] "[[.POSIXlt"           "[[<-"                 "[[<-.data.frame"     
[28] "[[<-.factor"          "[[<-.numeric_version" "[[<-.POSIXlt"        
[31] "[<-"                  "[<-.data.frame"       "[<-.Date"            
[34] "[<-.factor"           "[<-.numeric_version"  "[<-.POSIXct"         
[37] "[<-.POSIXlt"         
> 
> 
> 
> cleanEx()
> nameEx("aregexec")
> ### * aregexec
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: aregexec
> ### Title: Approximate String Match Positions
> ### Aliases: aregexec
> ### Keywords: character
> 
> ### ** Examples
> 
> ## Cf. the examples for agrep.
> x <- c("1 lazy", "1", "1 LAZY")
> aregexec("laysy", x, max.distance = 2)
[[1]]
[1] 3
attr(,"match.length")
[1] 4

[[2]]
[1] -1
attr(,"match.length")
[1] -1

[[3]]
[1] -1
attr(,"match.length")
[1] -1

> aregexec("(lay)(sy)", x, max.distance = 2)
[[1]]
[1] 3 3 5
attr(,"match.length")
[1] 4 2 2

[[2]]
[1] -1
attr(,"match.length")
[1] -1

[[3]]
[1] -1
attr(,"match.length")
[1] -1

> aregexec("(lay)(sy)", x, max.distance = 2, ignore.case = TRUE)
[[1]]
[1] 3 3 6
attr(,"match.length")
[1] 4 3 1

[[2]]
[1] -1
attr(,"match.length")
[1] -1

[[3]]
[1] 3 3 6
attr(,"match.length")
[1] 4 3 1

> m <- aregexec("(lay)(sy)", x, max.distance = 2)
> regmatches(x, m)
[[1]]
[1] "lazy" "la"   "zy"  

[[2]]
character(0)

[[3]]
character(0)

> 
> 
> 
> cleanEx()
> nameEx("arrangeWindows")
> ### * arrangeWindows
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: arrangeWindows
> ### Title: Rearrange Windows on MS Windows
> ### Aliases: arrangeWindows
> ### Keywords: utilities
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ## Only available on Windows :
> ##D arrangeWindows("v")
> ##D # This default is useful only in SDI mode:  it will tile any Firefox window
> ##D # along with the R windows
> ##D .arrangeWindowsDefaults <- list(c("R", "all"), pattern = c("", "Firefox"))
> ##D arrangeWindows("v")
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("askYesNo")
> ### * askYesNo
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: askYesNo
> ### Title: Ask a Yes/No Question
> ### Aliases: askYesNo
> ### Keywords: utilities
> 
> ### ** Examples
> 
> if (interactive())
+     askYesNo("Do you want to use askYesNo?")
> 
> 
> 
> cleanEx()
> nameEx("aspell")
> ### * aspell
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: aspell
> ### Title: Spell Check Interface
> ### Aliases: aspell
> ### Keywords: utilities
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ## To check all Rd files in a directory, (additionally) skipping the
> ##D ## \references sections.
> ##D files <- Sys.glob("*.Rd")
> ##D aspell(files, filter = list("Rd", drop = "\\references"))
> ##D 
> ##D ## To check all Sweave files
> ##D files <- Sys.glob(c("*.Rnw", "*.Snw", "*.rnw", "*.snw"))
> ##D aspell(files, filter = "Sweave", control = "-t")
> ##D 
> ##D ## To check all Texinfo files (Aspell only)
> ##D files <- Sys.glob("*.texi")
> ##D aspell(files, control = "--mode=texinfo")
> ## End(Not run)
> 
> ## List the available R system dictionaries.
> Sys.glob(file.path(R.home("share"), "dictionaries", "*.rds"))
[1] "/usr/local/lib/R/share/dictionaries/en_stats.rds"
> 
> 
> 
> cleanEx()
> nameEx("available.packages")
> ### * available.packages
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: available.packages
> ### Title: List Available Packages at CRAN-like Repositories
> ### Aliases: available.packages R_AVAILABLE_PACKAGES_CACHE_CONTROL_MAX_AGE
> ### Keywords: utilities
> 
> ### ** Examples
> ## Not run: 
> ##D ## Restrict install.packages() (etc) to known-to-be-FOSS packages
> ##D options(available_packages_filters =
> ##D   c("R_version", "OS_type", "subarch", "duplicates", "license/FOSS"))
> ##D ## or
> ##D options(available_packages_filters = list(add = TRUE, "license/FOSS"))
> ##D 
> ##D ## Give priority to released versions on CRAN, rather than development
> ##D ## versions on Omegahat, R-Forge etc.
> ##D options(available_packages_filters =
> ##D      c("R_version", "OS_type", "subarch", "CRAN", "duplicates"))
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("bibentry")
> ### * bibentry
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bibentry
> ### Title: Bibliography Entries
> ### Aliases: bibentry print.bibentry format.bibentry sort.bibentry
> ###   print.citation format.citation
> ### Keywords: utilities documentation
> 
> ### ** Examples
> 
> ## R reference
> rref <- bibentry(
+    bibtype = "Manual",
+    title = "R: A Language and Environment for Statistical Computing",
+    author = person("R Core Team"),
+    organization = "R Foundation for Statistical Computing",
+    address = "Vienna, Austria",
+    year = 2014,
+    url = "https://www.R-project.org/")
> 
> ## Different printing styles
> print(rref)
R Core Team (2014). _R: A Language and Environment for Statistical
Computing_. R Foundation for Statistical Computing, Vienna, Austria.
<URL: https://www.R-project.org/>.
> print(rref, style = "Bibtex")
@Manual{,
  title = {R: A Language and Environment for Statistical Computing},
  author = {{R Core Team}},
  organization = {R Foundation for Statistical Computing},
  address = {Vienna, Austria},
  year = {2014},
  url = {https://www.R-project.org/},
}
> print(rref, style = "citation")

R Core Team (2014). _R: A Language and Environment for Statistical
Computing_. R Foundation for Statistical Computing, Vienna, Austria.
<URL: https://www.R-project.org/>.

A BibTeX entry for LaTeX users is

  @Manual{,
    title = {R: A Language and Environment for Statistical Computing},
    author = {{R Core Team}},
    organization = {R Foundation for Statistical Computing},
    address = {Vienna, Austria},
    year = {2014},
    url = {https://www.R-project.org/},
  }

> print(rref, style = "html")
<p>R Core Team (2014).
<em>R: A Language and Environment for Statistical Computing</em>.
R Foundation for Statistical Computing, Vienna, Austria.
<a href="https://www.R-project.org/">https://www.R-project.org/</a>. 
</p>
> print(rref, style = "latex")
R Core Team (2014).
\emph{R: A Language and Environment for Statistical Computing}.
R Foundation for Statistical Computing, Vienna, Austria.
\url{https://www.R-project.org/}.
> print(rref, style = "R")
bibentry(bibtype = "Manual",
         title = "R: A Language and Environment for Statistical Computing",
         author = person(given = "R Core Team"),
         organization = "R Foundation for Statistical Computing",
         address = "Vienna, Austria",
         year = "2014",
         url = "https://www.R-project.org/")
> 
> ## References for boot package and associated book
> bref <- c(
+    bibentry(
+      bibtype = "Manual",
+      title = "boot: Bootstrap R (S-PLUS) Functions",
+      author = c(
+        person("Angelo", "Canty", role = "aut",
+          comment = "S original"),
+        person(c("Brian", "D."), "Ripley", role = c("aut", "trl", "cre"),
+          comment = "R port, author of parallel support",
+          email = "ripley@stats.ox.ac.uk")
+      ),
+      year = "2012",
+      note = "R package version 1.3-4",
+      url = "https://CRAN.R-project.org/package=boot",
+      key = "boot-package"
+    ),
+ 
+    bibentry(
+      bibtype = "Book",
+      title = "Bootstrap Methods and Their Applications",
+      author = as.person("Anthony C. Davison [aut], David V. Hinkley [aut]"),
+      year = "1997",
+      publisher = "Cambridge University Press",
+      address = "Cambridge",
+      isbn = "0-521-57391-2",
+      url = "http://statwww.epfl.ch/davison/BMA/",
+      key = "boot-book"
+    )
+ )
> 
> ## Combining and subsetting
> c(rref, bref)
R Core Team (2014). _R: A Language and Environment for Statistical
Computing_. R Foundation for Statistical Computing, Vienna, Austria.
<URL: https://www.R-project.org/>.

Canty A, Ripley BD (2012). _boot: Bootstrap R (S-PLUS) Functions_. R
package version 1.3-4, <URL: https://CRAN.R-project.org/package=boot>.

Davison AC, Hinkley DV (1997). _Bootstrap Methods and Their
Applications_. Cambridge University Press, Cambridge. ISBN
0-521-57391-2, <URL: http://statwww.epfl.ch/davison/BMA/>.
> bref[2]
Davison AC, Hinkley DV (1997). _Bootstrap Methods and Their
Applications_. Cambridge University Press, Cambridge. ISBN
0-521-57391-2, <URL: http://statwww.epfl.ch/davison/BMA/>.
> bref["boot-book"]
Davison AC, Hinkley DV (1997). _Bootstrap Methods and Their
Applications_. Cambridge University Press, Cambridge. ISBN
0-521-57391-2, <URL: http://statwww.epfl.ch/davison/BMA/>.
> 
> ## Extracting fields
> bref$author
[[1]]
[1] "Angelo Canty [aut] (S original)"                                                             
[2] "Brian D. Ripley <ripley@stats.ox.ac.uk> [aut, trl, cre] (R port, author of parallel support)"

[[2]]
[1] "Anthony C. Davison [aut]" "David V. Hinkley [aut]"  

> bref[1]$author
[1] "Angelo Canty [aut] (S original)"                                                             
[2] "Brian D. Ripley <ripley@stats.ox.ac.uk> [aut, trl, cre] (R port, author of parallel support)"
> bref[1]$author[2]$email
[1] "ripley@stats.ox.ac.uk"
> 
> ## Convert to BibTeX
> toBibtex(bref)
@Manual{boot-package,
  title = {boot: Bootstrap R (S-PLUS) Functions},
  author = {Angelo Canty and Brian D. Ripley},
  year = {2012},
  note = {R package version 1.3-4},
  url = {https://CRAN.R-project.org/package=boot},
}

@Book{boot-book,
  title = {Bootstrap Methods and Their Applications},
  author = {Anthony C. Davison and David V. Hinkley},
  year = {1997},
  publisher = {Cambridge University Press},
  address = {Cambridge},
  isbn = {0-521-57391-2},
  url = {http://statwww.epfl.ch/davison/BMA/},
}
> 
> ## Format in R style
> ## One bibentry() call for each bibentry:
> writeLines(paste(format(bref, "R"), collapse = "\n\n"))
bibentry(bibtype = "Manual",
         key = "boot-package",
         title = "boot: Bootstrap R (S-PLUS) Functions",
         author = c(person(given = "Angelo",
                           family = "Canty",
                           role = "aut",
                           comment = "S original"),
                    person(given = c("Brian", "D."),
                           family = "Ripley",
                           role = c("aut", "trl", "cre"),
                           email = "ripley@stats.ox.ac.uk",
                           comment = "R port, author of parallel support")),
         year = "2012",
         note = "R package version 1.3-4",
         url = "https://CRAN.R-project.org/package=boot")

bibentry(bibtype = "Book",
         key = "boot-book",
         title = "Bootstrap Methods and Their Applications",
         author = c(person(given = c("Anthony", "C."),
                           family = "Davison",
                           role = "aut"),
                    person(given = c("David", "V."),
                           family = "Hinkley",
                           role = "aut")),
         year = "1997",
         publisher = "Cambridge University Press",
         address = "Cambridge",
         isbn = "0-521-57391-2",
         url = "http://statwww.epfl.ch/davison/BMA/")
> ## One collapsed call:
> writeLines(format(bref, "R", collapse = TRUE))
c(bibentry(bibtype = "Manual",
           key = "boot-package",
           title = "boot: Bootstrap R (S-PLUS) Functions",
           author = c(person(given = "Angelo",
                             family = "Canty",
                             role = "aut",
                             comment = "S original"),
                      person(given = c("Brian", "D."),
                             family = "Ripley",
                             role = c("aut", "trl", "cre"),
                             email = "ripley@stats.ox.ac.uk",
                             comment = "R port, author of parallel support")),
           year = "2012",
           note = "R package version 1.3-4",
           url = "https://CRAN.R-project.org/package=boot"),
  bibentry(bibtype = "Book",
           key = "boot-book",
           title = "Bootstrap Methods and Their Applications",
           author = c(person(given = c("Anthony", "C."),
                             family = "Davison",
                             role = "aut"),
                      person(given = c("David", "V."),
                             family = "Hinkley",
                             role = "aut")),
           year = "1997",
           publisher = "Cambridge University Press",
           address = "Cambridge",
           isbn = "0-521-57391-2",
           url = "http://statwww.epfl.ch/davison/BMA/"))
> 
> 
> 
> cleanEx()
> nameEx("browseEnv")
> ### * browseEnv
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: browseEnv
> ### Title: Browse Objects in Environment
> ### Aliases: browseEnv wsbrowser
> ### Keywords: interface
> 
> ### ** Examples
> 
> if(interactive()) {
+    ## create some interesting objects :
+    ofa <- ordered(4:1)
+    ex1 <- expression(1+ 0:9)
+    ex3 <- expression(u, v, 1+ 0:9)
+    example(factor, echo = FALSE)
+    example(table, echo = FALSE)
+    example(ftable, echo = FALSE)
+    example(lm, echo = FALSE, ask = FALSE)
+    example(str, echo = FALSE)
+ 
+    ## and browse them:
+    browseEnv()
+ 
+    ## a (simple) function's environment:
+    af12 <- approxfun(1:2, 1:2, method = "const")
+    browseEnv(envir = environment(af12))
+  }
> 
> 
> 
> cleanEx()
> nameEx("browseURL")
> ### * browseURL
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: browseURL
> ### Title: Load URL into an HTML Browser
> ### Aliases: browseURL
> ### Keywords: file
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ## for KDE users who want to open files in a new tab
> ##D options(browser = "kfmclient newTab")
> ##D 
> ##D browseURL("https://www.r-project.org")
> ##D 
> ##D ## On Windows-only, something like
> ##D browseURL("file://d:/R/R-2.5.1/doc/html/index.html",
> ##D           browser = "C:/Program Files/Mozilla Firefox/firefox.exe")
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("browseVignettes")
> ### * browseVignettes
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: browseVignettes
> ### Title: List Vignettes in an HTML Browser
> ### Aliases: browseVignettes print.browseVignettes
> ### Keywords: documentation
> 
> ### ** Examples
> 
> 
> cleanEx()
> nameEx("capture.output")
> ### * capture.output
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: capture.output
> ### Title: Send Output to a Character String or File
> ### Aliases: capture.output
> ### Keywords: utilities
> 
> ### ** Examples
> 
> require(stats)
> glmout <- capture.output(summary(glm(case ~ spontaneous+induced,
+                                      data = infert, family = binomial())))
> glmout[1:5]
[1] ""                                                                 
[2] "Call:"                                                            
[3] "glm(formula = case ~ spontaneous + induced, family = binomial(), "
[4] "    data = infert)"                                               
[5] ""                                                                 
> capture.output(1+1, 2+2)
[1] "[1] 2" "[1] 4"
> capture.output({1+1; 2+2})
[1] "[1] 4"
> 
> ## Not run: 
> ##D ## on Unix-alike with a2ps available##D 
> ##D op <- options(useFancyQuotes=FALSE)
> ##D pdf <- pipe("a2ps -o - | ps2pdf - tempout.pdf", "w")
> ##D capture.output(example(glm), file = pdf)
> ##D close(pdf); options(op) ; system("evince tempout.pdf &")
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("changedFiles")
> ### * changedFiles
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: changedFiles
> ### Title: Detect which Files Have Changed
> ### Aliases: fileSnapshot changedFiles print.changedFiles
> ###   print.fileSnapshot
> ### Keywords: utilities file
> 
> ### ** Examples
> 
> # Create some files in a temporary directory
> dir <- tempfile()
> dir.create(dir)
> writeBin(1L, file.path(dir, "file1"))
> writeBin(2L, file.path(dir, "file2"))
> dir.create(file.path(dir, "dir"))
> 
> # Take a snapshot
> snapshot <- fileSnapshot(dir, timestamp = tempfile("timestamp"), md5sum=TRUE)
> 
> # Change one of the files.
> writeBin(3L:4L, file.path(dir, "file2"))
> 
> # Display the detected changes.  We may or may not see mtime change...
> changedFiles(snapshot)
File changes:
      size md5sum
file2 TRUE   TRUE
> changedFiles(snapshot)$changes
       size isdir  mode mtime Newer md5sum
dir   FALSE FALSE FALSE FALSE FALSE     NA
file1 FALSE FALSE FALSE FALSE FALSE  FALSE
file2  TRUE FALSE FALSE FALSE FALSE   TRUE
> 
> 
> 
> cleanEx()
> nameEx("choose.dir")
> ### * choose.dir
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: choose.dir
> ### Title: Choose a Folder Interactively on MS Windows
> ### Aliases: choose.dir
> ### Keywords: file
> 
> ### ** Examples
> 
>   if (interactive() && .Platform$OS.type == "windows")
+         choose.dir(getwd(), "Choose a suitable folder")
> 
> 
> 
> cleanEx()
> nameEx("choose.files")
> ### * choose.files
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: choose.files
> ### Title: Choose a List of Files Interactively on MS Windows
> ### Aliases: choose.files Filters
> ### Keywords: file
> 
> ### ** Examples
> 
>   if (interactive() && .Platform$OS.type == "windows")
+        choose.files(filters = Filters[c("zip", "All"),])
> 
> 
> 
> cleanEx()
> nameEx("citation")
> ### * citation
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: citation
> ### Title: Citing R and R Packages in Publications
> ### Aliases: CITATION citation readCitationFile
> ### Keywords: misc
> 
> ### ** Examples
> 
> ## the basic R reference
> citation()

To cite R in publications use:

  R Core Team (2020). R: A language and environment for statistical
  computing. R Foundation for Statistical Computing, Vienna, Austria.
  URL https://www.R-project.org/.

A BibTeX entry for LaTeX users is

  @Manual{,
    title = {R: A Language and Environment for Statistical Computing},
    author = {{R Core Team}},
    organization = {R Foundation for Statistical Computing},
    address = {Vienna, Austria},
    year = {2020},
    url = {https://www.R-project.org/},
  }

We have invested a lot of time and effort in creating R, please cite it
when using it for data analysis. See also ‘citation("pkgname")’ for
citing R packages.

> 
> ## references for a package -- might not have these installed
> if(nchar(system.file(package = "lattice"))) citation("lattice")

To cite the lattice package in publications use:

  Sarkar, Deepayan (2008) Lattice: Multivariate Data Visualization with
  R. Springer, New York. ISBN 978-0-387-75968-5

A BibTeX entry for LaTeX users is

  @Book{,
    title = {Lattice: Multivariate Data Visualization with R},
    author = {Deepayan Sarkar},
    publisher = {Springer},
    address = {New York},
    year = {2008},
    note = {ISBN 978-0-387-75968-5},
    url = {http://lmdvr.r-forge.r-project.org},
  }

> if(nchar(system.file(package = "foreign"))) citation("foreign")

To cite package ‘foreign’ in publications use:

  R Core Team (2020). foreign: Read Data Stored by 'Minitab', 'S',
  'SAS', 'SPSS', 'Stata', 'Systat', 'Weka', 'dBase', .... R package
  version 0.8-80. https://CRAN.R-project.org/package=foreign

A BibTeX entry for LaTeX users is

  @Manual{,
    title = {foreign: Read Data Stored by 'Minitab', 'S', 'SAS', 'SPSS', 'Stata',
'Systat', 'Weka', 'dBase', ...},
    author = {{R Core Team}},
    year = {2020},
    note = {R package version 0.8-80},
    url = {https://CRAN.R-project.org/package=foreign},
  }

> 
> ## extract the bibtex entry from the return value
> x <- citation()
> toBibtex(x)
@Manual{,
  title = {R: A Language and Environment for Statistical Computing},
  author = {{R Core Team}},
  organization = {R Foundation for Statistical Computing},
  address = {Vienna, Austria},
  year = {2020},
  url = {https://www.R-project.org/},
}
> 
> 
> 
> 
> cleanEx()
> nameEx("cite")
> ### * cite
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cite
> ### Title: Cite a Bibliography Entry
> ### Aliases: cite citeNatbib
> ### Keywords: utilities documentation
> 
> ### ** Examples
> 
> ## R reference
> rref <- bibentry(
+    bibtype = "Manual",
+    title = "R: A Language and Environment for Statistical Computing",
+    author = person("R Core Team"),
+    organization = "R Foundation for Statistical Computing",
+    address = "Vienna, Austria",
+    year = 2013,
+    url = "https://www.R-project.org/",
+    key = "R")
> 
> ## References for boot package and associated book
> bref <- c(
+    bibentry(
+      bibtype = "Manual",
+      title = "boot: Bootstrap R (S-PLUS) Functions",
+      author = c(
+        person("Angelo", "Canty", role = "aut",
+          comment = "S original"),
+        person(c("Brian", "D."), "Ripley", role = c("aut", "trl", "cre"),
+          comment = "R port, author of parallel support",
+          email = "ripley@stats.ox.ac.uk")
+      ),
+      year = "2012",
+      note = "R package version 1.3-4",
+      url = "https://CRAN.R-project.org/package=boot",
+      key = "boot-package"
+    ),
+ 
+    bibentry(
+      bibtype = "Book",
+      title = "Bootstrap Methods and Their Applications",
+      author = as.person("Anthony C. Davison [aut], David V. Hinkley [aut]"),
+      year = "1997",
+      publisher = "Cambridge University Press",
+      address = "Cambridge",
+      isbn = "0-521-57391-2",
+      url = "http://statwww.epfl.ch/davison/BMA/",
+      key = "boot-book"
+    )
+ )
> 
> ## Combine and cite
> refs <- c(rref, bref)
> cite("R, boot-package", refs)
[1] "(R Core Team 2013; Canty and Ripley 2012)"
> 
> ## Cite numerically
> savestyle <- tools::getBibstyle()
> tools::bibstyle("JSSnumbered", .init = TRUE,
+          fmtPrefix = function(paper) paste0("[", paper$.index, "]"),
+          cite = function(key, bib, ...)
+          	citeNatbib(key, bib, mode = "numbers",
+          	    bibpunct = c("[", "]", ";", "n", "", ","), ...)
+          )
<environment: 0x564a714c3470>
> cite("R, boot-package", refs, textual = TRUE)
[1] "R Core Team [3]; Canty and Ripley [1]"
> refs
[1] R Core Team (2013). _R: A Language and Environment for Statistical
Computing_. R Foundation for Statistical Computing, Vienna, Austria.
<URL: https://www.R-project.org/>.

[2] Canty A, Ripley BD (2012). _boot: Bootstrap R (S-PLUS) Functions_.
R package version 1.3-4, <URL:
https://CRAN.R-project.org/package=boot>.

[3] Davison AC, Hinkley DV (1997). _Bootstrap Methods and Their
Applications_. Cambridge University Press, Cambridge. ISBN
0-521-57391-2, <URL: http://statwww.epfl.ch/davison/BMA/>.
> 
> ## restore the old style
> tools::bibstyle(savestyle, .default = TRUE)
<environment: 0x564a72830e08>
> 
> 
> 
> cleanEx()
> nameEx("combn")
> ### * combn
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: combn
> ### Title: Generate All Combinations of n Elements, Taken m at a Time
> ### Aliases: combn
> ### Keywords: utilities iteration
> 
> ### ** Examples
> 
> combn(letters[1:4], 2)
     [,1] [,2] [,3] [,4] [,5] [,6]
[1,] "a"  "a"  "a"  "b"  "b"  "c" 
[2,] "b"  "c"  "d"  "c"  "d"  "d" 
> (m <- combn(10, 5, min))   # minimum value in each combination
  [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
 [38] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
 [75] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
[112] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
[149] 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
[186] 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
[223] 3 3 3 3 3 3 3 3 3 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 5 5 5 5 5 6
> mm <- combn(15, 6, function(x) matrix(x, 2, 3))
> stopifnot(round(choose(10, 5)) == length(m),
+           c(2,3, round(choose(15, 6))) == dim(mm))
> 
> ## Different way of encoding points:
> combn(c(1,1,1,1,2,2,2,3,3,4), 3, tabulate, nbins = 4)
     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] [,14]
[1,]    3    3    2    2    2    2    2    2    3     2     2     2     2     2
[2,]    0    0    1    1    1    0    0    0    0     1     1     1     0     0
[3,]    0    0    0    0    0    1    1    0    0     0     0     0     1     1
[4,]    0    0    0    0    0    0    0    1    0     0     0     0     0     0
     [,15] [,16] [,17] [,18] [,19] [,20] [,21] [,22] [,23] [,24] [,25] [,26]
[1,]     2     2     2     2     2     2     2     1     1     1     1     1
[2,]     0     1     1     1     0     0     0     2     2     1     1     1
[3,]     0     0     0     0     1     1     0     0     0     1     1     0
[4,]     1     0     0     0     0     0     1     0     0     0     0     1
     [,27] [,28] [,29] [,30] [,31] [,32] [,33] [,34] [,35] [,36] [,37] [,38]
[1,]     1     1     1     1     1     1     1     1     1     1     3     2
[2,]     2     1     1     1     1     1     1     0     0     0     0     1
[3,]     0     1     1     0     1     1     0     2     1     1     0     0
[4,]     0     0     0     1     0     0     1     0     1     1     0     0
     [,39] [,40] [,41] [,42] [,43] [,44] [,45] [,46] [,47] [,48] [,49] [,50]
[1,]     2     2     2     2     2     2     2     2     2     2     2     1
[2,]     1     1     0     0     0     1     1     1     0     0     0     2
[3,]     0     0     1     1     0     0     0     0     1     1     0     0
[4,]     0     0     0     0     1     0     0     0     0     0     1     0
     [,51] [,52] [,53] [,54] [,55] [,56] [,57] [,58] [,59] [,60] [,61] [,62]
[1,]     1     1     1     1     1     1     1     1     1     1     1     1
[2,]     2     1     1     1     2     1     1     1     1     1     1     0
[3,]     0     1     1     0     0     1     1     0     1     1     0     2
[4,]     0     0     0     1     0     0     0     1     0     0     1     0
     [,63] [,64] [,65] [,66] [,67] [,68] [,69] [,70] [,71] [,72] [,73] [,74]
[1,]     1     1     2     2     2     2     2     2     1     1     1     1
[2,]     0     0     1     1     1     0     0     0     2     2     1     1
[3,]     1     1     0     0     0     1     1     0     0     0     1     1
[4,]     1     1     0     0     0     0     0     1     0     0     0     0
     [,75] [,76] [,77] [,78] [,79] [,80] [,81] [,82] [,83] [,84] [,85] [,86]
[1,]     1     1     1     1     1     1     1     1     1     1     1     1
[2,]     1     2     1     1     1     1     1     1     0     0     0     2
[3,]     0     0     1     1     0     1     1     0     2     1     1     0
[4,]     1     0     0     0     1     0     0     1     0     1     1     0
     [,87] [,88] [,89] [,90] [,91] [,92] [,93] [,94] [,95] [,96] [,97] [,98]
[1,]     1     1     1     1     1     1     1     1     1     1     1     1
[2,]     2     1     1     1     2     1     1     1     1     1     1     0
[3,]     0     1     1     0     0     1     1     0     1     1     0     2
[4,]     0     0     0     1     0     0     0     1     0     0     1     0
     [,99] [,100] [,101] [,102] [,103] [,104] [,105] [,106] [,107] [,108]
[1,]     1      1      0      0      0      0      0      0      0      0
[2,]     0      0      3      2      2      2      2      2      2      1
[3,]     1      1      0      1      1      0      1      1      0      2
[4,]     1      1      0      0      0      1      0      0      1      0
     [,109] [,110] [,111] [,112] [,113] [,114] [,115] [,116] [,117] [,118]
[1,]      0      0      0      0      0      0      0      0      0      0
[2,]      1      1      2      2      2      1      1      1      1      1
[3,]      1      1      1      1      0      2      1      1      2      1
[4,]      1      1      0      0      1      0      1      1      0      1
     [,119] [,120]
[1,]      0      0
[2,]      1      0
[3,]      1      2
[4,]      1      1
> 
> ## Compute support points and (scaled) probabilities for a
> ## Multivariate-Hypergeometric(n = 3, N = c(4,3,2,1)) p.f.:
> # table.mat(t(combn(c(1,1,1,1,2,2,2,3,3,4), 3, tabulate, nbins = 4)))
> 
> ## Assuring the identity
> for(n in 1:7)
+  for(m in 0:n) stopifnot(is.array(cc <- combn(n, m)),
+                          dim(cc) == c(m, choose(n, m)))
> 
> 
> 
> cleanEx()
> nameEx("compareVersion")
> ### * compareVersion
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: compareVersion
> ### Title: Compare Two Package Version Numbers
> ### Aliases: compareVersion
> ### Keywords: utilities
> 
> ### ** Examples
> 
> compareVersion("1.0", "1.0-1")
[1] -1
> compareVersion("7.2-0","7.1-12")
[1] 1
> 
> 
> 
> cleanEx()
> nameEx("count.fields")
> ### * count.fields
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: count.fields
> ### Title: Count the Number of Fields per Line
> ### Aliases: count.fields
> ### Keywords: file
> 
> ### ** Examples
> 
> fil <- tempfile()
> cat("NAME", "1:John", "2:Paul", file = fil, sep = "\n")
> count.fields(fil, sep = ":")
[1] 1 2 2
> unlink(fil)
> 
> 
> 
> cleanEx()
> nameEx("data")
> ### * data
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: data
> ### Title: Data Sets
> ### Aliases: data print.packageIQR
> ### Keywords: documentation datasets
> 
> ### ** Examples
> 
> require(utils)
> data()                         # list all available data sets
Data sets in package ‘datasets’:

AirPassengers           Monthly Airline Passenger Numbers 1949-1960
BJsales                 Sales Data with Leading Indicator
BJsales.lead (BJsales)
                        Sales Data with Leading Indicator
BOD                     Biochemical Oxygen Demand
CO2                     Carbon Dioxide Uptake in Grass Plants
ChickWeight             Weight versus age of chicks on different diets
DNase                   Elisa assay of DNase
EuStockMarkets          Daily Closing Prices of Major European Stock
                        Indices, 1991-1998
Formaldehyde            Determination of Formaldehyde
HairEyeColor            Hair and Eye Color of Statistics Students
Harman23.cor            Harman Example 2.3
Harman74.cor            Harman Example 7.4
Indometh                Pharmacokinetics of Indomethacin
InsectSprays            Effectiveness of Insect Sprays
JohnsonJohnson          Quarterly Earnings per Johnson & Johnson Share
LakeHuron               Level of Lake Huron 1875-1972
LifeCycleSavings        Intercountry Life-Cycle Savings Data
Loblolly                Growth of Loblolly pine trees
Nile                    Flow of the River Nile
Orange                  Growth of Orange Trees
OrchardSprays           Potency of Orchard Sprays
PlantGrowth             Results from an Experiment on Plant Growth
Puromycin               Reaction Velocity of an Enzymatic Reaction
Seatbelts               Road Casualties in Great Britain 1969-84
Theoph                  Pharmacokinetics of Theophylline
Titanic                 Survival of passengers on the Titanic
ToothGrowth             The Effect of Vitamin C on Tooth Growth in
                        Guinea Pigs
UCBAdmissions           Student Admissions at UC Berkeley
UKDriverDeaths          Road Casualties in Great Britain 1969-84
UKgas                   UK Quarterly Gas Consumption
USAccDeaths             Accidental Deaths in the US 1973-1978
USArrests               Violent Crime Rates by US State
USJudgeRatings          Lawyers' Ratings of State Judges in the US
                        Superior Court
USPersonalExpenditure   Personal Expenditure Data
UScitiesD               Distances Between European Cities and Between
                        US Cities
VADeaths                Death Rates in Virginia (1940)
WWWusage                Internet Usage per Minute
WorldPhones             The World's Telephones
ability.cov             Ability and Intelligence Tests
airmiles                Passenger Miles on Commercial US Airlines,
                        1937-1960
airquality              New York Air Quality Measurements
anscombe                Anscombe's Quartet of 'Identical' Simple Linear
                        Regressions
attenu                  The Joyner-Boore Attenuation Data
attitude                The Chatterjee-Price Attitude Data
austres                 Quarterly Time Series of the Number of
                        Australian Residents
beaver1 (beavers)       Body Temperature Series of Two Beavers
beaver2 (beavers)       Body Temperature Series of Two Beavers
cars                    Speed and Stopping Distances of Cars
chickwts                Chicken Weights by Feed Type
co2                     Mauna Loa Atmospheric CO2 Concentration
crimtab                 Student's 3000 Criminals Data
discoveries             Yearly Numbers of Important Discoveries
esoph                   Smoking, Alcohol and (O)esophageal Cancer
euro                    Conversion Rates of Euro Currencies
euro.cross (euro)       Conversion Rates of Euro Currencies
eurodist                Distances Between European Cities and Between
                        US Cities
faithful                Old Faithful Geyser Data
fdeaths (UKLungDeaths)
                        Monthly Deaths from Lung Diseases in the UK
freeny                  Freeny's Revenue Data
freeny.x (freeny)       Freeny's Revenue Data
freeny.y (freeny)       Freeny's Revenue Data
infert                  Infertility after Spontaneous and Induced
                        Abortion
iris                    Edgar Anderson's Iris Data
iris3                   Edgar Anderson's Iris Data
islands                 Areas of the World's Major Landmasses
ldeaths (UKLungDeaths)
                        Monthly Deaths from Lung Diseases in the UK
lh                      Luteinizing Hormone in Blood Samples
longley                 Longley's Economic Regression Data
lynx                    Annual Canadian Lynx trappings 1821-1934
mdeaths (UKLungDeaths)
                        Monthly Deaths from Lung Diseases in the UK
morley                  Michelson Speed of Light Data
mtcars                  Motor Trend Car Road Tests
nhtemp                  Average Yearly Temperatures in New Haven
nottem                  Average Monthly Temperatures at Nottingham,
                        1920-1939
npk                     Classical N, P, K Factorial Experiment
occupationalStatus      Occupational Status of Fathers and their Sons
precip                  Annual Precipitation in US Cities
presidents              Quarterly Approval Ratings of US Presidents
pressure                Vapor Pressure of Mercury as a Function of
                        Temperature
quakes                  Locations of Earthquakes off Fiji
randu                   Random Numbers from Congruential Generator
                        RANDU
rivers                  Lengths of Major North American Rivers
rock                    Measurements on Petroleum Rock Samples
sleep                   Student's Sleep Data
stack.loss (stackloss)
                        Brownlee's Stack Loss Plant Data
stack.x (stackloss)     Brownlee's Stack Loss Plant Data
stackloss               Brownlee's Stack Loss Plant Data
state.abb (state)       US State Facts and Figures
state.area (state)      US State Facts and Figures
state.center (state)    US State Facts and Figures
state.division (state)
                        US State Facts and Figures
state.name (state)      US State Facts and Figures
state.region (state)    US State Facts and Figures
state.x77 (state)       US State Facts and Figures
sunspot.month           Monthly Sunspot Data, from 1749 to "Present"
sunspot.year            Yearly Sunspot Data, 1700-1988
sunspots                Monthly Sunspot Numbers, 1749-1983
swiss                   Swiss Fertility and Socioeconomic Indicators
                        (1888) Data
treering                Yearly Treering Data, -6000-1979
trees                   Diameter, Height and Volume for Black Cherry
                        Trees
uspop                   Populations Recorded by the US Census
volcano                 Topographic Information on Auckland's Maunga
                        Whau Volcano
warpbreaks              The Number of Breaks in Yarn during Weaving
women                   Average Heights and Weights for American Women


Use ‘data(package = .packages(all.available = TRUE))’
to list the data sets in all *available* packages.

> try(data(package = "rpart") )  # list the data sets in the rpart package
Data sets in package ‘rpart’:

car.test.frame          Automobile Data from 'Consumer Reports' 1990
car90                   Automobile Data from 'Consumer Reports' 1990
cu.summary              Automobile Data from 'Consumer Reports' 1990
kyphosis                Data on Children who have had Corrective Spinal
                        Surgery
solder                  Soldering of Components on Printed-Circuit
                        Boards
solder.balance (solder)
                        Soldering of Components on Printed-Circuit
                        Boards
stagec                  Stage C Prostate Cancer

> data(USArrests, "VADeaths")    # load the data sets 'USArrests' and 'VADeaths'
> ## Not run: 
> ##D ## Alternatively
> ##D ds <- c("USArrests", "VADeaths"); data(list = ds)
> ## End(Not run)
> help(USArrests)                # give information on data set 'USArrests'
USArrests               package:datasets               R Documentation

_V_i_o_l_e_n_t _C_r_i_m_e _R_a_t_e_s _b_y _U_S _S_t_a_t_e

_D_e_s_c_r_i_p_t_i_o_n:

     This data set contains statistics, in arrests per 100,000
     residents for assault, murder, and rape in each of the 50 US
     states in 1973.  Also given is the percent of the population
     living in urban areas.

_U_s_a_g_e:

     USArrests
     
_F_o_r_m_a_t:

     A data frame with 50 observations on 4 variables.

       [,1]  Murder    numeric  Murder arrests (per 100,000)  
       [,2]  Assault   numeric  Assault arrests (per 100,000) 
       [,3]  UrbanPop  numeric  Percent urban population      
       [,4]  Rape      numeric  Rape arrests (per 100,000)    
      
_N_o_t_e:

     ‘USArrests’ contains the data as in McNeil's monograph.  For the
     ‘UrbanPop’ percentages, a review of the table (No. 21) in the
     Statistical Abstracts 1975 reveals a transcription error for
     Maryland (and that McNeil used the same “round to even” rule that
     R's ‘round()’ uses), as found by Daniel S Coven (Arizona).

     See the example below on how to correct the error and improve
     accuracy for the ‘<n>.5’ percentages.

_S_o_u_r_c_e:

     World Almanac and Book of facts 1975.  (Crime rates).

     Statistical Abstracts of the United States 1975, p.20, (Urban
     rates), possibly available as <URL:
     https://books.google.ch/books?id=zl9qAAAAMAAJ&pg=PA20>.

_R_e_f_e_r_e_n_c_e_s:

     McNeil, D. R. (1977) _Interactive Data Analysis_.  New York:
     Wiley.

_S_e_e _A_l_s_o:

     The ‘state’ data sets.

_E_x_a_m_p_l_e_s:

     summary(USArrests)
     
     require(graphics)
     pairs(USArrests, panel = panel.smooth, main = "USArrests data")
     
     ## Difference between 'USArrests' and its correction
     USArrests["Maryland", "UrbanPop"] # 67 -- the transcription error
     UA.C <- USArrests
     UA.C["Maryland", "UrbanPop"] <- 76.6
     
     ## also +/- 0.5 to restore the original  <n>.5  percentages
     s5u <- c("Colorado", "Florida", "Mississippi", "Wyoming")
     s5d <- c("Nebraska", "Pennsylvania")
     UA.C[s5u, "UrbanPop"] <- UA.C[s5u, "UrbanPop"] + 0.5
     UA.C[s5d, "UrbanPop"] <- UA.C[s5d, "UrbanPop"] - 0.5
     
     ## ==> UA.C  is now a *C*orrected version of  USArrests
     

> 
> 
> 
> cleanEx()
> nameEx("dataentry")
> ### * dataentry
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dataentry
> ### Title: Spreadsheet Interface for Entering Data
> ### Aliases: data.entry dataentry de de.ncols de.restore de.setup
> ### Keywords: utilities file
> 
> ### ** Examples
> 
> # call data entry with variables x and y
> ## Not run: data.entry(x, y)
> 
> 
> 
> cleanEx()
> nameEx("debugcall")
> ### * debugcall
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: debugcall
> ### Title: Debug a Call
> ### Aliases: debugcall undebugcall
> ### Keywords: programming environment utilities
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ## Evaluate call after setting debugging
> ##D ## 
> ##D f <- factor(1:10)
> ##D res <- eval(debugcall(summary(f))) 
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("debugger")
> ### * debugger
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: debugger
> ### Title: Post-Mortem Debugging
> ### Aliases: debugger dump.frames
> ### Keywords: utilities error
> 
> ### ** Examples
> 
> ## Not run: 
> ##D options(error = quote(dump.frames("testdump", TRUE)))
> ##D 
> ##D f <- function() {
> ##D     g <- function() stop("test dump.frames")
> ##D     g()
> ##D }
> ##D f()   # will generate a dump on file "testdump.rda"
> ##D options(error = NULL)
> ##D 
> ##D ## possibly in another R session
> ##D load("testdump.rda")
> ##D debugger(testdump)
> ##D Available environments had calls:
> ##D 1: f()
> ##D 2: g()
> ##D 3: stop("test dump.frames")
> ##D 
> ##D Enter an environment number, or 0 to exit
> ##D Selection: 1
> ##D Browsing in the environment with call:
> ##D f()
> ##D Called from: debugger.look(ind)
> ##D Browse[1]> ls()
> ##D [1] "g"
> ##D Browse[1]> g
> ##D function() stop("test dump.frames")
> ##D <environment: 759818>
> ##D Browse[1]>
> ##D Available environments had calls:
> ##D 1: f()
> ##D 2: g()
> ##D 3: stop("test dump.frames")
> ##D 
> ##D Enter an environment number, or 0 to exit
> ##D Selection: 0
> ##D 
> ##D ## A possible setting for non-interactive sessions
> ##D options(error = quote({dump.frames(to.file = TRUE); q(status = 1)}))
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("demo")
> ### * demo
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: demo
> ### Title: Demonstrations of R Functionality
> ### Aliases: demo
> ### Keywords: documentation utilities
> 
> ### ** Examples
> 
> demo() # for attached packages
Demos in package ‘base’:

error.catching          More examples on catching and handling errors
is.things               Explore some properties of R objects and
                        is.FOO() functions. Not for newbies!
recursion               Using recursion for adaptive integration
scoping                 An illustration of lexical scoping.

Demos in package ‘graphics’:

Hershey                 Tables of the characters in the Hershey vector
                        fonts
Japanese                Tables of the Japanese characters in the
                        Hershey vector fonts
graphics                A show of some of R's graphics capabilities
image                   The image-like graphics builtins of R
persp                   Extended persp() examples
plotmath                Examples of the use of mathematics annotation

Demos in package ‘grDevices’:

colors                  A show of R's predefined colors()
hclColors               Exploration of hcl() space

Demos in package ‘stats’:

glm.vr                  Some glm() examples from V&R with several
                        predictors
lm.glm                  Some linear and generalized linear modelling
                        examples from `An Introduction to Statistical
                        Modelling' by Annette Dobson
nlm                     Nonlinear least-squares using nlm()
smooth                  `Visualize' steps in Tukey's smoothers


Use ‘demo(package = .packages(all.available = TRUE))’
to list the demos in all *available* packages.

> 
> ## All available demos:
> demo(package = .packages(all.available = TRUE))
Demos in package ‘base’:

error.catching          More examples on catching and handling errors
is.things               Explore some properties of R objects and
                        is.FOO() functions. Not for newbies!
recursion               Using recursion for adaptive integration
scoping                 An illustration of lexical scoping.

Demos in package ‘digest’:

vectorised              Timing comparison of approaches for vectorised
                        digest

Demos in package ‘graphics’:

Hershey                 Tables of the characters in the Hershey vector
                        fonts
Japanese                Tables of the Japanese characters in the
                        Hershey vector fonts
graphics                A show of some of R's graphics capabilities
image                   The image-like graphics builtins of R
persp                   Extended persp() examples
plotmath                Examples of the use of mathematics annotation

Demos in package ‘grDevices’:

colors                  A show of R's predefined colors()
hclColors               Exploration of hcl() space

Demos in package ‘knitr’:

gwidgets                An R Notebook based on gWidgetsWWW2
notebook                An R Notebook based on Shiny

Demos in package ‘lattice’:

intervals               Confidence intervals
labels                  Labels in lattice displays
lattice                 Lattice Demos
panel                   Custom panel functions

Demos in package ‘stats’:

glm.vr                  Some glm() examples from V&R with several
                        predictors
lm.glm                  Some linear and generalized linear modelling
                        examples from `An Introduction to Statistical
                        Modelling' by Annette Dobson
nlm                     Nonlinear least-squares using nlm()
smooth                  `Visualize' steps in Tukey's smoothers

Demos in package ‘tcltk’:

tkcanvas                Creates a canvas widget showing a 2-D plot with
                        data points that can be dragged with the mouse.
tkdensity               Interactive density plots.
tkfaq                   Show long file, the R FAQ, using scrollbared
                        window.
tkttest                 t-test example of GUI interface to a function
                        call.

> 
> 
> ## Not run: 
> ##D  ch <- "scoping"
> ##D  demo(ch, character = TRUE)
> ## End(Not run)
> 
> ## Find the location of a demo
> system.file("demo", "lm.glm.R", package = "stats")
[1] "/usr/local/lib/R/library/stats/demo/lm.glm.R"
> 
> 
> 
> cleanEx()
> nameEx("edit")
> ### * edit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: edit
> ### Title: Invoke a Text Editor
> ### Aliases: edit edit.default vi emacs pico xemacs xedit
> ### Keywords: utilities
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # use xedit on the function mean and assign the changes
> ##D mean <- edit(mean, editor = "xedit")
> ##D 
> ##D # use vi on mean and write the result to file mean.out
> ##D vi(mean, file = "mean.out")
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("edit.data.frame")
> ### * edit.data.frame
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: edit.data.frame
> ### Title: Edit Data Frames and Matrices
> ### Aliases: edit.data.frame edit.matrix
> ### Keywords: utilities
> 
> ### ** Examples
> 
> ## Not run: 
> ##D edit(InsectSprays)
> ##D edit(InsectSprays, factor.mode = "numeric")
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("example")
> ### * example
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: example
> ### Title: Run an Examples Section from the Online Help
> ### Aliases: example
> ### Keywords: documentation utilities
> 
> ### ** Examples
> 
> example(InsectSprays)

InsctS> require(stats); require(graphics)

InsctS> boxplot(count ~ spray, data = InsectSprays,
InsctS+         xlab = "Type of spray", ylab = "Insect count",
InsctS+         main = "InsectSprays data", varwidth = TRUE, col = "lightgray")

InsctS> fm1 <- aov(count ~ spray, data = InsectSprays)

InsctS> summary(fm1)
            Df Sum Sq Mean Sq F value Pr(>F)    
spray        5   2669   533.8    34.7 <2e-16 ***
Residuals   66   1015    15.4                   
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

InsctS> opar <- par(mfrow = c(2, 2), oma = c(0, 0, 1.1, 0))

InsctS> plot(fm1)

InsctS> fm2 <- aov(sqrt(count) ~ spray, data = InsectSprays)

InsctS> summary(fm2)
            Df Sum Sq Mean Sq F value Pr(>F)    
spray        5  88.44  17.688    44.8 <2e-16 ***
Residuals   66  26.06   0.395                   
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

InsctS> plot(fm2)

InsctS> par(opar)
> ## force use of the standard package 'stats':
> example("smooth", package = "stats", lib.loc = .Library)

smooth> require(graphics)

smooth> ## see also   demo(smooth) !
smooth> 
smooth> x1 <- c(4, 1, 3, 6, 6, 4, 1, 6, 2, 4, 2) # very artificial

smooth> (x3R <- smooth(x1, "3R")) # 2 iterations of "3"
3R Tukey smoother resulting from  smooth(x = x1, kind = "3R") 
 used 2 iterations
 [1] 3 3 3 6 6 4 4 4 2 2 2

smooth> smooth(x3R, kind = "S")
S Tukey smoother resulting from  smooth(x = x3R, kind = "S") 
 changed
 [1] 3 3 3 3 4 4 4 4 2 2 2

smooth> sm.3RS <- function(x, ...)
smooth+    smooth(smooth(x, "3R", ...), "S", ...)

smooth> y <- c(1, 1, 19:1)

smooth> plot(y, main = "misbehaviour of \"3RSR\"", col.main = 3)

smooth> lines(sm.3RS(y))

smooth> lines(smooth(y))

smooth> lines(smooth(y, "3RSR"), col = 3, lwd = 2)  # the horror

smooth> x <- c(8:10, 10, 0, 0, 9, 9)

smooth> plot(x, main = "breakdown of  3R  and  S  and hence  3RSS")

smooth> matlines(cbind(smooth(x, "3R"), smooth(x, "S"), smooth(x, "3RSS"), smooth(x)))

smooth> presidents[is.na(presidents)] <- 0 # silly

smooth> summary(sm3 <- smooth(presidents, "3R"))
3R Tukey smoother resulting from
 smooth(x = presidents, kind = "3R") ;  n = 120 
 used 4 iterations
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
    0.0    44.0    57.0    54.2    71.0    82.0 

smooth> summary(sm2 <- smooth(presidents,"3RSS"))
3RSS Tukey smoother resulting from
 smooth(x = presidents, kind = "3RSS") ;  n = 120 
 used 5 iterations
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
   0.00   44.00   57.00   55.45   69.00   82.00 

smooth> summary(sm  <- smooth(presidents))
3RS3R Tukey smoother resulting from
 smooth(x = presidents) ;  n = 120 
 used 7 iterations
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
  24.00   44.00   57.00   55.88   69.00   82.00 

smooth> all.equal(c(sm2), c(smooth(smooth(sm3, "S"), "S")))  # 3RSS  === 3R S S
[1] TRUE

smooth> all.equal(c(sm),  c(smooth(smooth(sm3, "S"), "3R"))) # 3RS3R === 3R S 3R
[1] TRUE

smooth> plot(presidents, main = "smooth(presidents0, *) :  3R and default 3RS3R")

smooth> lines(sm3, col = 3, lwd = 1.5)

smooth> lines(sm, col = 2, lwd = 1.25)
> 
> ## set RNG *before* example as when R CMD check is run:
> 
> r1 <- example(quantile, setRNG = TRUE)

quantl> quantile(x <- rnorm(1001)) # Extremes & Quartiles by default
         0%         25%         50%         75%        100% 
-3.00804860 -0.69731820 -0.03472603  0.68924373  3.81027668 

quantl> quantile(x,  probs = c(0.1, 0.5, 1, 2, 5, 10, 50, NA)/100)
       0.1%        0.5%          1%          2%          5%         10% 
-2.99694930 -2.59232767 -2.42431731 -2.24515257 -1.72663060 -1.33880074 
        50%             
-0.03472603          NA 

quantl> ### Compare different types
quantl> quantAll <- function(x, prob, ...)
quantl+   t(vapply(1:9, function(typ) quantile(x, prob=prob, type = typ, ...),
quantl+            quantile(x, prob, type=1, ...)))

quantl> p <- c(0.1, 0.5, 1, 2, 5, 10, 50)/100

quantl> signif(quantAll(x, p), 4)
        0.1%   0.5%     1%     2%     5%    10%      50%
 [1,] -2.997 -2.592 -2.424 -2.245 -1.727 -1.339 -0.03473
 [2,] -2.997 -2.592 -2.424 -2.245 -1.727 -1.339 -0.03473
 [3,] -3.008 -2.596 -2.433 -2.265 -1.733 -1.344 -0.03592
 [4,] -3.008 -2.596 -2.433 -2.264 -1.733 -1.344 -0.03532
 [5,] -3.002 -2.594 -2.428 -2.255 -1.730 -1.341 -0.03473
 [6,] -3.008 -2.596 -2.432 -2.264 -1.733 -1.343 -0.03473
 [7,] -2.997 -2.592 -2.424 -2.245 -1.727 -1.339 -0.03473
 [8,] -3.004 -2.595 -2.430 -2.258 -1.731 -1.342 -0.03473
 [9,] -3.004 -2.595 -2.429 -2.257 -1.730 -1.341 -0.03473

quantl> ## 0% and 100% are equal to min(), max() for all types:
quantl> stopifnot(t(quantAll(x, prob=0:1)) == range(x))

quantl> ## for complex numbers:
quantl> z <- complex(re=x, im = -10*x)

quantl> signif(quantAll(z, p), 4)
              0.1%         0.5%           1%           2%           5%
 [1,] -3.00+29.97i -2.59+25.92i -2.42+24.24i -2.25+22.45i -1.73+17.27i
 [2,] -3.00+29.97i -2.59+25.92i -2.42+24.24i -2.25+22.45i -1.73+17.27i
 [3,] -3.01+30.08i -2.60+25.96i -2.43+24.33i -2.26+22.65i -1.73+17.33i
 [4,] -3.01+30.08i -2.60+25.96i -2.43+24.33i -2.26+22.64i -1.73+17.33i
 [5,] -3.00+30.02i -2.59+25.94i -2.43+24.28i -2.25+22.55i -1.73+17.30i
 [6,] -3.01+30.08i -2.60+25.96i -2.43+24.32i -2.26+22.64i -1.73+17.33i
 [7,] -3.00+29.97i -2.59+25.92i -2.42+24.24i -2.25+22.45i -1.73+17.27i
 [8,] -3.00+30.04i -2.59+25.95i -2.43+24.30i -2.26+22.58i -1.73+17.31i
 [9,] -3.00+30.04i -2.59+25.95i -2.43+24.29i -2.26+22.57i -1.73+17.30i
               10%             50%
 [1,] -1.34+13.39i -0.0347+0.3473i
 [2,] -1.34+13.39i -0.0347+0.3473i
 [3,] -1.34+13.44i -0.0359+0.3592i
 [4,] -1.34+13.44i -0.0353+0.3532i
 [5,] -1.34+13.41i -0.0347+0.3473i
 [6,] -1.34+13.43i -0.0347+0.3473i
 [7,] -1.34+13.39i -0.0347+0.3473i
 [8,] -1.34+13.42i -0.0347+0.3473i
 [9,] -1.34+13.41i -0.0347+0.3473i
> x1 <- rnorm(1)
> u <- runif(1)
> ## identical random numbers
> r2 <- example(quantile, setRNG = TRUE)

quantl> quantile(x <- rnorm(1001)) # Extremes & Quartiles by default
         0%         25%         50%         75%        100% 
-3.00804860 -0.69731820 -0.03472603  0.68924373  3.81027668 

quantl> quantile(x,  probs = c(0.1, 0.5, 1, 2, 5, 10, 50, NA)/100)
       0.1%        0.5%          1%          2%          5%         10% 
-2.99694930 -2.59232767 -2.42431731 -2.24515257 -1.72663060 -1.33880074 
        50%             
-0.03472603          NA 

quantl> ### Compare different types
quantl> quantAll <- function(x, prob, ...)
quantl+   t(vapply(1:9, function(typ) quantile(x, prob=prob, type = typ, ...),
quantl+            quantile(x, prob, type=1, ...)))

quantl> p <- c(0.1, 0.5, 1, 2, 5, 10, 50)/100

quantl> signif(quantAll(x, p), 4)
        0.1%   0.5%     1%     2%     5%    10%      50%
 [1,] -2.997 -2.592 -2.424 -2.245 -1.727 -1.339 -0.03473
 [2,] -2.997 -2.592 -2.424 -2.245 -1.727 -1.339 -0.03473
 [3,] -3.008 -2.596 -2.433 -2.265 -1.733 -1.344 -0.03592
 [4,] -3.008 -2.596 -2.433 -2.264 -1.733 -1.344 -0.03532
 [5,] -3.002 -2.594 -2.428 -2.255 -1.730 -1.341 -0.03473
 [6,] -3.008 -2.596 -2.432 -2.264 -1.733 -1.343 -0.03473
 [7,] -2.997 -2.592 -2.424 -2.245 -1.727 -1.339 -0.03473
 [8,] -3.004 -2.595 -2.430 -2.258 -1.731 -1.342 -0.03473
 [9,] -3.004 -2.595 -2.429 -2.257 -1.730 -1.341 -0.03473

quantl> ## 0% and 100% are equal to min(), max() for all types:
quantl> stopifnot(t(quantAll(x, prob=0:1)) == range(x))

quantl> ## for complex numbers:
quantl> z <- complex(re=x, im = -10*x)

quantl> signif(quantAll(z, p), 4)
              0.1%         0.5%           1%           2%           5%
 [1,] -3.00+29.97i -2.59+25.92i -2.42+24.24i -2.25+22.45i -1.73+17.27i
 [2,] -3.00+29.97i -2.59+25.92i -2.42+24.24i -2.25+22.45i -1.73+17.27i
 [3,] -3.01+30.08i -2.60+25.96i -2.43+24.33i -2.26+22.65i -1.73+17.33i
 [4,] -3.01+30.08i -2.60+25.96i -2.43+24.33i -2.26+22.64i -1.73+17.33i
 [5,] -3.00+30.02i -2.59+25.94i -2.43+24.28i -2.25+22.55i -1.73+17.30i
 [6,] -3.01+30.08i -2.60+25.96i -2.43+24.32i -2.26+22.64i -1.73+17.33i
 [7,] -3.00+29.97i -2.59+25.92i -2.42+24.24i -2.25+22.45i -1.73+17.27i
 [8,] -3.00+30.04i -2.59+25.95i -2.43+24.30i -2.26+22.58i -1.73+17.31i
 [9,] -3.00+30.04i -2.59+25.95i -2.43+24.29i -2.26+22.57i -1.73+17.30i
               10%             50%
 [1,] -1.34+13.39i -0.0347+0.3473i
 [2,] -1.34+13.39i -0.0347+0.3473i
 [3,] -1.34+13.44i -0.0359+0.3592i
 [4,] -1.34+13.44i -0.0353+0.3532i
 [5,] -1.34+13.41i -0.0347+0.3473i
 [6,] -1.34+13.43i -0.0347+0.3473i
 [7,] -1.34+13.39i -0.0347+0.3473i
 [8,] -1.34+13.42i -0.0347+0.3473i
 [9,] -1.34+13.41i -0.0347+0.3473i
> x2 <- rnorm(1)
> stopifnot(identical(r1, r2))
> ## but x1 and x2 differ since the RNG state from before example()
> ## differs and is restored!
> x1; x2
[1] -0.6264538
[1] 1.329799
> 
> ## Exploring examples code:
> ## How large are the examples of "lm...()" functions?
> lmex <- sapply(apropos("^lm", mode = "function"),
+                example, character.only = TRUE, give.lines = TRUE)
> sapply(lmex, length)
          lm       lm.fit lm.influence      lm.wfit 
          33           37           18           37 
> 
> 
> 
> cleanEx()
> nameEx("file.edit")
> ### * file.edit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: file.edit
> ### Title: Edit One or More Files
> ### Aliases: file.edit
> ### Keywords: utilities
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # open two R scripts for editing
> ##D file.edit("script1.R", "script2.R")
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("filetest")
> ### * filetest
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: file_test
> ### Title: Shell-style Tests on Files
> ### Aliases: file_test
> ### Keywords: file
> 
> ### ** Examples
> 
> dir <- file.path(R.home(), "library", "stats")
> file_test("-d", dir)
[1] TRUE
> file_test("-nt", file.path(dir, "R"), file.path(dir, "demo"))
[1] FALSE
> 
> 
> 
> cleanEx()
> nameEx("findLineNum")
> ### * findLineNum
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: findLineNum
> ### Title: Find the Location of a Line of Source Code, or Set a Breakpoint
> ###   There
> ### Aliases: findLineNum setBreakpoint
> ### Keywords: debugging
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # Find what function was defined in the file mysource.R at line 100:
> ##D findLineNum("mysource.R#100")
> ##D 
> ##D # Set a breakpoint in both copies of that function, assuming one is in the
> ##D # same namespace as myfunction and the other is on the search path
> ##D setBreakpoint("mysource.R#100", envir = myfunction)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("fix")
> ### * fix
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fix
> ### Title: Fix an Object
> ### Aliases: fix
> ### Keywords: utilities
> 
> ### ** Examples
> 
> ## Not run: 
> ##D  ## Assume 'my.fun' is a user defined function :
> ##D  fix(my.fun)
> ##D  ## now my.fun is changed
> ##D  ## Also,
> ##D  fix(my.data.frame) # calls up data editor
> ##D  fix(my.data.frame, factor.mode="char") # use of ...
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("format")
> ### * format
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: format
> ### Title: Format Unordered and Ordered Lists
> ### Aliases: formatUL formatOL
> ### Keywords: print
> 
> ### ** Examples
> 
> ## A simpler recipe.
> x <- c("Mix dry ingredients thoroughly.",
+        "Pour in wet ingredients.",
+        "Mix for 10 minutes.",
+        "Bake for one hour at 300 degrees.")
> ## Format and output as an unordered list.
> writeLines(formatUL(x))
* Mix dry ingredients thoroughly.
* Pour in wet ingredients.
* Mix for 10 minutes.
* Bake for one hour at 300 degrees.
> ## Format and output as an ordered list.
> writeLines(formatOL(x))
1. Mix dry ingredients thoroughly.
2. Pour in wet ingredients.
3. Mix for 10 minutes.
4. Bake for one hour at 300 degrees.
> ## Ordered list using lower case roman numerals.
> writeLines(formatOL(x, type = "i"))
  i. Mix dry ingredients thoroughly.
 ii. Pour in wet ingredients.
iii. Mix for 10 minutes.
 iv. Bake for one hour at 300 degrees.
> ## Ordered list using upper case letters and some offset.
> writeLines(formatOL(x, type = "A", offset = 5))
     A. Mix dry ingredients thoroughly.
     B. Pour in wet ingredients.
     C. Mix for 10 minutes.
     D. Bake for one hour at 300 degrees.
> 
> 
> 
> cleanEx()
> nameEx("getAnywhere")
> ### * getAnywhere
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: getAnywhere
> ### Title: Retrieve an R Object, Including from a Namespace
> ### Aliases: getAnywhere argsAnywhere [.getAnywhere print.getAnywhere
> ### Keywords: data
> 
> ### ** Examples
> 
> getAnywhere("format.dist")
A single object matching ‘format.dist’ was found
It was found in the following places
  registered S3 method for format from namespace stats
  namespace:stats
with value

function (x, ...) 
format(as.vector(x), ...)
<bytecode: 0x564a74535390>
<environment: namespace:stats>
> getAnywhere("simpleLoess") # not exported from stats
A single object matching ‘simpleLoess’ was found
It was found in the following places
  namespace:stats
with value

function (y, x, weights, span = 0.75, degree = 2L, parametric = FALSE, 
    drop.square = FALSE, normalize = TRUE, statistics = "approximate", 
    surface = "interpolate", cell, iterations, iterTrace, trace.hat) 
{
    D <- as.integer(NCOL(x))
    if (is.na(D)) 
        stop("invalid NCOL(X)")
    if (D > 4) 
        stop("only 1-4 predictors are allowed")
    N <- as.integer(NROW(x))
    if (is.na(N)) 
        stop("invalid NROW(X)")
    if (!N || !D) 
        stop("invalid 'x'")
    if (length(y) != N) 
        stop("invalid 'y'")
    x <- as.matrix(x)
    storage.mode(x) <- "double"
    storage.mode(y) <- "double"
    storage.mode(weights) <- "double"
    max.kd <- max(N, 200L)
    robust <- rep_len(1, N)
    if (normalize && D > 1L) {
        trim <- ceiling(0.1 * N)
        divisor <- sqrt(apply(apply(x, 2L, sort)[seq(trim + 1, 
            N - trim), , drop = FALSE], 2L, var))
        x <- x/rep(divisor, rep_len(N, D))
    }
    else divisor <- 1
    sum.drop.sqr <- sum(drop.square)
    sum.parametric <- sum(parametric)
    nonparametric <- sum(!parametric)
    order.parametric <- order(parametric)
    x <- x[, order.parametric]
    order.drop.sqr <- (2L - drop.square)[order.parametric]
    if (degree == 1L && sum.drop.sqr) 
        stop("specified the square of a factor predictor to be dropped when degree = 1")
    if (D == 1L && sum.drop.sqr) 
        stop("specified the square of a predictor to be dropped with only one numeric predictor")
    if (sum.parametric == D) 
        stop("specified parametric for all predictors")
    if (length(span) != 1L) 
        stop("invalid argument 'span'")
    if (length(cell) != 1L) 
        stop("invalid argument 'cell'")
    if (length(degree) != 1L) 
        stop("invalid argument 'degree'")
    if (surface == "interpolate" && statistics == "approximate") 
        statistics <- if (trace.hat == "exact") 
            "1.approx"
        else "2.approx"
    surf.stat <- paste(surface, statistics, sep = "/")
    do.rob <- (iterations > 1L)
    if (!do.rob && iterTrace) {
        warning(sprintf(gettext("iterTrace = %d is not obeyed since iterations = %d"), 
            iterTrace, iterations))
        iterTrace <- FALSE
    }
    no.st <- (statistics == "none")
    if (iterTrace) 
        wRSS <- NA
    for (j in seq_len(iterations)) {
        no.st <- (statistics == "none")
        z <- .C(C_loess_raw, y, x, if (no.st) 1 else weights, 
            if (no.st) weights * robust else 1, D, N, as.double(span), 
            as.integer(degree), as.integer(nonparametric), as.integer(order.drop.sqr), 
            as.integer(sum.drop.sqr), as.double(span * cell), 
            as.character(surf.stat), fitted.values = double(N), 
            parameter = integer(7L), a = integer(max.kd), xi = double(max.kd), 
            vert = double(2L * D), vval = double((D + 1L) * max.kd), 
            diagonal = double(N), trL = double(1L), delta1 = double(1L), 
            delta2 = double(1L), as.integer(surf.stat == "interpolate/exact"))
        fitted.residuals <- y - z$fitted.values
        if (j < iterations) {
            if (iterTrace) 
                old.rob <- robust
            robust <- .Fortran(C_lowesw, fitted.residuals, N, 
                robust = double(N), integer(N))$robust
        }
        if (j == 1) {
            trace.hat.out <- z$trL
            one.delta <- z$delta1
            two.delta <- z$delta2
            if (do.rob) {
                statistics <- "none"
                surf.stat <- paste(surface, statistics, sep = "/")
                no.st <- TRUE
            }
        }
        if (iterTrace) {
            oSS <- wRSS
            wRSS <- sum(weights * fitted.residuals^2)
            del.SS <- abs(oSS - wRSS)/(if (wRSS == 0) 
                1
            else wRSS)
            d.rob.w <- if (j < iterations) 
                sum(abs(old.rob - robust))/sum(robust)
            else NA
            cat(sprintf("iter.%2d: wRSS=%#14.9g, rel. changes: (SS=%#9.4g, rob.wgts=%#9.4g)\n", 
                j, wRSS, del.SS, d.rob.w))
            if (iterTrace >= 2 && j < iterations) {
                cat("robustness weights:\n")
                print(quantile(robust, probs = (0:8)/8), digits = 3)
            }
        }
    }
    if (surface == "interpolate") {
        pars <- setNames(z$parameter, c("d", "n", "vc", "nc", 
            "nv", "liv", "lv"))
        enough <- (D + 1L) * pars[["nv"]]
        fit.kd <- list(parameter = pars, a = z$a[1L:pars[4L]], 
            xi = z$xi[1L:pars[4L]], vert = z$vert, vval = z$vval[1L:enough])
    }
    if (do.rob) {
        pseudovalues <- .Fortran(C_lowesp, N, as.double(y), as.double(z$fitted.values), 
            as.double(weights), as.double(robust), integer(N), 
            pseudovalues = double(N))$pseudovalues
        zz <- .C(C_loess_raw, pseudovalues, x, weights, weights, 
            D, N, as.double(span), as.integer(degree), as.integer(nonparametric), 
            as.integer(order.drop.sqr), as.integer(sum.drop.sqr), 
            as.double(span * cell), as.character(surf.stat), 
            fitted = double(N), parameter = integer(7L), a = integer(max.kd), 
            xi = double(max.kd), vert = double(2L * D), vval = double((D + 
                1L) * max.kd), diagonal = double(N), trL = double(1L), 
            delta1 = double(1L), delta2 = double(1L), 0L)[["fitted"]]
        pseudo.resid <- pseudovalues - zz
    }
    sum.squares <- if (do.rob) 
        sum(weights * pseudo.resid^2)
    else sum(weights * fitted.residuals^2)
    enp <- one.delta + 2 * trace.hat.out - N
    s <- sqrt(sum.squares/one.delta)
    structure(class = "loess", list(n = N, fitted = z$fitted.values, 
        residuals = fitted.residuals, enp = enp, s = s, one.delta = one.delta, 
        two.delta = two.delta, trace.hat = trace.hat.out, divisor = divisor, 
        robust = robust, pars = list(span = span, degree = degree, 
            normalize = normalize, parametric = parametric, drop.square = drop.square, 
            surface = surface, cell = cell, family = if (iterations <= 
                1L) "gaussian" else "symmetric", trace.hat = trace.hat, 
            iterations = iterations), kd = if (surface == "interpolate") fit.kd))
}
<bytecode: 0x564a745590a8>
<environment: namespace:stats>
> argsAnywhere(format.dist)
function (x, ...) 
NULL
> 
> 
> 
> cleanEx()
> nameEx("getFromNamespace")
> ### * getFromNamespace
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: getFromNamespace
> ### Title: Utility Functions for Developing Namespaces
> ### Aliases: assignInNamespace assignInMyNamespace getFromNamespace
> ###   fixInNamespace
> ### Keywords: data
> 
> ### ** Examples
> 
> getFromNamespace("findGeneric", "utils")
function (fname, envir, warnS4only = TRUE) 
{
    if (!exists(fname, mode = "function", envir = envir)) 
        return("")
    f <- get(fname, mode = "function", envir = envir)
    if (.isMethodsDispatchOn() && methods::is(f, "genericFunction")) {
        fMethsEnv <- methods::getMethodsForDispatch(f)
        meths <- as.list(fMethsEnv, all.names = TRUE)
        r <- meths[grep("^ANY\\b", names(meths))]
        if (any(ddm <- vapply(r, methods::is, logical(1L), "derivedDefaultMethod"))) 
            f <- r[ddm][[1]]@.Data
        else if (warnS4only) 
            warning(gettextf("'%s' is a formal generic function; S3 methods will not likely be found", 
                fname), domain = NA)
    }
    isUMEbrace <- function(e) {
        for (ee in as.list(e[-1L])) if (nzchar(res <- isUME(ee))) 
            return(res)
        ""
    }
    isUMEif <- function(e) {
        if (length(e) == 3L) 
            isUME(e[[3L]])
        else {
            if (nzchar(res <- isUME(e[[3L]]))) 
                res
            else if (nzchar(res <- isUME(e[[4L]]))) 
                res
            else ""
        }
    }
    isUME <- function(e) {
        if (is.call(e) && (is.name(e[[1L]]) || is.character(e[[1L]]))) {
            switch(as.character(e[[1L]]), UseMethod = as.character(e[[2L]]), 
                `{` = isUMEbrace(e), `if` = isUMEif(e), "")
        }
        else ""
    }
    isUME(body(f))
}
<bytecode: 0x564a745149a0>
<environment: namespace:utils>
> ## Not run: 
> ##D fixInNamespace("predict.ppr", "stats")
> ##D stats:::predict.ppr
> ##D getS3method("predict", "ppr")
> ##D ## alternatively
> ##D fixInNamespace("predict.ppr", pos = 3)
> ##D fixInNamespace("predict.ppr", pos = "package:stats")
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("getParseData")
> ### * getParseData
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: getParseData
> ### Title: Get Detailed Parse Information from Object
> ### Aliases: getParseData getParseText
> ### Keywords: utilities
> 
> ### ** Examples
> 
> fn <- function(x) {
+   x + 1 # A comment, kept as part of the source
+ }
> 
> d <- getParseData(fn)
> if (!is.null(d)) {
+   plus <- which(d$token == "'+'")
+   sum <- d$parent[plus]
+   print(d[as.character(sum),])
+   print(getParseText(d, sum))
+ }
> 
> 
> 
> cleanEx()
> nameEx("getS3method")
> ### * getS3method
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: getS3method
> ### Title: Get an S3 Method
> ### Aliases: getS3method
> ### Keywords: data methods
> 
> ### ** Examples
> 
> require(stats)
> exists("predict.ppr") # false
[1] FALSE
> getS3method("predict", "ppr")
function (object, newdata, ...) 
{
    if (missing(newdata)) 
        return(fitted(object))
    if (!is.null(object$terms)) {
        newdata <- as.data.frame(newdata)
        rn <- row.names(newdata)
        Terms <- delete.response(object$terms)
        m <- model.frame(Terms, newdata, na.action = na.omit, 
            xlev = object$xlevels)
        if (!is.null(cl <- attr(Terms, "dataClasses"))) 
            .checkMFClasses(cl, m)
        keep <- match(row.names(m), rn)
        x <- model.matrix(Terms, m, contrasts.arg = object$contrasts)
    }
    else {
        x <- as.matrix(newdata)
        keep <- seq_len(nrow(x))
        rn <- dimnames(x)[[1L]]
    }
    if (ncol(x) != object$p) 
        stop("wrong number of columns in 'x'")
    res <- matrix(NA, length(keep), object$q, dimnames = list(rn, 
        object$ynames))
    res[keep, ] <- matrix(.Fortran(C_pppred, as.integer(nrow(x)), 
        as.double(x), as.double(object$smod), y = double(nrow(x) * 
            object$q), double(2 * object$smod[4L]))$y, ncol = object$q)
    drop(res)
}
<bytecode: 0x564a74604320>
<environment: namespace:stats>
> 
> 
> 
> cleanEx()
> nameEx("getWindowsHandle")
> ### * getWindowsHandle
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: getWindowsHandle
> ### Title: Get a Windows Handle
> ### Aliases: getWindowsHandle
> ### Keywords: utilities
> 
> ### ** Examples
> 
> if(.Platform$OS.type == "windows")
+   print( getWindowsHandle() )
> 
> 
> 
> cleanEx()
> nameEx("getWindowsHandles")
> ### * getWindowsHandles
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: getWindowsHandles
> ### Title: Get handles of Windows in the MS Windows RGui
> ### Aliases: getWindowsHandles
> ### Keywords: utilities
> 
> ### ** Examples
> 
> 
> cleanEx()
> nameEx("glob2rx")
> ### * glob2rx
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: glob2rx
> ### Title: Change Wildcard or Globbing Pattern into Regular Expression
> ### Aliases: glob2rx
> ### Keywords: file character utilities
> 
> ### ** Examples
> 
> stopifnot(glob2rx("abc.*") == "^abc\\.",
+           glob2rx("a?b.*") == "^a.b\\.",
+           glob2rx("a?b.*", trim.tail = FALSE) == "^a.b\\..*$",
+           glob2rx("*.doc") == "^.*\\.doc$",
+           glob2rx("*.doc", trim.head = TRUE) == "\\.doc$",
+           glob2rx("*.t*")  == "^.*\\.t",
+           glob2rx("*.t??") == "^.*\\.t..$",
+           glob2rx("*[*")  == "^.*\\["
+ )
> 
> 
> 
> cleanEx()
> nameEx("globalVariables")
> ### * globalVariables
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: globalVariables
> ### Title: Declarations Used in Checking a Package
> ### Aliases: globalVariables suppressForeignCheck
> ### Keywords: packages
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ## assume your package has some code that assigns ".obj1" and ".obj2"
> ##D ## but not in a way that codetools can find.
> ##D ## In the same source file (to remind you that you did it) add:
> ##D if(getRversion() >= "2.15.1")  utils::globalVariables(c(".obj1", "obj2"))
> ##D 
> ##D ## To suppress messages about a run-time calculated native symbol, 
> ##D ## save it to a local variable.
> ##D 
> ##D ## At top level, put this:
> ##D if(getRversion() >= "3.1.0") utils::suppressForeignCheck("localvariable")
> ##D 
> ##D ## Within your function, do the call like this:
> ##D localvariable <- if (condition) entry1 else entry2
> ##D .Call(localvariable, 1, 2, 3)
> ##D 
> ##D ## HOWEVER, it is much better practice to write code
> ##D ## that can be checked thoroughly, e.g.
> ##D if(condition) .Call(entry1, 1, 2, 3) else .Call(entry2, 1, 2, 3)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("hasName")
> ### * hasName
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: hasName
> ### Title: Check for Name
> ### Aliases: hasName
> ### Keywords: manip logic
> 
> ### ** Examples
> 
> x <- list(abc = 1, def = 2)
> !is.null(x$abc) # correct
[1] TRUE
> !is.null(x$a)   # this is the wrong test!
[1] TRUE
> hasName(x, "abc")
[1] TRUE
> hasName(x, "a")
[1] FALSE
> 
> 
> 
> cleanEx()
> nameEx("head")
> ### * head
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: head
> ### Title: Return the First or Last Parts of an Object
> ### Aliases: head head.data.frame head.default head.function head.ftable
> ###   head.matrix tail tail.data.frame tail.default tail.function
> ###   tail.ftable tail.table tail.matrix tail.array
> ### Keywords: manip
> 
> ### ** Examples
> 
> head(letters)
[1] "a" "b" "c" "d" "e" "f"
> head(letters, n = -6L)
 [1] "a" "b" "c" "d" "e" "f" "g" "h" "i" "j" "k" "l" "m" "n" "o" "p" "q" "r" "s"
[20] "t"
> 
> head(freeny.x, n = 10L)
      lag quarterly revenue price index income level market potential
 [1,]               8.79636     4.70997      5.82110          12.9699
 [2,]               8.79236     4.70217      5.82558          12.9733
 [3,]               8.79137     4.68944      5.83112          12.9774
 [4,]               8.81486     4.68558      5.84046          12.9806
 [5,]               8.81301     4.64019      5.85036          12.9831
 [6,]               8.90751     4.62553      5.86464          12.9854
 [7,]               8.93673     4.61991      5.87769          12.9900
 [8,]               8.96161     4.61654      5.89763          12.9943
 [9,]               8.96044     4.61407      5.92574          12.9992
[10,]               9.00868     4.60766      5.94232          13.0033
> head(freeny.y)
[1] 8.79236 8.79137 8.81486 8.81301 8.90751 8.93673
> 
> head(iris3)
, , Setosa

     Sepal L. Sepal W. Petal L. Petal W.
[1,]      5.1      3.5      1.4      0.2
[2,]      4.9      3.0      1.4      0.2
[3,]      4.7      3.2      1.3      0.2
[4,]      4.6      3.1      1.5      0.2
[5,]      5.0      3.6      1.4      0.2
[6,]      5.4      3.9      1.7      0.4

, , Versicolor

     Sepal L. Sepal W. Petal L. Petal W.
[1,]      7.0      3.2      4.7      1.4
[2,]      6.4      3.2      4.5      1.5
[3,]      6.9      3.1      4.9      1.5
[4,]      5.5      2.3      4.0      1.3
[5,]      6.5      2.8      4.6      1.5
[6,]      5.7      2.8      4.5      1.3

, , Virginica

     Sepal L. Sepal W. Petal L. Petal W.
[1,]      6.3      3.3      6.0      2.5
[2,]      5.8      2.7      5.1      1.9
[3,]      7.1      3.0      5.9      2.1
[4,]      6.3      2.9      5.6      1.8
[5,]      6.5      3.0      5.8      2.2
[6,]      7.6      3.0      6.6      2.1

> head(iris3, c(6L, 2L))
, , Setosa

     Sepal L. Sepal W.
[1,]      5.1      3.5
[2,]      4.9      3.0
[3,]      4.7      3.2
[4,]      4.6      3.1
[5,]      5.0      3.6
[6,]      5.4      3.9

, , Versicolor

     Sepal L. Sepal W.
[1,]      7.0      3.2
[2,]      6.4      3.2
[3,]      6.9      3.1
[4,]      5.5      2.3
[5,]      6.5      2.8
[6,]      5.7      2.8

, , Virginica

     Sepal L. Sepal W.
[1,]      6.3      3.3
[2,]      5.8      2.7
[3,]      7.1      3.0
[4,]      6.3      2.9
[5,]      6.5      3.0
[6,]      7.6      3.0

> head(iris3, c(6L, -1L, 2L))
, , Setosa

     Sepal L. Sepal W. Petal L.
[1,]      5.1      3.5      1.4
[2,]      4.9      3.0      1.4
[3,]      4.7      3.2      1.3
[4,]      4.6      3.1      1.5
[5,]      5.0      3.6      1.4
[6,]      5.4      3.9      1.7

, , Versicolor

     Sepal L. Sepal W. Petal L.
[1,]      7.0      3.2      4.7
[2,]      6.4      3.2      4.5
[3,]      6.9      3.1      4.9
[4,]      5.5      2.3      4.0
[5,]      6.5      2.8      4.6
[6,]      5.7      2.8      4.5

> 
> tail(letters)
[1] "u" "v" "w" "x" "y" "z"
> tail(letters, n = -6L)
 [1] "g" "h" "i" "j" "k" "l" "m" "n" "o" "p" "q" "r" "s" "t" "u" "v" "w" "x" "y"
[20] "z"
> 
> tail(freeny.x)
      lag quarterly revenue price index income level market potential
[34,]               9.69405     4.30909      6.17369          13.1459
[35,]               9.69958     4.30909      6.16135          13.1520
[36,]               9.68683     4.30552      6.18231          13.1593
[37,]               9.71774     4.29627      6.18768          13.1579
[38,]               9.74924     4.27839      6.19377          13.1625
[39,]               9.77536     4.27789      6.20030          13.1664
> ## the bottom-right "corner" :
> tail(freeny.x, n = c(4, 2))
      income level market potential
[36,]      6.18231          13.1593
[37,]      6.18768          13.1579
[38,]      6.19377          13.1625
[39,]      6.20030          13.1664
> tail(freeny.y)
[1] 9.69958 9.68683 9.71774 9.74924 9.77536 9.79424
> 
> tail(iris3)
, , Setosa

      Sepal L. Sepal W. Petal L. Petal W.
[45,]      5.1      3.8      1.9      0.4
[46,]      4.8      3.0      1.4      0.3
[47,]      5.1      3.8      1.6      0.2
[48,]      4.6      3.2      1.4      0.2
[49,]      5.3      3.7      1.5      0.2
[50,]      5.0      3.3      1.4      0.2

, , Versicolor

      Sepal L. Sepal W. Petal L. Petal W.
[45,]      5.6      2.7      4.2      1.3
[46,]      5.7      3.0      4.2      1.2
[47,]      5.7      2.9      4.2      1.3
[48,]      6.2      2.9      4.3      1.3
[49,]      5.1      2.5      3.0      1.1
[50,]      5.7      2.8      4.1      1.3

, , Virginica

      Sepal L. Sepal W. Petal L. Petal W.
[45,]      6.7      3.3      5.7      2.5
[46,]      6.7      3.0      5.2      2.3
[47,]      6.3      2.5      5.0      1.9
[48,]      6.5      3.0      5.2      2.0
[49,]      6.2      3.4      5.4      2.3
[50,]      5.9      3.0      5.1      1.8

> tail(iris3, c(6L, 2L))
, , Setosa

      Petal L. Petal W.
[45,]      1.9      0.4
[46,]      1.4      0.3
[47,]      1.6      0.2
[48,]      1.4      0.2
[49,]      1.5      0.2
[50,]      1.4      0.2

, , Versicolor

      Petal L. Petal W.
[45,]      4.2      1.3
[46,]      4.2      1.2
[47,]      4.2      1.3
[48,]      4.3      1.3
[49,]      3.0      1.1
[50,]      4.1      1.3

, , Virginica

      Petal L. Petal W.
[45,]      5.7      2.5
[46,]      5.2      2.3
[47,]      5.0      1.9
[48,]      5.2      2.0
[49,]      5.4      2.3
[50,]      5.1      1.8

> tail(iris3, c(6L, -1L, 2L))
, , Versicolor

      Sepal W. Petal L. Petal W.
[45,]      2.7      4.2      1.3
[46,]      3.0      4.2      1.2
[47,]      2.9      4.2      1.3
[48,]      2.9      4.3      1.3
[49,]      2.5      3.0      1.1
[50,]      2.8      4.1      1.3

, , Virginica

      Sepal W. Petal L. Petal W.
[45,]      3.3      5.7      2.5
[46,]      3.0      5.2      2.3
[47,]      2.5      5.0      1.9
[48,]      3.0      5.2      2.0
[49,]      3.4      5.4      2.3
[50,]      3.0      5.1      1.8

> 
> ## iris with dimnames stripped
> a3d <- iris3 ; dimnames(a3d) <- NULL
> tail(a3d, c(6, -1, 2)) # keepnums = TRUE is default here!
, , 2

      [,2] [,3] [,4]
[45,]  2.7  4.2  1.3
[46,]  3.0  4.2  1.2
[47,]  2.9  4.2  1.3
[48,]  2.9  4.3  1.3
[49,]  2.5  3.0  1.1
[50,]  2.8  4.1  1.3

, , 3

      [,2] [,3] [,4]
[45,]  3.3  5.7  2.5
[46,]  3.0  5.2  2.3
[47,]  2.5  5.0  1.9
[48,]  3.0  5.2  2.0
[49,]  3.4  5.4  2.3
[50,]  3.0  5.1  1.8

> tail(a3d, c(6, -1, 2), keepnums = FALSE)
, , 1

     [,1] [,2] [,3]
[1,]  2.7  4.2  1.3
[2,]  3.0  4.2  1.2
[3,]  2.9  4.2  1.3
[4,]  2.9  4.3  1.3
[5,]  2.5  3.0  1.1
[6,]  2.8  4.1  1.3

, , 2

     [,1] [,2] [,3]
[1,]  3.3  5.7  2.5
[2,]  3.0  5.2  2.3
[3,]  2.5  5.0  1.9
[4,]  3.0  5.2  2.0
[5,]  3.4  5.4  2.3
[6,]  3.0  5.1  1.8

> 
> ## data frame w/ a (non-standard) attribute:
> treeS <- structure(trees, foo = "bar")
> (n <- nrow(treeS))
[1] 31
> stopifnot(exprs = { # attribute is kept
+     identical(htS <- head(treeS), treeS[1:6, ])
+     identical(attr(htS, "foo") , "bar")
+     identical(tlS <- tail(treeS), treeS[(n-5):n, ])
+     ## BUT if I use "useAttrib(.)", this is *not* ok, when n is of length 2:
+     ## --- because [i,j]-indexing of data frames *also* drops "other" attributes ..
+     identical(tail(treeS, 3:2), treeS[(n-2):n, 2:3] )
+ })
> 
> tail(library) # last lines of function
                                   
378         return(y)              
379     }                          
380     if (logical.return)        
381         TRUE                   
382     else invisible(.packages())
383 }                              
> 
> head(stats::ftable(Titanic))
                                               
                          "Survived" "No" "Yes"
 "Class" "Sex"    "Age"                        
 "1st"   "Male"   "Child"               0     5
                  "Adult"             118    57
         "Female" "Child"               0     1
                  "Adult"               4   140
 "2nd"   "Male"   "Child"               0    11
                  "Adult"             154    14
> 
> ## 1d-array (with named dim) :
> a1 <- array(1:7, 7); names(dim(a1)) <- "O2"
> stopifnot(exprs = {
+   identical( tail(a1, 10), a1)
+   identical( head(a1, 10), a1)
+   identical( head(a1, 1), a1 [1 , drop=FALSE] ) # was a1[1] in R <= 3.6.x
+   identical( tail(a1, 2), a1[6:7])
+   identical( tail(a1, 1), a1 [7 , drop=FALSE] ) # was a1[7] in R <= 3.6.x
+ })
> 
> 
> 
> cleanEx()
> nameEx("help")
> ### * help
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: help
> ### Title: Documentation
> ### Aliases: help
> ### Keywords: documentation
> 
> ### ** Examples
> 
> help()
help                   package:utils                   R Documentation

_D_o_c_u_m_e_n_t_a_t_i_o_n

_D_e_s_c_r_i_p_t_i_o_n:

     ‘help’ is the primary interface to the help systems.

_U_s_a_g_e:

     help(topic, package = NULL, lib.loc = NULL,
          verbose = getOption("verbose"),
          try.all.packages = getOption("help.try.all.packages"),
          help_type = getOption("help_type"))
     
_A_r_g_u_m_e_n_t_s:

   topic: usually, a name or character string specifying the topic for
          which help is sought.  A character string (enclosed in
          explicit single or double quotes) is always taken as naming a
          topic.

          If the value of ‘topic’ is a length-one character vector the
          topic is taken to be the value of the only element.
          Otherwise ‘topic’ must be a name or a reserved word (if
          syntactically valid) or character string.

          See ‘Details’ for what happens if this is omitted.

 package: a name or character vector giving the packages to look into
          for documentation, or ‘NULL’.  By default, all packages whose
          namespaces are loaded are used.  To avoid a name being
          deparsed use e.g.  ‘(pkg_ref)’ (see the examples).

 lib.loc: a character vector of directory names of R libraries, or
          ‘NULL’.  The default value of ‘NULL’ corresponds to all
          libraries currently known.  If the default is used, the
          loaded packages are searched before the libraries.  This is
          not used for HTML help (see ‘Details’).

 verbose: logical; if ‘TRUE’, the file name is reported.

try.all.packages: logical; see ‘Note’.

help_type: character string: the type of help required.  Possible
          values are ‘"text"’, ‘"html"’ and ‘"pdf"’.  Case is ignored,
          and partial matching is allowed.

_D_e_t_a_i_l_s:

     The following types of help are available:

        • Plain text help

        • HTML help pages with hyperlinks to other topics, shown in a
          browser by ‘browseURL’.

          (On Unix-alikes, where possible an existing browser window is
          re-used: the macOS GUI uses its own browser window.)

          If for some reason HTML help is unavailable (see
          ‘startDynamicHelp’), plain text help will be used instead.

        • For ‘help’ only, typeset as PDF - see the section on ‘Offline
          help’.

     On Unix-alikes: The ‘factory-fresh’ default is text help except
          from the macOS GUI, which uses HTML help displayed in its own
          browser window.

     On Windows: The default for the type of help is selected when R is
          installed - the ‘factory-fresh’ default is HTML help.

     The rendering of text help will use directional quotes in suitable
     locales (UTF-8 and single-byte Windows locales): sometimes the
     fonts used do not support these quotes so this can be turned off
     by setting ‘options(useFancyQuotes = FALSE)’.

     ‘topic’ is not optional: if it is omitted R will give

        • If a package is specified, (text or, in interactive use only,
          HTML) information on the package, including hints/links to
          suitable help topics.

        • If ‘lib.loc’ only is specified, a (text) list of available
          packages.

        • Help on ‘help’ itself if none of the first three arguments is
          specified.

     Some topics need to be quoted (by backticks) or given as a
     character string.  These include those which cannot syntactically
     appear on their own such as unary and binary operators, ‘function’
     and control-flow reserved words (including ‘if’, ‘else’ ‘for’,
     ‘in’, ‘repeat’, ‘while’, ‘break’ and ‘next’).  The other
     ‘reserved’ words can be used as if they were names, for example
     ‘TRUE’, ‘NA’ and ‘Inf’.

     If multiple help files matching ‘topic’ are found, in interactive
     use a menu is presented for the user to choose one: in batch use
     the first on the search path is used.  (For HTML help the menu
     will be an HTML page, otherwise a graphical menu if possible if
     ‘getOption("menu.graphics")’ is true, the default.)

     Note that HTML help does not make use of ‘lib.loc’: it will always
     look first in the loaded packages and then along ‘.libPaths()’.

_O_f_f_l_i_n_e _h_e_l_p:

     Typeset documentation is produced by running the LaTeX version of
     the help page through ‘pdflatex’: this will produce a PDF file.

     The appearance of the output can be customized through a file
     ‘Rhelp.cfg’ somewhere in your LaTeX search path: this will be
     input as a LaTeX style file after ‘Rd.sty’.  Some environment
     variables are consulted, notably ‘R_PAPERSIZE’ (_via_
     ‘getOption("papersize")’) and ‘R_RD4PDF’ (see ‘Making manuals’ in
     the ‘R Installation and Administration Manual’).

     If there is a function ‘offline_help_helper’ in the workspace or
     further down the search path it is used to do the typesetting,
     otherwise the function of that name in the ‘utils’ namespace (to
     which the first paragraph applies).  It should accept at least two
     arguments, the name of the LaTeX file to be typeset and the type
     (which is nowadays ignored).  It accepts a third argument,
     ‘texinputs’, which will give the graphics path when the help
     document contains figures, and will otherwise not be supplied.

_N_o_t_e:

     Unless ‘lib.loc’ is specified explicitly, the loaded packages are
     searched before those in the specified libraries.  This ensures
     that if a library is loaded from a library not in the known
     library trees, then the help from the loaded library is used.  If
     ‘lib.loc’ is specified explicitly, the loaded packages are _not_
     searched.

     If this search fails and argument ‘try.all.packages’ is ‘TRUE’ and
     neither ‘packages’ nor ‘lib.loc’ is specified, then all the
     packages in the known library trees are searched for help on
     ‘topic’ and a list of (any) packages where help may be found is
     displayed (with hyperlinks for ‘help_type = "html"’).  *NB:*
     searching all packages can be slow, especially the first time
     (caching of files by the OS can expedite subsequent searches
     dramatically).

_R_e_f_e_r_e_n_c_e_s:

     Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988) _The New S
     Language_.  Wadsworth & Brooks/Cole.

_S_e_e _A_l_s_o:

     ‘?’ for shortcuts to help topics.

     ‘help.search()’ or ‘??’ for finding help pages on a vague topic;
     ‘help.start()’ which opens the HTML version of the R help pages;
     ‘library()’ for listing available packages and the help objects
     they contain; ‘data()’ for listing available data sets;
     ‘methods()’.

     Use ‘prompt()’ to get a prototype for writing ‘help’ pages of your
     own package.

_E_x_a_m_p_l_e_s:

     help()
     help(help)              # the same
     
     help(lapply)
     
     help("for")             # or ?"for", but quotes/backticks are needed
     
     try({# requires working TeX installation:
      help(dgamma, help_type = "pdf")
      ## -> nicely formatted pdf -- including math formula -- for help(dgamma):
      system2(getOption("pdfviewer"), "dgamma.pdf", wait = FALSE)
     })
     
     help(package = "splines") # get help even when package is not loaded
     
     topi <- "women"
     help(topi)
     
     try(help("bs", try.all.packages = FALSE)) # reports not found (an error)
     help("bs", try.all.packages = TRUE)       # reports can be found
                                               # in package 'splines'
     
     ## For programmatic use:
     topic <- "family"; pkg_ref <- "stats"
     help((topic), (pkg_ref))
     

> help(help)              # the same
help                   package:utils                   R Documentation

_D_o_c_u_m_e_n_t_a_t_i_o_n

_D_e_s_c_r_i_p_t_i_o_n:

     ‘help’ is the primary interface to the help systems.

_U_s_a_g_e:

     help(topic, package = NULL, lib.loc = NULL,
          verbose = getOption("verbose"),
          try.all.packages = getOption("help.try.all.packages"),
          help_type = getOption("help_type"))
     
_A_r_g_u_m_e_n_t_s:

   topic: usually, a name or character string specifying the topic for
          which help is sought.  A character string (enclosed in
          explicit single or double quotes) is always taken as naming a
          topic.

          If the value of ‘topic’ is a length-one character vector the
          topic is taken to be the value of the only element.
          Otherwise ‘topic’ must be a name or a reserved word (if
          syntactically valid) or character string.

          See ‘Details’ for what happens if this is omitted.

 package: a name or character vector giving the packages to look into
          for documentation, or ‘NULL’.  By default, all packages whose
          namespaces are loaded are used.  To avoid a name being
          deparsed use e.g.  ‘(pkg_ref)’ (see the examples).

 lib.loc: a character vector of directory names of R libraries, or
          ‘NULL’.  The default value of ‘NULL’ corresponds to all
          libraries currently known.  If the default is used, the
          loaded packages are searched before the libraries.  This is
          not used for HTML help (see ‘Details’).

 verbose: logical; if ‘TRUE’, the file name is reported.

try.all.packages: logical; see ‘Note’.

help_type: character string: the type of help required.  Possible
          values are ‘"text"’, ‘"html"’ and ‘"pdf"’.  Case is ignored,
          and partial matching is allowed.

_D_e_t_a_i_l_s:

     The following types of help are available:

        • Plain text help

        • HTML help pages with hyperlinks to other topics, shown in a
          browser by ‘browseURL’.

          (On Unix-alikes, where possible an existing browser window is
          re-used: the macOS GUI uses its own browser window.)

          If for some reason HTML help is unavailable (see
          ‘startDynamicHelp’), plain text help will be used instead.

        • For ‘help’ only, typeset as PDF - see the section on ‘Offline
          help’.

     On Unix-alikes: The ‘factory-fresh’ default is text help except
          from the macOS GUI, which uses HTML help displayed in its own
          browser window.

     On Windows: The default for the type of help is selected when R is
          installed - the ‘factory-fresh’ default is HTML help.

     The rendering of text help will use directional quotes in suitable
     locales (UTF-8 and single-byte Windows locales): sometimes the
     fonts used do not support these quotes so this can be turned off
     by setting ‘options(useFancyQuotes = FALSE)’.

     ‘topic’ is not optional: if it is omitted R will give

        • If a package is specified, (text or, in interactive use only,
          HTML) information on the package, including hints/links to
          suitable help topics.

        • If ‘lib.loc’ only is specified, a (text) list of available
          packages.

        • Help on ‘help’ itself if none of the first three arguments is
          specified.

     Some topics need to be quoted (by backticks) or given as a
     character string.  These include those which cannot syntactically
     appear on their own such as unary and binary operators, ‘function’
     and control-flow reserved words (including ‘if’, ‘else’ ‘for’,
     ‘in’, ‘repeat’, ‘while’, ‘break’ and ‘next’).  The other
     ‘reserved’ words can be used as if they were names, for example
     ‘TRUE’, ‘NA’ and ‘Inf’.

     If multiple help files matching ‘topic’ are found, in interactive
     use a menu is presented for the user to choose one: in batch use
     the first on the search path is used.  (For HTML help the menu
     will be an HTML page, otherwise a graphical menu if possible if
     ‘getOption("menu.graphics")’ is true, the default.)

     Note that HTML help does not make use of ‘lib.loc’: it will always
     look first in the loaded packages and then along ‘.libPaths()’.

_O_f_f_l_i_n_e _h_e_l_p:

     Typeset documentation is produced by running the LaTeX version of
     the help page through ‘pdflatex’: this will produce a PDF file.

     The appearance of the output can be customized through a file
     ‘Rhelp.cfg’ somewhere in your LaTeX search path: this will be
     input as a LaTeX style file after ‘Rd.sty’.  Some environment
     variables are consulted, notably ‘R_PAPERSIZE’ (_via_
     ‘getOption("papersize")’) and ‘R_RD4PDF’ (see ‘Making manuals’ in
     the ‘R Installation and Administration Manual’).

     If there is a function ‘offline_help_helper’ in the workspace or
     further down the search path it is used to do the typesetting,
     otherwise the function of that name in the ‘utils’ namespace (to
     which the first paragraph applies).  It should accept at least two
     arguments, the name of the LaTeX file to be typeset and the type
     (which is nowadays ignored).  It accepts a third argument,
     ‘texinputs’, which will give the graphics path when the help
     document contains figures, and will otherwise not be supplied.

_N_o_t_e:

     Unless ‘lib.loc’ is specified explicitly, the loaded packages are
     searched before those in the specified libraries.  This ensures
     that if a library is loaded from a library not in the known
     library trees, then the help from the loaded library is used.  If
     ‘lib.loc’ is specified explicitly, the loaded packages are _not_
     searched.

     If this search fails and argument ‘try.all.packages’ is ‘TRUE’ and
     neither ‘packages’ nor ‘lib.loc’ is specified, then all the
     packages in the known library trees are searched for help on
     ‘topic’ and a list of (any) packages where help may be found is
     displayed (with hyperlinks for ‘help_type = "html"’).  *NB:*
     searching all packages can be slow, especially the first time
     (caching of files by the OS can expedite subsequent searches
     dramatically).

_R_e_f_e_r_e_n_c_e_s:

     Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988) _The New S
     Language_.  Wadsworth & Brooks/Cole.

_S_e_e _A_l_s_o:

     ‘?’ for shortcuts to help topics.

     ‘help.search()’ or ‘??’ for finding help pages on a vague topic;
     ‘help.start()’ which opens the HTML version of the R help pages;
     ‘library()’ for listing available packages and the help objects
     they contain; ‘data()’ for listing available data sets;
     ‘methods()’.

     Use ‘prompt()’ to get a prototype for writing ‘help’ pages of your
     own package.

_E_x_a_m_p_l_e_s:

     help()
     help(help)              # the same
     
     help(lapply)
     
     help("for")             # or ?"for", but quotes/backticks are needed
     
     try({# requires working TeX installation:
      help(dgamma, help_type = "pdf")
      ## -> nicely formatted pdf -- including math formula -- for help(dgamma):
      system2(getOption("pdfviewer"), "dgamma.pdf", wait = FALSE)
     })
     
     help(package = "splines") # get help even when package is not loaded
     
     topi <- "women"
     help(topi)
     
     try(help("bs", try.all.packages = FALSE)) # reports not found (an error)
     help("bs", try.all.packages = TRUE)       # reports can be found
                                               # in package 'splines'
     
     ## For programmatic use:
     topic <- "family"; pkg_ref <- "stats"
     help((topic), (pkg_ref))
     

> 
> help(lapply)
lapply                  package:base                   R Documentation

_A_p_p_l_y _a _F_u_n_c_t_i_o_n _o_v_e_r _a _L_i_s_t _o_r _V_e_c_t_o_r

_D_e_s_c_r_i_p_t_i_o_n:

     ‘lapply’ returns a list of the same length as ‘X’, each element of
     which is the result of applying ‘FUN’ to the corresponding element
     of ‘X’.

     ‘sapply’ is a user-friendly version and wrapper of ‘lapply’ by
     default returning a vector, matrix or, if ‘simplify = "array"’, an
     array if appropriate, by applying ‘simplify2array()’.  ‘sapply(x,
     f, simplify = FALSE, USE.NAMES = FALSE)’ is the same as ‘lapply(x,
     f)’.

     ‘vapply’ is similar to ‘sapply’, but has a pre-specified type of
     return value, so it can be safer (and sometimes faster) to use.

     ‘replicate’ is a wrapper for the common use of ‘sapply’ for
     repeated evaluation of an expression (which will usually involve
     random number generation).

     ‘simplify2array()’ is the utility called from ‘sapply()’ when
     ‘simplify’ is not false and is similarly called from ‘mapply()’.

_U_s_a_g_e:

     lapply(X, FUN, ...)
     
     sapply(X, FUN, ..., simplify = TRUE, USE.NAMES = TRUE)
     
     vapply(X, FUN, FUN.VALUE, ..., USE.NAMES = TRUE)
     
     replicate(n, expr, simplify = "array")
     
     simplify2array(x, higher = TRUE)
     
_A_r_g_u_m_e_n_t_s:

       X: a vector (atomic or list) or an ‘expression’ object.  Other
          objects (including classed objects) will be coerced by
          ‘base::as.list’.

     FUN: the function to be applied to each element of ‘X’: see
          ‘Details’.  In the case of functions like ‘+’, ‘%*%’, the
          function name must be backquoted or quoted.

     ...: optional arguments to ‘FUN’.

simplify: logical or character string; should the result be simplified
          to a vector, matrix or higher dimensional array if possible?
          For ‘sapply’ it must be named and not abbreviated.  The
          default value, ‘TRUE’, returns a vector or matrix if
          appropriate, whereas if ‘simplify = "array"’ the result may
          be an ‘array’ of “rank” (=‘length(dim(.))’) one higher than
          the result of ‘FUN(X[[i]])’.

USE.NAMES: logical; if ‘TRUE’ and if ‘X’ is character, use ‘X’ as
          ‘names’ for the result unless it had names already.  Since
          this argument follows ‘...’ its name cannot be abbreviated.

FUN.VALUE: a (generalized) vector; a template for the return value from
          FUN.  See ‘Details’.

       n: integer: the number of replications.

    expr: the expression (a language object, usually a call) to
          evaluate repeatedly.

       x: a list, typically returned from ‘lapply()’.

  higher: logical; if true, ‘simplify2array()’ will produce a (“higher
          rank”) array when appropriate, whereas ‘higher = FALSE’ would
          return a matrix (or vector) only.  These two cases correspond
          to ‘sapply(*, simplify = "array")’ or ‘simplify = TRUE’,
          respectively.

_D_e_t_a_i_l_s:

     ‘FUN’ is found by a call to ‘match.fun’ and typically is specified
     as a function or a symbol (e.g., a backquoted name) or a character
     string specifying a function to be searched for from the
     environment of the call to ‘lapply’.

     Function ‘FUN’ must be able to accept as input any of the elements
     of ‘X’.  If the latter is an atomic vector, ‘FUN’ will always be
     passed a length-one vector of the same type as ‘X’.

     Arguments in ‘...’ cannot have the same name as any of the other
     arguments, and care may be needed to avoid partial matching to
     ‘FUN’.  In general-purpose code it is good practice to name the
     first two arguments ‘X’ and ‘FUN’ if ‘...’ is passed through: this
     both avoids partial matching to ‘FUN’ and ensures that a sensible
     error message is given if arguments named ‘X’ or ‘FUN’ are passed
     through ‘...’.

     Simplification in ‘sapply’ is only attempted if ‘X’ has length
     greater than zero and if the return values from all elements of
     ‘X’ are all of the same (positive) length.  If the common length
     is one the result is a vector, and if greater than one is a matrix
     with a column corresponding to each element of ‘X’.

     Simplification is always done in ‘vapply’.  This function checks
     that all values of ‘FUN’ are compatible with the ‘FUN.VALUE’, in
     that they must have the same length and type.  (Types may be
     promoted to a higher type within the ordering logical < integer <
     double < complex, but not demoted.)

     Users of S4 classes should pass a list to ‘lapply’ and ‘vapply’:
     the internal coercion is done by the ‘as.list’ in the base
     namespace and not one defined by a user (e.g., by setting S4
     methods on the base function).

_V_a_l_u_e:

     For ‘lapply’, ‘sapply(simplify = FALSE)’ and ‘replicate(simplify =
     FALSE)’, a list.

     For ‘sapply(simplify = TRUE)’ and ‘replicate(simplify = TRUE)’: if
     ‘X’ has length zero or ‘n = 0’, an empty list.  Otherwise an
     atomic vector or matrix or list of the same length as ‘X’ (of
     length ‘n’ for ‘replicate’).  If simplification occurs, the output
     type is determined from the highest type of the return values in
     the hierarchy NULL < raw < logical < integer < double < complex <
     character < list < expression, after coercion of pairlists to
     lists.

     ‘vapply’ returns a vector or array of type matching the
     ‘FUN.VALUE’.  If ‘length(FUN.VALUE) == 1’ a vector of the same
     length as ‘X’ is returned, otherwise an array.  If ‘FUN.VALUE’ is
     not an ‘array’, the result is a matrix with ‘length(FUN.VALUE)’
     rows and ‘length(X)’ columns, otherwise an array ‘a’ with ‘dim(a)
     == c(dim(FUN.VALUE), length(X))’.

     The (Dim)names of the array value are taken from the ‘FUN.VALUE’
     if it is named, otherwise from the result of the first function
     call.  Column names of the matrix or more generally the names of
     the last dimension of the array value or names of the vector value
     are set from ‘X’ as in ‘sapply’.

_N_o_t_e:

     ‘sapply(*, simplify = FALSE, USE.NAMES = FALSE)’ is equivalent to
     ‘lapply(*)’.

     For historical reasons, the calls created by ‘lapply’ are
     unevaluated, and code has been written (e.g., ‘bquote’) that
     relies on this.  This means that the recorded call is always of
     the form ‘FUN(X[[i]], ...)’, with ‘i’ replaced by the current
     (integer or double) index.  This is not normally a problem, but it
     can be if ‘FUN’ uses ‘sys.call’ or ‘match.call’ or if it is a
     primitive function that makes use of the call.  This means that it
     is often safer to call primitive functions with a wrapper, so that
     e.g. ‘lapply(ll, function(x) is.numeric(x))’ is required to ensure
     that method dispatch for ‘is.numeric’ occurs correctly.

     If ‘expr’ is a function call, be aware of assumptions about where
     it is evaluated, and in particular what ‘...’ might refer to.  You
     can pass additional named arguments to a function call as
     additional named arguments to ‘replicate’: see ‘Examples’.

_R_e_f_e_r_e_n_c_e_s:

     Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988) _The New S
     Language_.  Wadsworth & Brooks/Cole.

_S_e_e _A_l_s_o:

     ‘apply’, ‘tapply’, ‘mapply’ for applying a function to *m*ultiple
     arguments, and ‘rapply’ for a *r*ecursive version of ‘lapply()’,
     ‘eapply’ for applying a function to each entry in an
     ‘environment’.

_E_x_a_m_p_l_e_s:

     require(stats); require(graphics)
     
     x <- list(a = 1:10, beta = exp(-3:3), logic = c(TRUE,FALSE,FALSE,TRUE))
     # compute the list mean for each list element
     lapply(x, mean)
     # median and quartiles for each list element
     lapply(x, quantile, probs = 1:3/4)
     sapply(x, quantile)
     i39 <- sapply(3:9, seq) # list of vectors
     sapply(i39, fivenum)
     vapply(i39, fivenum,
            c(Min. = 0, "1st Qu." = 0, Median = 0, "3rd Qu." = 0, Max. = 0))
     
     ## sapply(*, "array") -- artificial example
     (v <- structure(10*(5:8), names = LETTERS[1:4]))
     f2 <- function(x, y) outer(rep(x, length.out = 3), y)
     (a2 <- sapply(v, f2, y = 2*(1:5), simplify = "array"))
     a.2 <- vapply(v, f2, outer(1:3, 1:5), y = 2*(1:5))
     stopifnot(dim(a2) == c(3,5,4), all.equal(a2, a.2),
               identical(dimnames(a2), list(NULL,NULL,LETTERS[1:4])))
     
     hist(replicate(100, mean(rexp(10))))
     
     ## use of replicate() with parameters:
     foo <- function(x = 1, y = 2) c(x, y)
     # does not work: bar <- function(n, ...) replicate(n, foo(...))
     bar <- function(n, x) replicate(n, foo(x = x))
     bar(5, x = 3)
     

> 
> help("for")             # or ?"for", but quotes/backticks are needed
Control                  package:base                  R Documentation

_C_o_n_t_r_o_l _F_l_o_w

_D_e_s_c_r_i_p_t_i_o_n:

     These are the basic control-flow constructs of the R language.
     They function in much the same way as control statements in any
     Algol-like language.  They are all reserved words.

_U_s_a_g_e:

     if(cond) expr
     if(cond) cons.expr  else  alt.expr
     
     for(var in seq) expr
     while(cond) expr
     repeat expr
     break
     next
     
_A_r_g_u_m_e_n_t_s:

    cond: A length-one logical vector that is not ‘NA’.  Conditions of
          length greater than one are currently accepted with a
          warning, but only the first element is used.  An error is
          signalled instead when the environment variable
          ‘_R_CHECK_LENGTH_1_CONDITION_’ is set to true.  Other types
          are coerced to logical if possible, ignoring any class.

     var: A syntactical name for a variable.

     seq: An expression evaluating to a vector (including a list and an
          expression) or to a pairlist or ‘NULL’.  A factor value will
          be coerced to a character vector.  As from R 4.0.0 this can
          be a long vector.

expr, cons.expr, alt.expr: An _expression_ in a formal sense.  This is
          either a simple expression or a so-called _compound
          expression_, usually of the form ‘{ expr1 ; expr2 }’.

_D_e_t_a_i_l_s:

     ‘break’ breaks out of a ‘for’, ‘while’ or ‘repeat’ loop; control
     is transferred to the first statement outside the inner-most loop.
     ‘next’ halts the processing of the current iteration and advances
     the looping index.  Both ‘break’ and ‘next’ apply only to the
     innermost of nested loops.

     Note that it is a common mistake to forget to put braces (‘{ ..
     }’) around your statements, e.g., after ‘if(..)’ or ‘for(....)’.
     In particular, you should not have a newline between ‘}’ and
     ‘else’ to avoid a syntax error in entering a ‘if ... else’
     construct at the keyboard or via ‘source’.  For that reason, one
     (somewhat extreme) attitude of defensive programming is to always
     use braces, e.g., for ‘if’ clauses.

     The ‘seq’ in a ‘for’ loop is evaluated at the start of the loop;
     changing it subsequently does not affect the loop.  If ‘seq’ has
     length zero the body of the loop is skipped. Otherwise the
     variable ‘var’ is assigned in turn the value of each element of
     ‘seq’. You can assign to ‘var’ within the body of the loop, but
     this will not affect the next iteration.  When the loop
     terminates, ‘var’ remains as a variable containing its latest
     value.

_V_a_l_u_e:

     ‘if’ returns the value of the expression evaluated, or ‘NULL’
     invisibly if none was (which may happen if there is no ‘else’).

     ‘for’, ‘while’ and ‘repeat’ return ‘NULL’ invisibly.  ‘for’ sets
     ‘var’ to the last used element of ‘seq’, or to ‘NULL’ if it was of
     length zero.

     ‘break’ and ‘next’ do not return a value as they transfer control
     within the loop.

_R_e_f_e_r_e_n_c_e_s:

     Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988) _The New S
     Language_.  Wadsworth & Brooks/Cole.

_S_e_e _A_l_s_o:

     ‘Syntax’ for the basic R syntax and operators, ‘Paren’ for
     parentheses and braces.

     ‘ifelse’, ‘switch’ for other ways to control flow.

_E_x_a_m_p_l_e_s:

     for(i in 1:5) print(1:i)
     for(n in c(2,5,10,20,50)) {
        x <- stats::rnorm(n)
        cat(n, ": ", sum(x^2), "\n", sep = "")
     }
     f <- factor(sample(letters[1:5], 10, replace = TRUE))
     for(i in unique(f)) print(i)
     

> 
> 
> topi <- "women"
> help(topi)
women                 package:datasets                 R Documentation

_A_v_e_r_a_g_e _H_e_i_g_h_t_s _a_n_d _W_e_i_g_h_t_s _f_o_r _A_m_e_r_i_c_a_n _W_o_m_e_n

_D_e_s_c_r_i_p_t_i_o_n:

     This data set gives the average heights and weights for American
     women aged 30-39.

_U_s_a_g_e:

     women
     
_F_o_r_m_a_t:

     A data frame with 15 observations on 2 variables.

       ‘[,1]’  ‘height’  numeric  Height (in)  
       ‘[,2]’  ‘weight’  numeric  Weight (lbs) 
      
_D_e_t_a_i_l_s:

     The data set appears to have been taken from the American Society
     of Actuaries _Build and Blood Pressure Study_ for some (unknown to
     us) earlier year.

     The World Almanac notes: “The figures represent weights in
     ordinary indoor clothing and shoes, and heights with shoes”.

_S_o_u_r_c_e:

     The World Almanac and Book of Facts, 1975.

_R_e_f_e_r_e_n_c_e_s:

     McNeil, D. R. (1977) _Interactive Data Analysis_.  Wiley.

_E_x_a_m_p_l_e_s:

     require(graphics)
     plot(women, xlab = "Height (in)", ylab = "Weight (lb)",
          main = "women data: American women aged 30-39")
     

> 
> try(help("bs", try.all.packages = FALSE)) # reports not found (an error)
No documentation for ‘bs’ in specified packages and libraries:
you could try ‘??bs’
> help("bs", try.all.packages = TRUE)       # reports can be found
Help for topic ‘bs’ is not in any loaded package but can be found in
the following packages:

  Package               Library
  splines               /usr/local/lib/R/library
>                                           # in package 'splines'
> 
> 
> 
> cleanEx()
> nameEx("help.search")
> ### * help.search
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: help.search
> ### Title: Search the Help System
> ### Aliases: help.search ?? print.hsearch
> ### Keywords: documentation
> 
> ### ** Examples
> 
> help.search("linear models")    # In case you forgot how to fit linear
Demos with name or title matching ‘linear models’ using fuzzy matching:


stats::lm.glm           Some linear and generalized linear modelling
                        examples from `An Introduction to Statistical
                        Modelling' by Annette Dobson


Type 'demo(PKG::FOO)' to run demonstration 'PKG::FOO'.



Help files with alias or concept or title matching ‘linear models’
using fuzzy matching:


boot::cv.glm            Cross-validation for Generalized Linear Models
boot::glm.diag          Generalized Linear Model Diagnostics
boot::glm.diag.plots    Diagnostics plots for generalized linear models
MASS::boxcox            Box-Cox Transformations for Linear Models
MASS::glm.nb            Fit a Negative Binomial Generalized Linear
                        Model
MASS::lm.gls            Fit Linear Models by Generalized Least Squares
MASS::loglm             Fit Log-Linear Models by Iterative Proportional
                        Scaling
MASS::loglm1            Fit Log-Linear Models by Iterative Proportional
                        Scaling - Internal function
MASS::rlm               Robust Fitting of Linear Models
MASS::stdres            Extract Standardized Residuals from a Linear
                        Model
MASS::studres           Extract Studentized Residuals from a Linear
                        Model
MASS::summary.rlm       Summary Method for Robust Linear Models
mgcv::bam               Generalized additive models for very large
                        datasets
  Concepts: Functional linear model
mgcv::bam.update        Update a strictly additive bam model for new
                        data.
  Concepts: Functional linear model
mgcv::gam               Generalized additive models with integrated
                        smoothness estimation
  Concepts: Functional linear model
mgcv::jagam             Just Another Gibbs Additive Modeller: JAGS
                        support for mgcv.
  Concepts: Functional linear model
nlme::gls               Fit Linear Model Using Generalized Least
                        Squares
nlme::gnls              Fit Nonlinear Model Using Generalized Least
                        Squares
nlme::recalc            Recalculate Condensed Linear Model Object
nnet::multinom          Fit Multinomial Log-linear Models
stats::anova.glm        Analysis of Deviance for Generalized Linear
                        Model Fits
stats::anova.lm         ANOVA for Linear Model Fits
stats::anova.mlm        Comparisons between Multivariate Linear Models
stats::family.glm       Accessing Generalized Linear Model Fits
stats::family.lm        Accessing Linear Model Fits
stats::glm              Fitting Generalized Linear Models
stats::lm               Fitting Linear Models
stats::lm.fit           Fitter Functions for Linear Models
stats::loglin           Fitting Log-Linear Models
stats::predict.lm       Predict method for Linear Model Fits
stats::selfStart        Construct Self-starting Nonlinear Models
stats::summary.glm      Summarizing Generalized Linear Model Fits
stats::summary.lm       Summarizing Linear Model Fits


Type '?PKG::FOO' to inspect entries 'PKG::FOO', or 'TYPE?PKG::FOO' for
entries like 'PKG::FOO-TYPE'.




>                                 # models
> help.search("non-existent topic")
No vignettes or demos or help files found with alias or concept or
title matching ‘non-existent topic’ using fuzzy matching.
> 
> ??utils::help  # All the topics matching "help" in the utils package
Help files with alias or concept or title matching ‘help’ using regular
expression matching:


utils::example          Run an Examples Section from the Online Help
utils::help             Documentation
  Aliases: help
utils::help.request     Send a Post to R-help
  Aliases: help.request
utils::help.search      Search the Help System
  Aliases: help.search
utils::help.start       Hypertext Documentation
  Aliases: help.start
utils::hsearch_db       Help Search Utilities


Type '?PKG::FOO' to inspect entries 'PKG::FOO', or 'TYPE?PKG::FOO' for
entries like 'PKG::FOO-TYPE'.




> 
> 
> 
> cleanEx()
> nameEx("help.start")
> ### * help.start
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: help.start
> ### Title: Hypertext Documentation
> ### Aliases: help.start
> ### Keywords: documentation
> 
> ### ** Examples
> 
> ## Not run: 
> ##D if(.Platform$OS.type == "unix") # includes Mac
> ##D   ## the 'remote' arg can be tested by
> ##D   help.start(remote = paste0("file://", R.home()))
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("hsearch-utils")
> ### * hsearch-utils
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: hsearch-utils
> ### Title: Help Search Utilities
> ### Aliases: hsearch_db hsearch_db_concepts hsearch_db_keywords
> ### Keywords: documentation
> 
> ### ** Examples
> 
> db <- hsearch_db()
> ## Total numbers of documentation objects, aliases, keywords and
> ## concepts (using the current format):
> sapply(db, NROW)
    Base  Aliases Keywords Concepts 
    3846    11388     3634     3912 
> ## Can also be obtained from print method:
> db
A help search database:
Objects: 3846, Aliases: 11388, Keywords: 3634, Concepts: 3912
> ## 10 most frequent concepts:
> head(hsearch_db_concepts(), 10)
                            Concept Frequency Packages
1                Statistical Models       507       10
2      Datasets available by data()       340       20
3                         Utilities       258       12
4  Computations Related to Plotting       193        9
5                        Regression       187        6
6                       Programming       140        9
7               Data Types (not OO)       138        5
8     Curve (and Surface) Smoothing       114        6
9                 Survival Analysis        97        2
10                 High-Level Plots        94       11
> ## 10 most frequent keywords:
> head(hsearch_db_keywords(), 10)
       Keyword                            Concept Frequency Packages
1       models                 Statistical Models       507       10
2     datasets       Datasets available by data()       340       20
3    utilities                          Utilities       258       12
4     internal Internal Objects (not part of API)       250       31
5        dplot   Computations Related to Plotting       193        9
6   regression                         Regression       187        6
7  programming                        Programming       140        9
8      classes                Data Types (not OO)       138        5
9       smooth      Curve (and Surface) Smoothing       114        6
10    survival                  Survival Analysis        97        2
> 
> 
> 
> cleanEx()
> nameEx("install.packages")
> ### * install.packages
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: install.packages
> ### Title: Install Packages from Repositories or Local Files
> ### Aliases: install.packages
> ### Keywords: utilities
> 
> ### ** Examples
> ## Not run: 
> ##D ## A Linux example for Fedora's layout of udunits2 headers.
> ##D install.packages(c("ncdf4", "RNetCDF"),
> ##D   configure.args = c(RNetCDF = "--with-netcdf-include=/usr/include/udunits2"))
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("installed.packages")
> ### * installed.packages
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: installed.packages
> ### Title: Find Installed Packages
> ### Aliases: installed.packages
> ### Keywords: utilities
> 
> ### ** Examples
> 
> ## confine search to .Library for speed
> str(ip <- installed.packages(.Library, priority = "high"))
 chr [1:29, 1:16] "base" "boot" "class" "cluster" "codetools" "compiler" ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:29] "base" "boot" "class" "cluster" ...
  ..$ : chr [1:16] "Package" "LibPath" "Version" "Priority" ...
> ip[, c(1,3:5)]
           Package      Version   Priority     
base       "base"       "4.0.3"   "base"       
boot       "boot"       "1.3-25"  "recommended"
class      "class"      "7.3-17"  "recommended"
cluster    "cluster"    "2.1.0"   "recommended"
codetools  "codetools"  "0.2-16"  "recommended"
compiler   "compiler"   "4.0.3"   "base"       
datasets   "datasets"   "4.0.3"   "base"       
foreign    "foreign"    "0.8-80"  "recommended"
graphics   "graphics"   "4.0.3"   "base"       
grDevices  "grDevices"  "4.0.3"   "base"       
grid       "grid"       "4.0.3"   "base"       
KernSmooth "KernSmooth" "2.23-17" "recommended"
lattice    "lattice"    "0.20-41" "recommended"
MASS       "MASS"       "7.3-53"  "recommended"
Matrix     "Matrix"     "1.2-18"  "recommended"
methods    "methods"    "4.0.3"   "base"       
mgcv       "mgcv"       "1.8-33"  "recommended"
nlme       "nlme"       "3.1-149" "recommended"
nnet       "nnet"       "7.3-14"  "recommended"
parallel   "parallel"   "4.0.3"   "base"       
rpart      "rpart"      "4.1-15"  "recommended"
spatial    "spatial"    "7.3-12"  "recommended"
splines    "splines"    "4.0.3"   "base"       
stats      "stats"      "4.0.3"   "base"       
stats4     "stats4"     "4.0.3"   "base"       
survival   "survival"   "3.2-7"   "recommended"
tcltk      "tcltk"      "4.0.3"   "base"       
tools      "tools"      "4.0.3"   "base"       
utils      "utils"      "4.0.3"   "base"       
           Depends                                          
base       NA                                               
boot       "R (>= 3.0.0), graphics, stats"                  
class      "R (>= 3.0.0), stats, utils"                     
cluster    "R (>= 3.3.0)"                                   
codetools  "R (>= 2.1)"                                     
compiler   NA                                               
datasets   NA                                               
foreign    "R (>= 4.0.0)"                                   
graphics   NA                                               
grDevices  NA                                               
grid       NA                                               
KernSmooth "R (>= 2.5.0), stats"                            
lattice    "R (>= 3.0.0)"                                   
MASS       "R (>= 3.1.0), grDevices, graphics, stats, utils"
Matrix     "R (>= 3.2.0)"                                   
methods    NA                                               
mgcv       "R (>= 2.14.0), nlme (>= 3.1-64)"                
nlme       "R (>= 3.4.0)"                                   
nnet       "R (>= 3.0.0), stats, utils"                     
parallel   NA                                               
rpart      "R (>= 2.15.0), graphics, stats, grDevices"      
spatial    "R (>= 3.0.0), graphics, stats, utils"           
splines    NA                                               
stats      NA                                               
stats4     NA                                               
survival   "R (>= 3.4.0)"                                   
tcltk      NA                                               
tools      NA                                               
utils      NA                                               
> plic <- installed.packages(.Library, priority = "high", fields = "License")
> ## what licenses are there:
> table( plic[, "License"] )

                      GPL                GPL (>= 2) GPL (>= 2) | file LICENCE 
                        1                         4                         2 
            GPL-2 | GPL-3               LGPL (>= 2)           Part of R 4.0.3 
                        5                         1                        14 
                Unlimited 
                        2 
> 
> 
> 
> cleanEx()
> nameEx("isS3method")
> ### * isS3method
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: isS3method
> ### Title: Is 'method' the Name of an S3 Method?
> ### Aliases: isS3method
> ### Keywords: methods
> 
> ### ** Examples
> 
> isS3method("t")           # FALSE - it is an S3 generic
[1] FALSE
> isS3method("t.default")   # TRUE
[1] TRUE
> isS3method("t.ts")        # TRUE
[1] TRUE
> isS3method("t.test")      # FALSE
[1] FALSE
> isS3method("t.data.frame")# TRUE
[1] TRUE
> isS3method("t.lm")        # FALSE - not existing
[1] FALSE
> isS3method("t.foo.bar")   # FALSE - not existing
[1] FALSE
> 
> ## S3 methods with "4 parts" in their name:
> ff <- c("as.list", "as.matrix", "is.na", "row.names", "row.names<-")
> for(m in ff) if(isS3method(m)) stop("wrongly declared an S3 method: ", m)
> (m4 <- paste(ff, "data.frame", sep="."))
[1] "as.list.data.frame"     "as.matrix.data.frame"   "is.na.data.frame"      
[4] "row.names.data.frame"   "row.names<-.data.frame"
> for(m in m4) if(!isS3method(m)) stop("not an S3 method: ", m)
> ## Don't show: 
> stopifnot(
+   !isS3method("t"), !isS3method("t.test"), !isS3method("qr.coef"), !isS3method("sort.list"),
+   isS3method("t.default"), isS3method("t.ts"), isS3method("t.data.frame"),
+   !isS3method("t.lm"), !isS3method("t.foo.bar"))
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("localeToCharset")
> ### * localeToCharset
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: localeToCharset
> ### Title: Select a Suitable Encoding Name from a Locale Name
> ### Aliases: localeToCharset
> ### Keywords: utilities
> 
> ### ** Examples
> 
> localeToCharset()
[1] "UTF-8"     "ISO8859-1"
> 
> 
> 
> cleanEx()
> nameEx("ls_str")
> ### * ls_str
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ls.str
> ### Title: List Objects and their Structure
> ### Aliases: ls.str lsf.str print.ls_str
> ### Keywords: print utilities
> 
> ### ** Examples
> 
> require(stats)
> 
> lsf.str()  #- how do the functions look like which I am using?
> ls.str(mode = "list")   #- what are the structured objects I have defined?
> 
> ## create a few objects
> example(glm, echo = FALSE)
> ll <- as.list(LETTERS)
> print(ls.str(), max.level = 0)# don't show details
A0 :  num 56.8
A1 :  num 56.8
A2 :  num 56.8
clotting : 'data.frame':	9 obs. of  3 variables:
counts :  num [1:9] 18 17 15 20 10 20 25 13 12
fS : List of 30
glm.D93 : List of 30
ll : List of 26
outcome :  Factor w/ 3 levels "1","2","3": 1 2 3 1 2 3 1 2 3
treatment :  Factor w/ 3 levels "1","2","3": 1 1 1 2 2 2 3 3 3
> 
> ## which base functions have "file" in their name ?
> lsf.str(pos = length(search()), pattern = "file")
bzfile : function (description, open = "", encoding = getOption("encoding"), compression = 9)  
close.srcfile : function (con, ...)  
close.srcfilealias : function (con, ...)  
env.profile : function (env)  
file : function (description = "", open = "", blocking = TRUE, encoding = getOption("encoding"), 
    raw = FALSE, method = getOption("url.method", "default"))  
file.access : function (names, mode = 0)  
file.append : function (file1, file2)  
file.choose : function (new = FALSE)  
file.copy : function (from, to, overwrite = recursive, recursive = FALSE, copy.mode = TRUE, 
    copy.date = FALSE)  
file.create : function (..., showWarnings = TRUE)  
file.exists : function (...)  
file.info : function (..., extra_cols = TRUE)  
file.link : function (from, to)  
file.mode : function (...)  
file.mtime : function (...)  
file.path : function (..., fsep = .Platform$file.sep)  
file.remove : function (...)  
file.rename : function (from, to)  
file.show : function (..., header = rep("", nfiles), title = "R Information", delete.file = FALSE, 
    pager = getOption("pager"), encoding = "")  
file.size : function (...)  
file.symlink : function (from, to)  
gzfile : function (description, open = "", encoding = getOption("encoding"), compression = 6)  
list.files : function (path = ".", pattern = NULL, all.files = FALSE, full.names = FALSE, 
    recursive = FALSE, ignore.case = FALSE, include.dirs = FALSE, no.. = FALSE)  
memory.profile : function ()  
nullfile : function ()  
open.srcfile : function (con, line, ...)  
open.srcfilealias : function (con, line, ...)  
open.srcfilecopy : function (con, line, ...)  
print.srcfile : function (x, ...)  
srcfile : function (filename, encoding = getOption("encoding"), Enc = "unknown")  
srcfilealias : function (filename, srcfile)  
srcfilecopy : function (filename, lines, timestamp = Sys.time(), isFile = FALSE)  
summary.srcfile : function (object, ...)  
system.file : function (..., package = "base", lib.loc = NULL, mustWork = FALSE)  
tempfile : function (pattern = "file", tmpdir = tempdir(), fileext = "")  
xzfile : function (description, open = "", encoding = getOption("encoding"), compression = 6)  
> 
> ## demonstrating that  ls.str() works inside functions
> ## ["browser/debug mode"]:
> tt <- function(x, y = 1) { aa <- 7; r <- x + y; ls.str() }
> (nms <- sapply(strsplit(capture.output(tt(2))," *: *"), `[`, 1))
[1] "aa" "r"  "x"  "y" 
> stopifnot(nms == c("aa", "r","x","y"))
> 
> 
> 
> cleanEx()
> nameEx("maintainer")
> ### * maintainer
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: maintainer
> ### Title: Show Package Maintainer
> ### Aliases: maintainer
> ### Keywords: utilities
> 
> ### ** Examples
> 
> maintainer("MASS")
[1] "Brian Ripley <ripley@stats.ox.ac.uk>"
> 
> 
> 
> cleanEx()
> nameEx("make.packages.html")
> ### * make.packages.html
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: make.packages.html
> ### Title: Update HTML Package List
> ### Aliases: make.packages.html
> ### Keywords: utilities
> 
> ### ** Examples
> ## Not run: 
> ##D make.packages.html()
> ##D # this can be slow for large numbers of installed packages.
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("make.socket")
> ### * make.socket
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: make.socket
> ### Title: Create a Socket Connection
> ### Aliases: make.socket print.socket
> ### Keywords: misc
> 
> ### ** Examples
> 
> daytime <- function(host = "localhost"){
+     a <- make.socket(host, 13)
+     on.exit(close.socket(a))
+     read.socket(a)
+ }
> ## Official time (UTC) from US Naval Observatory
> ## Not run: daytime("tick.usno.navy.mil")
> 
> 
> 
> cleanEx()
> nameEx("memory.size")
> ### * memory.size
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: memory.size
> ### Title: Report on Memory Allocation (on Windows)
> ### Aliases: memory.size memory.limit
> ### Keywords: utilities
> 
> ### ** Examples
> 
> if(.Platform$OS.type == "windows") withAutoprint({
+ memory.size()
+ memory.size(TRUE)
+ memory.limit()
+ })
> 
> 
> 
> cleanEx()
> nameEx("menu")
> ### * menu
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: menu
> ### Title: Menu Interaction Function
> ### Aliases: menu
> ### Keywords: utilities programming
> 
> ### ** Examples
> 
> ## Not run: 
> ##D switch(menu(c("List letters", "List LETTERS")) + 1,
> ##D        cat("Nothing done\n"), letters, LETTERS)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("methods")
> ### * methods
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: methods
> ### Title: List Methods for S3 Generic Functions or Classes
> ### Aliases: .S3methods methods format.MethodsFunction
> ###   print.MethodsFunction
> ### Keywords: methods
> 
> ### ** Examples
> 
> methods(class = "MethodsFunction") # format and print
[1] format print 
see '?methods' for accessing help and source code
> 
> require(stats)
> 
> methods(summary)
 [1] summary.aov                    summary.aovlist*              
 [3] summary.aspell*                summary.check_packages_in_dir*
 [5] summary.connection             summary.data.frame            
 [7] summary.Date                   summary.default               
 [9] summary.ecdf*                  summary.factor                
[11] summary.glm                    summary.infl*                 
[13] summary.lm                     summary.loess*                
[15] summary.manova                 summary.matrix                
[17] summary.mlm*                   summary.nls*                  
[19] summary.packageStatus*         summary.POSIXct               
[21] summary.POSIXlt                summary.ppr*                  
[23] summary.prcomp*                summary.princomp*             
[25] summary.proc_time              summary.srcfile               
[27] summary.srcref                 summary.stepfun               
[29] summary.stl*                   summary.table                 
[31] summary.tukeysmooth*           summary.warnings              
see '?methods' for accessing help and source code
> methods(class = "aov")    # S3 class
 [1] coef         coerce       extractAIC   initialize   model.tables
 [6] print        proj         se.contrast  show         slotsFromS3 
[11] summary      TukeyHSD     vcov        
see '?methods' for accessing help and source code
> ## The same, with more details and more difficult to read:
> print(methods(class = "aov"), byclass=FALSE)
 [1] coef.aov*                   coerce,oldClass,S3-method  
 [3] extractAIC.aov*             initialize,oldClass-method 
 [5] model.tables.aov*           print.aov*                 
 [7] proj.aov*                   se.contrast.aov*           
 [9] show,oldClass-method        slotsFromS3,oldClass-method
[11] summary.aov                 TukeyHSD.aov*              
[13] vcov.aov*                  
see '?methods' for accessing help and source code
> methods("[[")             # uses C-internal dispatching
[1] [[.bibentry*       [[.data.frame      [[.Date            [[.dendrogram*    
[5] [[.factor          [[.numeric_version [[.person*         [[.POSIXct        
[9] [[.POSIXlt        
see '?methods' for accessing help and source code
> methods("$")
[1] $,envRefClass-method        $,refObjectGenerator-method
[3] $.bibentry*                 $.DLLInfo                  
[5] $.package_version           $.person*                  
see '?methods' for accessing help and source code
> methods("$<-")            # replacement function
[1] $<-,data.frame-method         $<-,envRefClass-method       
[3] $<-,localRefClass-method      $<-,refObjectGenerator-method
[5] $<-.bibentry*                 $<-.data.frame               
[7] $<-.person*                  
see '?methods' for accessing help and source code
> methods("+")              # binary operator
[1] +.Date   +.POSIXt
see '?methods' for accessing help and source code
> methods("Math")           # group generic
[1] Math,nonStructure-method Math,structure-method    Math.data.frame         
[4] Math.Date                Math.difftime            Math.factor             
[7] Math.POSIXt             
see '?methods' for accessing help and source code
> require(graphics)
> methods(axis)             # looks like a generic, but is not
Warning in .S3methods(generic.function, class, envir) :
  function 'axis' appears not to be S3 generic; found functions that look like S3 methods
[1] axis.Date    axis.POSIXct
see '?methods' for accessing help and source code
> 
> mf <- methods(format)     # quite a few; ... the last few :
> tail(cbind(meth = format(mf)))
      meth                                 
[63,] "format.POSIXlt"                     
[64,] "format.roman*"                      
[65,] "format.subdir_tests*"               
[66,] "format.summarize_CRAN_check_status*"
[67,] "format.summaryDefault"              
[68,] "format.undoc*"                      
> 
> if(require(Matrix)) {
+ print(methods(class = "Matrix"))  # S4 class
+ m <- methods(dim)         # S3 and S4 methods
+ print(m)
+ print(attr(m, "info"))    # more extensive information
+ 
+ ## --> help(showMethods) for related examples
+ }
Loading required package: Matrix
 [1] -           !           [           [<-         *           /          
 [7] &           %*%         %/%         %&%         %%          ^          
[13] +           all         all.equal   any         Arith       as.array   
[19] as.logical  as.matrix   as.numeric  as.vector   cbind2      chol       
[25] Cholesky    coerce      cov2cor     crossprod   determinant diag       
[31] diff        dim         dimnames    dimnames<-  drop        expm       
[37] head        image       initialize  kronecker   length      Logic      
[43] Math2       mean        norm        Ops         qr.coef     qr.fitted  
[49] qr.qty      qr.qy       qr.resid    rbind2      rcond       rep        
[55] skewpart    solve       Summary     symmpart    t           tail       
[61] tcrossprod  unname      updown     
see '?methods' for accessing help and source code
[1] dim,Matrix-method              dim,MatrixFactorization-method
[3] dim.data.frame                 dim.layout*                   
[5] dim.trellis*                  
see '?methods' for accessing help and source code
                               visible                        from generic
dim,Matrix-method                 TRUE                      Matrix     dim
dim,MatrixFactorization-method    TRUE                      Matrix     dim
dim.data.frame                    TRUE                        base     dim
dim.layout                       FALSE registered S3method for dim     dim
dim.trellis                      FALSE registered S3method for dim     dim
                                isS4
dim,Matrix-method               TRUE
dim,MatrixFactorization-method  TRUE
dim.data.frame                 FALSE
dim.layout                     FALSE
dim.trellis                    FALSE
> 
> 
> 
> cleanEx()

detaching ‘package:Matrix’

> nameEx("modifyList")
> ### * modifyList
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: modifyList
> ### Title: Recursively Modify Elements of a List
> ### Aliases: modifyList
> ### Keywords: utilities
> 
> ### ** Examples
> 
> foo <- list(a = 1, b = list(c = "a", d = FALSE))
> bar <- modifyList(foo, list(e = 2, b = list(d = TRUE)))
> str(foo)
List of 2
 $ a: num 1
 $ b:List of 2
  ..$ c: chr "a"
  ..$ d: logi FALSE
> str(bar)
List of 3
 $ a: num 1
 $ b:List of 2
  ..$ c: chr "a"
  ..$ d: logi TRUE
 $ e: num 2
> 
> 
> 
> cleanEx()
> nameEx("news")
> ### * news
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: news
> ### Title: Build and Query R or Package News Information
> ### Aliases: news print.news_db
> 
> ### ** Examples
> 
> ## Build a db of all R news entries.
> db <- news()
> ## Don't show: 
>   vv <- capture.output(print(db, doBrowse=FALSE))  # without an error
>   stopifnot(is.character(vv), length(vv) >= 3) # was wrong (for weeks during devel.)
> ## End(Don't show)
> ## Bug fixes with PR number in 4.0.0.
> db4 <- news(Version == "4.0.0" & grepl("^BUG", Category) & grepl("PR#", Text),
+             db = db)
> nrow(db4)
[1] 25
> 
> ## print db4 to show in an HTML browser.
> 
> ## News from a date range ('Matrix' is there in a regular R installation):
> if(length(iM <- find.package("Matrix", quiet = TRUE)) && nzchar(iM)) {
+    dM <- news(package="Matrix")
+    stopifnot(identical(dM, news(db=dM)))
+    dM2014 <- news("2014-01-01" <= Date & Date <= "2014-12-31", db = dM)
+    stopifnot(paste0("1.1-", 2:4) %in% dM2014[,"Version"])
+ }
> 
> ## Which categories have been in use? % R-core maybe should standardize a bit more
> sort(table(db[, "Category"]), decreasing = TRUE)

                             BUG FIXES                           NEW FEATURES 
                                    81                                     70 
                   BUG FIXES (Windows)                 DEPRECATED AND DEFUNCT 
                                     7                                      7 
          INSTALLATION on a UNIX-ALIKE                                Windows 
                                     6                                      6 
      SIGNIFICANT USER-VISIBLE CHANGES                     C-LEVEL FACILITIES 
                                     5                                      4 
                    MIGRATION TO PCRE2                              UTILITIES 
                                     4                                      4 
LINK-TIME OPTIMIZATION on a UNIX-ALIKE                   PACKAGE INSTALLATION 
                                     3                                      1 
                    REFERENCE COUNTING 
                                     1 
> ## Entries with version >= 4.0.0
> table(news(Version >= "4.0.0", db = db)$Version)

4.0.0 4.0.1 4.0.2 4.0.3 
  156    11     6    26 
> 
> 
> 
> 
> cleanEx()
> nameEx("nsl")
> ### * nsl
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: nsl
> ### Title: Look up the IP Address by Hostname (on Unix-alikes)
> ### Aliases: nsl
> ### Keywords: utilities
> 
> ### ** Examples
> 
> if(.Platform$OS.type == "unix") # includes Mac
+   print( nsl("www.r-project.org") )
[1] "137.208.57.37"
> 
> 
> 
> cleanEx()
> nameEx("object.size")
> ### * object.size
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: object.size
> ### Title: Report the Space Allocated for an Object
> ### Aliases: object.size format.object_size print.object_size
> ### Keywords: utilities
> 
> ### ** Examples
> 
> object.size(letters)
1712 bytes
> object.size(ls)
89880 bytes
> format(object.size(library), units = "auto")
[1] "1.8 Mb"
> 
> sl <- object.size(rep(letters, 1000))
> 
> print(sl)                                    ## 209288 bytes
209504 bytes
> print(sl, units = "auto")                    ## 204.4 Kb
204.6 Kb
> print(sl, units = "auto", standard = "IEC")  ## 204.4 KiB
204.6 KiB
> print(sl, units = "auto", standard = "SI")   ## 209.3 kB
209.5 kB
> 
> (fsl <- sapply(c("Kb", "KB", "KiB"),
+                function(u) format(sl, units = u)))
         Kb          KB         KiB 
 "204.6 Kb"  "204.6 Kb" "204.6 KiB" 
> stopifnot(identical( ## assert that all three are the same :
+              unique(substr(as.vector(fsl), 1,5)),
+              format(round(as.vector(sl)/1024, 1))))
> 
> ## find the 10 largest objects in the base package
> z <- sapply(ls("package:base"), function(x)
+             object.size(get(x, envir = baseenv())))
> if(interactive()) {
+ as.matrix(rev(sort(z))[1:10])
+ } else # (more constant over time):
+     names(rev(sort(z))[1:10])
 [1] "loadNamespace"      "library"            "[<-.data.frame"    
 [4] "parseNamespaceFile" "rbind.data.frame"   "seq.default"       
 [7] "source"             "merge.data.frame"   "registerS3methods" 
[10] "data.frame"        
> 
> 
> 
> cleanEx()
> nameEx("package.skeleton")
> ### * package.skeleton
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: package.skeleton
> ### Title: Create a Skeleton for a New Source Package
> ### Aliases: package.skeleton
> ### Keywords: file utilities
> 
> ### ** Examples
> 
> require(stats)
> ## two functions and two "data sets" :
> f <- function(x, y) x+y
> g <- function(x, y) x-y
> d <- data.frame(a = 1, b = 2)
> e <- rnorm(1000)
> ## Don't show: 
>   owd <- getwd()
>   setwd(tempdir())
> ## End(Don't show)
> package.skeleton(list = c("f","g","d","e"), name = "mypkg")
Creating directories ...
Creating DESCRIPTION ...
Creating NAMESPACE ...
Creating Read-and-delete-me ...
Saving functions and data ...
Making help files ...
Done.
Further steps are described in './mypkg/Read-and-delete-me'.
> ## Don't show: 
>  setwd(owd) 
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("packageDescription")
> ### * packageDescription
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: packageDescription
> ### Title: Package Description
> ### Aliases: packageDescription packageVersion packageDate asDateBuilt
> ###   print.packageDescription
> ### Keywords: utilities
> 
> ### ** Examples
> pu <- packageDate("utils")
> stopifnot(identical(pu, packageDate(desc = packageDescription("utils"))),
+           identical(pu, packageDate("stats"))) # as "utils" and "stats" are
>                                    # both 'base R' and "Built" at same time
> 
> 
> 
> cleanEx()
> nameEx("packageName")
> ### * packageName
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: packageName
> ### Title: Find Package Associated with an Environment
> ### Aliases: packageName
> ### Keywords: utilities
> 
> ### ** Examples
> 
> packageName()
> packageName(environment(mean))
[1] "base"
> 
> 
> 
> cleanEx()
> nameEx("packageStatus")
> ### * packageStatus
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: packageStatus
> ### Title: Package Management Tools
> ### Aliases: packageStatus print.packageStatus summary.packageStatus
> ###   update.packageStatus upgrade.packageStatus upgrade
> ### Keywords: utilities
> 
> ### ** Examples
> 
> ## Not run: 
> ##D x <- packageStatus()
> ##D print(x)
> ##D summary(x)
> ##D upgrade(x)
> ##D x <- update(x)
> ##D print(x)
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("page")
> ### * page
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: page
> ### Title: Invoke a Pager on an R Object
> ### Aliases: page
> ### Keywords: utilities
> 
> ### ** Examples
> ## Not run: 
> ##D ## four ways to look at the code of 'page'
> ##D page(page)             # as an object
> ##D page("page")           # a character string
> ##D v <- "page"; page(v)   # a length-one character vector
> ##D page(utils::page)      # a call
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("person")
> ### * person
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: person
> ### Title: Persons
> ### Aliases: person as.person as.person.default [.person $.person
> ###   as.character.person c.person format.person print.person
> ###   toBibtex.person personList as.personList as.personList.person
> ###   as.personList.default
> ### Keywords: misc
> 
> ### ** Examples
> 
> ## Create a person object directly ...
> p1 <- person("Karl", "Pearson", email = "pearson@stats.heaven")
> 
> ## ... or convert a string.
> p2 <- as.person("Ronald Aylmer Fisher")
> 
> ## Combining and subsetting.
> p <- c(p1, p2)
> p[1]
[1] "Karl Pearson <pearson@stats.heaven>"
> p[-1]
[1] "Ronald Aylmer Fisher"
> 
> ## Extracting fields.
> p$family
[[1]]
[1] "Pearson"

[[2]]
[1] "Fisher"

> p$email
[[1]]
[1] "pearson@stats.heaven"

[[2]]
NULL

> p[1]$email
[1] "pearson@stats.heaven"
> 
> ## Specifying package authors, example from "boot":
> ## AC is the first author [aut] who wrote the S original.
> ## BR is the second author [aut], who translated the code to R [trl],
> ## and maintains the package [cre].
> b <- c(person("Angelo", "Canty", role = "aut", comment =
+          "S original, <http://statwww.epfl.ch/davison/BMA/library.html>"),
+        person(c("Brian", "D."), "Ripley", role = c("aut", "trl", "cre"),
+               comment = "R port", email = "ripley@stats.ox.ac.uk")
+      )
> b
[1] "Angelo Canty [aut] (S original, <http://statwww.epfl.ch/davison/BMA/library.html>)"
[2] "Brian D. Ripley <ripley@stats.ox.ac.uk> [aut, trl, cre] (R port)"                  
> 
> ## Formatting.
> format(b)
[1] "Angelo Canty [aut] (S original, <http://statwww.epfl.ch/davison/BMA/library.html>)"
[2] "Brian D. Ripley <ripley@stats.ox.ac.uk> [aut, trl, cre] (R port)"                  
> format(b, include = c("family", "given", "role"),
+    braces = list(family = c("", ","), role = c("(Role(s): ", ")")))
[1] "Canty, Angelo (Role(s): aut)"             
[2] "Ripley, Brian D. (Role(s): aut, trl, cre)"
> 
> ## Conversion to BibTeX author field.
> paste(format(b, include = c("given", "family")), collapse = " and ")
[1] "Angelo Canty and Brian D. Ripley"
> toBibtex(b)
[1] "Canty, Angelo and Ripley, Brian D."
> 
> ## ORCID identifiers.
> (p3 <- person("Achim", "Zeileis",
+               comment = c(ORCID = "0000-0003-0918-3766")))
[1] "Achim Zeileis (<https://orcid.org/0000-0003-0918-3766>)"
> 
> 
> 
> cleanEx()
> nameEx("prompt")
> ### * prompt
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: prompt
> ### Title: Produce Prototype of an R Documentation File
> ### Aliases: prompt prompt.default prompt.data.frame promptImport
> ### Keywords: documentation
> 
> ### ** Examples
> 
> require(graphics)
> ## Don't show: 
> oldwd <- setwd(tempdir())
> ## End(Don't show)
> prompt(plot.default)
Created file named ‘plot.default.Rd’.
Edit the file and move it to the appropriate directory.
> prompt(interactive, force.function = TRUE)
Created file named ‘interactive.Rd’.
Edit the file and move it to the appropriate directory.
> unlink("plot.default.Rd")
> unlink("interactive.Rd")
> 
> prompt(women) # data.frame
Created file named ‘women.Rd’.
Edit the file and move it to the appropriate directory.
> unlink("women.Rd")
> 
> prompt(sunspots) # non-data.frame data
Created file named ‘sunspots.Rd’.
Edit the file and move it to the appropriate directory.
> unlink("sunspots.Rd")
> 
> ## Don't show: 
> setwd(oldwd)
> ## End(Don't show)
> ## Not run: 
> ##D ## Create a help file for each function in the .GlobalEnv:
> ##D for(f in ls()) if(is.function(get(f))) prompt(name = f)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("promptData")
> ### * promptData
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: promptData
> ### Title: Generate Outline Documentation for a Data Set
> ### Aliases: promptData
> ### Keywords: documentation
> 
> ### ** Examples
> 
> ## Don't show: 
> oldwd <- setwd(tempdir())
> ## End(Don't show)
> promptData(sunspots)
Created file named ‘sunspots.Rd’.
Edit the file and move it to the appropriate directory.
> unlink("sunspots.Rd")
> ## Don't show: 
> setwd(oldwd)
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("promptPackage")
> ### * promptPackage
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: promptPackage
> ### Title: Generate a Shell for Documentation of a Package
> ### Aliases: promptPackage
> ### Keywords: documentation
> 
> ### ** Examples
> 
> 
> cleanEx()
> nameEx("read.DIF")
> ### * read.DIF
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: read.DIF
> ### Title: Data Input from Spreadsheet
> ### Aliases: read.DIF
> ### Keywords: file connection
> 
> ### ** Examples
> 
> ## read.DIF() may need transpose = TRUE for a file exported from Excel
> udir <- system.file("misc", package = "utils")
> dd <- read.DIF(file.path(udir, "exDIF.dif"), header = TRUE, transpose = TRUE)
> dc <- read.csv(file.path(udir, "exDIF.csv"), header = TRUE)
> stopifnot(identical(dd, dc), dim(dd) == c(4,2))
> 
> 
> 
> cleanEx()
> nameEx("read.fortran")
> ### * read.fortran
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: read.fortran
> ### Title: Read Fixed-Format Data in a Fortran-like Style
> ### Aliases: read.fortran
> ### Keywords: file connection
> 
> ### ** Examples
> 
> ff <- tempfile()
> cat(file = ff, "123456", "987654", sep = "\n")
> read.fortran(ff, c("F2.1","F2.0","I2"))
   V1 V2 V3
1 1.2 34 56
2 9.8 76 54
> read.fortran(ff, c("2F1.0","2X","2A1"))
  V1 V2 V3 V4
1  1  2  5  6
2  9  8  5  4
> unlink(ff)
> cat(file = ff, "123456AB", "987654CD", sep = "\n")
> read.fortran(ff, list(c("2F3.1","A2"), c("3I2","2X")))
    V1   V2 V3 V4 V5 V6
1 12.3 45.6 AB 98 76 54
> unlink(ff)
> # Note that the first number is read differently than Fortran would
> # read it:
> cat(file = ff, "12.3456", "1234567", sep = "\n")
> read.fortran(ff, "F7.4")
            V1
1   0.00123456
2 123.45670000
> unlink(ff)
> 
> 
> 
> cleanEx()
> nameEx("read.fwf")
> ### * read.fwf
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: read.fwf
> ### Title: Read Fixed Width Format Files
> ### Aliases: read.fwf
> ### Keywords: file connection
> 
> ### ** Examples
> 
> ff <- tempfile()
> cat(file = ff, "123456", "987654", sep = "\n")
> read.fwf(ff, widths = c(1,2,3))    #> 1 23 456 \ 9 87 654
  V1 V2  V3
1  1 23 456
2  9 87 654
> read.fwf(ff, widths = c(1,-2,3))   #> 1 456 \ 9 654
  V1  V2
1  1 456
2  9 654
> unlink(ff)
> cat(file = ff, "123", "987654", sep = "\n")
> read.fwf(ff, widths = c(1,0, 2,3))    #> 1 NA 23 NA \ 9 NA 87 654
  V1 V2 V3  V4
1  1 NA 23  NA
2  9 NA 87 654
> unlink(ff)
> cat(file = ff, "123456", "987654", sep = "\n")
> read.fwf(ff, widths = list(c(1,0, 2,3), c(2,2,2))) #> 1 NA 23 456 98 76 54
  V1 V2 V3  V4 V5 V6 V7
1  1 NA 23 456 98 76 54
> unlink(ff)
> 
> 
> 
> cleanEx()
> nameEx("read.socket")
> ### * read.socket
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: read.socket
> ### Title: Read from or Write to a Socket
> ### Aliases: read.socket write.socket
> ### Keywords: misc
> 
> ### ** Examples
> 
> finger <- function(user, host = "localhost", port = 79, print = TRUE)
+ {
+     if (!is.character(user))
+         stop("user name must be a string")
+     user <- paste(user,"\r\n")
+     socket <- make.socket(host, port)
+     on.exit(close.socket(socket))
+     write.socket(socket, user)
+     output <- character(0)
+     repeat{
+         ss <- read.socket(socket)
+         if (ss == "") break
+         output <- paste(output, ss)
+     }
+     close.socket(socket)
+     if (print) cat(output)
+     invisible(output)
+ }
> ## Not run: 
> ##D finger("root")  ## only works if your site provides a finger daemon
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("read.table")
> ### * read.table
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: read.table
> ### Title: Data Input
> ### Aliases: read.table read.csv read.csv2 read.delim read.delim2
> ### Keywords: file connection
> 
> ### ** Examples
> 
> ## using count.fields to handle unknown maximum number of fields
> ## when fill = TRUE
> test1 <- c(1:5, "6,7", "8,9,10")
> tf <- tempfile()
> writeLines(test1, tf)
> 
> read.csv(tf, fill = TRUE) # 1 column
  X1
1  2
2  3
3  4
4  5
5  6
6  7
7  8
8  9
9 10
> ncol <- max(count.fields(tf, sep = ","))
> read.csv(tf, fill = TRUE, header = FALSE,
+          col.names = paste0("V", seq_len(ncol)))
  V1 V2 V3
1  1 NA NA
2  2 NA NA
3  3 NA NA
4  4 NA NA
5  5 NA NA
6  6  7 NA
7  8  9 10
> unlink(tf)
> 
> ## "Inline" data set, using text=
> ## Notice that leading and trailing empty lines are auto-trimmed
> 
> read.table(header = TRUE, text = "
+ a b
+ 1 2
+ 3 4
+ ")
  a b
1 1 2
2 3 4
> 
> 
> 
> cleanEx()
> nameEx("readRegistry")
> ### * readRegistry
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: readRegistry
> ### Title: Read a Windows Registry Hive
> ### Aliases: readRegistry
> ### Keywords: utilities
> 
> ### ** Examples
> ## Not run: 
> ##D ## on a 64-bit R need this to find 32-bit JAGS
> ##D readRegistry("SOFTWARE\\JAGS", maxdepth = 3, view = "32")
> ##D 
> ##D ## See if there is a 64-bit user install
> ##D readRegistry("SOFTWARE\\R-core\\R64", "HCU", maxdepth = 2)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("recover")
> ### * recover
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: recover
> ### Title: Browsing after an Error
> ### Aliases: recover limitedLabels
> ### Keywords: programming debugging
> 
> ### ** Examples
> 
> ## Not run: 
> ##D 
> ##D options(error = recover) # setting the error option
> ##D 
> ##D ### Example of interaction
> ##D 
> ##D > myFit <- lm(y ~ x, data = xy, weights = w)
> ##D Error in lm.wfit(x, y, w, offset = offset, ...) :
> ##D         missing or negative weights not allowed
> ##D 
> ##D Enter a frame number, or 0 to exit
> ##D 1:lm(y ~ x, data = xy, weights = w)
> ##D 2:lm.wfit(x, y, w, offset = offset, ...)
> ##D Selection: 2
> ##D Called from: eval(expr, envir, enclos)
> ##D Browse[1]> objects() # all the objects in this frame
> ##D [1] "method" "n"      "ny"     "offset" "tol"    "w"
> ##D [7] "x"      "y"
> ##D Browse[1]> w
> ##D [1] -0.5013844  1.3112515  0.2939348 -0.8983705 -0.1538642
> ##D [6] -0.9772989  0.7888790 -0.1919154 -0.3026882
> ##D Browse[1]> dump.frames() # save for offline debugging
> ##D Browse[1]> c # exit the browser
> ##D 
> ##D Enter a frame number, or 0 to exit
> ##D 1:lm(y ~ x, data = xy, weights = w)
> ##D 2:lm.wfit(x, y, w, offset = offset, ...)
> ##D Selection: 0 # exit recover
> ##D >
> ##D 
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("relist")
> ### * relist
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: relist
> ### Title: Allow Re-Listing an unlist()ed Object
> ### Aliases: relist relist.default relist.list relist.factor relist.matrix
> ###   as.relistable is.relistable unlist.relistable
> ### Keywords: list manip
> 
> ### ** Examples
> 
>  ipar <- list(mean = c(0, 1), vcov = cbind(c(1, 1), c(1, 0)))
>  initial.param <- as.relistable(ipar)
>  ul <- unlist(initial.param)
>  relist(ul)
$mean
[1] 0 1

$vcov
     [,1] [,2]
[1,]    1    1
[2,]    1    0

attr(,"class")
[1] "relistable" "list"      
>  stopifnot(identical(relist(ul), initial.param))
> 
> 
> 
> cleanEx()
> nameEx("removeSource")
> ### * removeSource
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: removeSource
> ### Title: Remove Stored Source from a Function or Language Object
> ### Aliases: removeSource
> ### Keywords: utility
> 
> ### ** Examples
> 
> ## to make this act independently of the global 'options()' setting:
> op <- options(keep.source = TRUE)
> fn <- function(x) {
+   x + 1 # A comment, kept as part of the source
+ }
> fn
function(x) {
  x + 1 # A comment, kept as part of the source
}
> names(attributes(fn))       # "srcref" (only)
[1] "srcref"
> names(attributes(body(fn))) # "srcref" "srcfile" "wholeSrcref"
[1] "srcref"      "srcfile"     "wholeSrcref"
> f2 <- removeSource(fn)
> f2
function (x) 
{
    x + 1
}
> stopifnot(length(attributes(fn)) > 0,
+           is.null(attributes(f2)),
+           is.null(attributes(body(f2))))
> 
> ## Source attribute of parse()d expressions,
> ##	  have {"srcref", "srcfile", "wholeSrcref"} :
> E  <- parse(text ="a <- x^y  # power")  ; names(attributes(E ))
[1] "srcref"      "srcfile"     "wholeSrcref"
> E. <- removeSource(E)                   ; names(attributes(E.))
NULL
> stopifnot(length(attributes(E ))  > 0,
+           is.null(attributes(E.)))
> options(op) # reset to previous state
> 
> 
> 
> cleanEx()
> nameEx("roman")
> ### * roman
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: roman
> ### Title: Roman Numerals
> ### Aliases: as.roman .romans Ops.roman Summary.roman
> ### Keywords: arith
> 
> ### ** Examples
> 
> ## First five roman 'numbers'.
> (y <- as.roman(1 : 5))
[1] I   II  III IV  V  
> ## Middle one.
> y[3]
[1] III
> ## Current year as a roman number.
> (y <- as.roman(format(Sys.Date(), "%Y")))
[1] MMXXI
> ## Today, and  10, 20, 30, and 100 years ago ...
> y - 10*c(0:3,10)
[1] MMXXI  MMXI   MMI    MCMXCI MCMXXI
> ## Don't show: 
> stopifnot(identical(as.character(as.roman("2016") - 10*c(0:3,10)),
+              c("MMXVI", "MMVI", "MCMXCVI", "MCMLXXXVI", "MCMXVI"))) 
> ## End(Don't show)
> ## mixture of arabic and roman numbers :
> as.roman(c(NA, 1:3, "", strrep("I", 1:6))) # + NA with a warning for "IIIIII"
Warning in .roman2numeric(x[!dig.x]) : invalid roman numeral: IIIIII
 [1] <NA> I    II   III  <NA> I    II   III  IV   V    <NA>
> cc <- c(NA, 1:3, strrep("I", 0:5))
> (rc <- as.roman(cc)) # two NAs: 0 is not "roman"
 [1] <NA> I    II   III  <NA> I    II   III  IV   V   
> (ic <- as.integer(rc)) # works automatically [without an explicit method]
 [1] NA  1  2  3 NA  1  2  3  4  5
> rNA <- as.roman(NA)
> ## simple consistency checks -- arithmetic when result is in  {1,2,..,3899} :
> stopifnot(identical(rc, as.roman(rc)), # as.roman(.) is "idempotent"
+           identical(rc + rc + (3*rc), rc*5),
+           identical(ic, c(NA, 1:3, NA, 1:5)),
+           identical(as.integer(5*rc), 5L*ic),
+           identical(as.numeric(rc), as.numeric(ic)),
+           identical(rc[1], rNA),
+           identical(as.roman(0), rNA),
+           identical(as.roman(NA_character_), rNA),
+           identical(as.list(rc), as.list(ic)))
> ## Non-Arithmetic 'Ops' :
> stopifnot(exprs = {
+         # Comparisons :
+         identical(ic < 1:5, rc < 1:5)
+         identical(ic < 1:5, rc < as.roman(1:5))
+         # Logic  [integers |-> logical] :
+         identical(rc & TRUE , ic & TRUE)
+         identical(rc & FALSE, ic & FALSE)
+         identical(rc | FALSE, ic | FALSE)
+         identical(rc | NA   , ic | NA)
+ })
> ## 'Summary' group functions (and comparison):
> (rc. <- rc[!is.na(rc)])
[1] I   II  III I   II  III IV  V  
> stopifnot(exprs = {
+         identical(min(rc), as.roman(NA))
+         identical(min(rc, na.rm=TRUE),
+          as.roman(min(ic, na.rm=TRUE)))
+         identical(range(rc.),
+          as.roman(range(as.integer(rc.))))
+         identical(sum (rc, na.rm=TRUE), as.roman("XXI"))
+         identical(format(prod(rc, na.rm=TRUE)), "DCCXX")
+         format(prod(rc.)) == "DCCXX"
+ })
> 
> 
> 
> cleanEx()
> nameEx("rtags")
> ### * rtags
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rtags
> ### Title: An Etags-like Tagging Utility for R
> ### Aliases: rtags
> ### Keywords: programming utilities
> 
> ### ** Examples
> 
> 
> ## Not run: 
> ##D rtags("/path/to/src/repository",
> ##D       pattern = "[.]*\\.[RrSs]$",
> ##D       keep.re = "/R/",
> ##D       verbose = TRUE,
> ##D       ofile = "TAGS",
> ##D       append = FALSE,
> ##D       recursive = TRUE)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("savehistory")
> ### * savehistory
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: savehistory
> ### Title: Load or Save or Display the Commands History
> ### Aliases: loadhistory savehistory history timestamp
> ### Keywords: utilities
> 
> ### ** Examples
> ## Not run: 
> ##D ## Save the history in the home directory: note that it is not
> ##D ## (by default) read from there but from the current directory
> ##D .Last <- function()
> ##D     if(interactive()) try(savehistory("~/.Rhistory"))
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("select.list")
> ### * select.list
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: select.list
> ### Title: Select Items from a List
> ### Aliases: select.list
> ### Keywords: utilities
> 
> ### ** Examples
> ## Not run: 
> ##D select.list(sort(.packages(all.available = TRUE)))
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("sessionInfo")
> ### * sessionInfo
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sessionInfo
> ### Title: Collect Information About the Current R Session
> ### Aliases: sessionInfo osVersion toLatex.sessionInfo print.sessionInfo
> ### Keywords: misc
> 
> ### ** Examples
> 
> 
> cleanEx()
> nameEx("setRepositories")
> ### * setRepositories
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: setRepositories
> ### Title: Select Package Repositories
> ### Aliases: setRepositories
> ### Keywords: utilities
> 
> ### ** Examples
> ## Not run: 
> ##D setRepositories(addURLs =
> ##D                 c(CRANxtras = "http://www.stats.ox.ac.uk/pub/RWin"))
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("setWindowTitle")
> ### * setWindowTitle
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: setWindowTitle
> ### Title: Set the Window Title or the Statusbar of the RGui in Windows
> ### Aliases: setWindowTitle getWindowTitle getIdentification setStatusBar
> ### Keywords: utilities
> 
> ### ** Examples
> 
> if(.Platform$OS.type == "windows") withAutoprint({
+ ## show the current working directory in the title, saving the old one
+ oldtitle <- setWindowTitle(getwd())
+ Sys.sleep(0.5)
+ ## reset the title
+ setWindowTitle("")
+ Sys.sleep(0.5)
+ ## restore the original title
+ setWindowTitle(title = oldtitle)
+ })
> 
> 
> 
> cleanEx()
> nameEx("shortPathName")
> ### * shortPathName
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: shortPathName
> ### Title: Express File Paths in Short Form on Windows
> ### Aliases: shortPathName
> ### Keywords: utilities
> 
> ### ** Examples
> 
> if(.Platform$OS.type == "windows") withAutoprint({
+ 
+ ## Don't show: 
+   cat(shortPathName(R.home()), sep = "\n")
+ ## End(Don't show)
+ })
> 
> 
> 
> cleanEx()
> nameEx("sourceutils")
> ### * sourceutils
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sourceutils
> ### Title: Source Reference Utilities
> ### Aliases: getSrcFilename getSrcDirectory getSrcref getSrcLocation
> ### Keywords: utilities
> 
> ### ** Examples
> 
> fn <- function(x) {
+   x + 1 # A comment, kept as part of the source
+ }			
> 
> # Show the temporary file directory
> # where the example was saved
> 
> getSrcDirectory(fn)
character(0)
> getSrcLocation(fn, "line")
NULL
> 
> 
> 
> cleanEx()
> nameEx("stack")
> ### * stack
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: stack
> ### Title: Stack or Unstack Vectors from a Data Frame or List
> ### Aliases: stack stack.default stack.data.frame unstack unstack.default
> ###   unstack.data.frame
> ### Keywords: manip
> 
> ### ** Examples
> 
> require(stats)
> formula(PlantGrowth)         # check the default formula
weight ~ group
> pg <- unstack(PlantGrowth)   # unstack according to this formula
> pg
   ctrl trt1 trt2
1  4.17 4.81 6.31
2  5.58 4.17 5.12
3  5.18 4.41 5.54
4  6.11 3.59 5.50
5  4.50 5.87 5.37
6  4.61 3.83 5.29
7  5.17 6.03 4.92
8  4.53 4.89 6.15
9  5.33 4.32 5.80
10 5.14 4.69 5.26
> stack(pg)                    # now put it back together
   values  ind
1    4.17 ctrl
2    5.58 ctrl
3    5.18 ctrl
4    6.11 ctrl
5    4.50 ctrl
6    4.61 ctrl
7    5.17 ctrl
8    4.53 ctrl
9    5.33 ctrl
10   5.14 ctrl
11   4.81 trt1
12   4.17 trt1
13   4.41 trt1
14   3.59 trt1
15   5.87 trt1
16   3.83 trt1
17   6.03 trt1
18   4.89 trt1
19   4.32 trt1
20   4.69 trt1
21   6.31 trt2
22   5.12 trt2
23   5.54 trt2
24   5.50 trt2
25   5.37 trt2
26   5.29 trt2
27   4.92 trt2
28   6.15 trt2
29   5.80 trt2
30   5.26 trt2
> stack(pg, select = -ctrl)    # omitting one vector
   values  ind
1    4.81 trt1
2    4.17 trt1
3    4.41 trt1
4    3.59 trt1
5    5.87 trt1
6    3.83 trt1
7    6.03 trt1
8    4.89 trt1
9    4.32 trt1
10   4.69 trt1
11   6.31 trt2
12   5.12 trt2
13   5.54 trt2
14   5.50 trt2
15   5.37 trt2
16   5.29 trt2
17   4.92 trt2
18   6.15 trt2
19   5.80 trt2
20   5.26 trt2
> 
> 
> 
> cleanEx()
> nameEx("str")
> ### * str
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: str
> ### Title: Compactly Display the Structure of an Arbitrary R Object
> ### Aliases: str str.default str.data.frame strOptions
> ### Keywords: print documentation utilities
> 
> ### ** Examples
> 
> require(stats); require(grDevices); require(graphics)
> ## The following examples show some of 'str' capabilities
> str(1:12)
 int [1:12] 1 2 3 4 5 6 7 8 9 10 ...
> str(ls)
function (name, pos = -1L, envir = as.environment(pos), all.names = FALSE, 
    pattern, sorted = TRUE)  
> str(args) #- more useful than  args(args) !
function (name)  
> str(freeny)
'data.frame':	39 obs. of  5 variables:
 $ y                    : Time-Series  from 1962 to 1972: 8.79 8.79 8.81 8.81 8.91 ...
 $ lag.quarterly.revenue: num  8.8 8.79 8.79 8.81 8.81 ...
 $ price.index          : num  4.71 4.7 4.69 4.69 4.64 ...
 $ income.level         : num  5.82 5.83 5.83 5.84 5.85 ...
 $ market.potential     : num  13 13 13 13 13 ...
> str(str)
function (object, ...)  
> str(.Machine, digits.d = 20) # extra digits for identification of binary numbers
List of 28
 $ double.eps               : num 2.2204460492503130808e-16
 $ double.neg.eps           : num 1.1102230246251565404e-16
 $ double.xmin              : num 2.2250738585072013831e-308
 $ double.xmax              : num 1.7976931348623157081e+308
 $ double.base              : int 2
 $ double.digits            : int 53
 $ double.rounding          : int 5
 $ double.guard             : int 0
 $ double.ulp.digits        : int -52
 $ double.neg.ulp.digits    : int -53
 $ double.exponent          : int 11
 $ double.min.exp           : int -1022
 $ double.max.exp           : int 1024
 $ integer.max              : int 2147483647
 $ sizeof.long              : int 8
 $ sizeof.longlong          : int 8
 $ sizeof.longdouble        : int 16
 $ sizeof.pointer           : int 8
 $ longdouble.eps           : num 1.084202172485504434e-19
 $ longdouble.neg.eps       : num 5.42101086242752217e-20
 $ longdouble.digits        : int 64
 $ longdouble.rounding      : int 5
 $ longdouble.guard         : int 0
 $ longdouble.ulp.digits    : int -63
 $ longdouble.neg.ulp.digits: int -64
 $ longdouble.exponent      : int 15
 $ longdouble.min.exp       : int -16382
 $ longdouble.max.exp       : int 16384
> str( lsfit(1:9, 1:9))
List of 4
 $ coefficients: Named num [1:2] 1.11e-15 1.00
  ..- attr(*, "names")= chr [1:2] "Intercept" "X"
 $ residuals   : num [1:9] -7.86e-16 1.44e-15 -2.09e-16 -1.96e-16 -1.69e-16 ...
 $ intercept   : logi TRUE
 $ qr          :List of 6
  ..$ qt   : num [1:9] -1.50e+01 7.75 -1.81e-16 4.17e-32 1.95e-16 ...
  ..$ qr   : num [1:9, 1:2] -3 0.333 0.333 0.333 0.333 ...
  .. ..- attr(*, "dimnames")=List of 2
  .. .. ..$ : NULL
  .. .. ..$ : chr [1:2] "Intercept" "X"
  ..$ qraux: num [1:2] 1.33 1.26
  ..$ rank : int 2
  ..$ pivot: int [1:2] 1 2
  ..$ tol  : num 1e-07
  ..- attr(*, "class")= chr "qr"
> str( lsfit(1:9, 1:9), max.level = 1)
List of 4
 $ coefficients: Named num [1:2] 1.11e-15 1.00
  ..- attr(*, "names")= chr [1:2] "Intercept" "X"
 $ residuals   : num [1:9] -7.86e-16 1.44e-15 -2.09e-16 -1.96e-16 -1.69e-16 ...
 $ intercept   : logi TRUE
 $ qr          :List of 6
  ..- attr(*, "class")= chr "qr"
> str( lsfit(1:9, 1:9), width = 60, strict.width = "cut")
List of 4
 $ coefficients: Named num [1:2] 1.11e-15 1.00
  ..- attr(*, "names")= chr [1:2] "Intercept" "X"
 $ residuals   : num [1:9] -7.86e-16 1.44e-15 -2.09e-16 -1..
 $ intercept   : logi TRUE
 $ qr          :List of 6
  ..$ qt   : num [1:9] -1.50e+01 7.75 -1.81e-16 4.17e-32 1..
  ..$ qr   : num [1:9, 1:2] -3 0.333 0.333 0.333 0.333 ...
  .. ..- attr(*, "dimnames")=List of 2
  .. .. ..$ : NULL
  .. .. ..$ : chr [1:2] "Intercept" "X"
  ..$ qraux: num [1:2] 1.33 1.26
  ..$ rank : int 2
  ..$ pivot: int [1:2] 1 2
  ..$ tol  : num 1e-07
  ..- attr(*, "class")= chr "qr"
> str( lsfit(1:9, 1:9), width = 60, strict.width = "wrap")
List of 4
$ coefficients: Named num [1:2] 1.11e-15 1.00
..- attr(*, "names")= chr [1:2] "Intercept" "X"
$ residuals : num [1:9] -7.86e-16 1.44e-15 -2.09e-16
   -1.96e-16 -1.69e-16 ...
$ intercept : logi TRUE
$ qr :List of 6
..$ qt : num [1:9] -1.50e+01 7.75 -1.81e-16 4.17e-32
   1.95e-16 ...
..$ qr : num [1:9, 1:2] -3 0.333 0.333 0.333 0.333 ...
.. ..- attr(*, "dimnames")=List of 2
.. .. ..$ : NULL
.. .. ..$ : chr [1:2] "Intercept" "X"
..$ qraux: num [1:2] 1.33 1.26
..$ rank : int 2
..$ pivot: int [1:2] 1 2
..$ tol : num 1e-07
..- attr(*, "class")= chr "qr"
> op <- options(); str(op)   # save first;
List of 67
 $ add.smooth              : logi TRUE
 $ ambiguousMethodSelection:function (cond)  
 $ bitmapType              : chr "cairo"
 $ browser                 : chr "xdg-open"
 $ browserNLdisabled       : logi FALSE
 $ CBoundsCheck            : logi FALSE
 $ check.bounds            : logi FALSE
 $ citation.bibtex.max     : int 1
 $ continue                : chr "+ "
 $ contrasts               : Named chr [1:2] "contr.treatment" "contr.poly"
  ..- attr(*, "names")= chr [1:2] "unordered" "ordered"
 $ defaultPackages         : chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
 $ demo.ask                : chr "default"
 $ deparse.cutoff          : int 60
 $ device                  :function (file = if (onefile) "Rplots.pdf" else "Rplot%03d.pdf", width, 
    height, onefile, family, title, fonts, version, paper, encoding, bg, 
    fg, pointsize, pagecentre, colormodel, useDingbats, useKerning, fillOddEven, 
    compress)  
 $ device.ask.default      : logi FALSE
 $ digits                  : int 7
 $ dvipscmd                : chr "dvips"
 $ echo                    : logi TRUE
 $ editor                  : chr "vi"
 $ encoding                : chr "native.enc"
 $ example.ask             : chr "default"
 $ expressions             : int 5000
 $ help.search.types       : chr [1:3] "vignette" "demo" "help"
 $ help.try.all.packages   : logi FALSE
 $ HTTPUserAgent           : chr "R (4.0.3 x86_64-pc-linux-gnu x86_64 linux-gnu)"
 $ internet.info           : int 2
 $ keep.parse.data         : logi TRUE
 $ keep.parse.data.pkgs    : logi FALSE
 $ keep.source             : logi FALSE
 $ keep.source.pkgs        : logi FALSE
 $ locatorBell             : logi TRUE
 $ mailer                  : chr "mailto"
 $ matprod                 : chr "default"
 $ max.print               : int 99999
 $ menu.graphics           : logi TRUE
 $ na.action               : chr "na.omit"
 $ nwarnings               : int 50
 $ OutDec                  : chr "."
 $ pager                   : chr "/usr/local/lib/R/bin/pager"
 $ papersize               : chr "letter"
 $ PCRE_limit_recursion    : logi NA
 $ PCRE_study              : logi FALSE
 $ PCRE_use_JIT            : logi TRUE
 $ pdfviewer               : chr "/usr/bin/xdg-open"
 $ pkgType                 : chr "source"
 $ printcmd                : chr "/usr/bin/lpr"
 $ prompt                  : chr "> "
 $ repos                   : Named chr "@CRAN@"
  ..- attr(*, "names")= chr "CRAN"
 $ rl_word_breaks          : chr " \t\n\"\\'`><=%;,|&{()}"
 $ scipen                  : num 0
 $ show.coef.Pvalues       : logi TRUE
 $ show.error.messages     : logi TRUE
 $ show.signif.stars       : logi TRUE
 $ showErrorCalls          : logi TRUE
 $ str                     :List of 7
  ..$ strict.width     : chr "no"
  ..$ digits.d         : int 3
  ..$ vec.len          : int 4
  ..$ list.len         : int 99
  ..$ deparse.lines    : NULL
  ..$ drop.deparse.attr: logi TRUE
  ..$ formatNum        :function (x, ...)  
 $ str.dendrogram.last     : chr "`"
 $ stringsAsFactors        : logi FALSE
 $ texi2dvi                : chr "/usr/bin/texi2dvi"
 $ timeout                 : int 60
 $ ts.eps                  : num 1e-05
 $ ts.S.compat             : logi FALSE
 $ unzip                   : chr "/usr/bin/unzip"
 $ useFancyQuotes          : logi TRUE
 $ verbose                 : logi FALSE
 $ warn                    : int 1
 $ warning.length          : int 1000
 $ width                   : int 80
>                            # otherwise internal options() is used.
> need.dev <-
+   !exists(".Device") || is.null(.Device) || .Device == "null device"
> { if(need.dev) postscript()
+   str(par())
+   if(need.dev) graphics.off()
+ }
List of 72
 $ xlog     : logi FALSE
 $ ylog     : logi FALSE
 $ adj      : num 0.5
 $ ann      : logi TRUE
 $ ask      : logi FALSE
 $ bg       : chr "transparent"
 $ bty      : chr "o"
 $ cex      : num 1
 $ cex.axis : num 1
 $ cex.lab  : num 1
 $ cex.main : num 1.2
 $ cex.sub  : num 1
 $ cin      : num [1:2] 0.15 0.2
 $ col      : chr "black"
 $ col.axis : chr "black"
 $ col.lab  : chr "black"
 $ col.main : chr "black"
 $ col.sub  : chr "black"
 $ cra      : num [1:2] 10.8 14.4
 $ crt      : num 0
 $ csi      : num 0.2
 $ cxy      : num [1:2] 0.837 3.642
 $ din      : num [1:2] 7 7
 $ err      : int 0
 $ family   : chr ""
 $ fg       : chr "black"
 $ fig      : num [1:4] 0 1 0 1
 $ fin      : num [1:2] 7 7
 $ font     : int 1
 $ font.axis: int 1
 $ font.lab : int 1
 $ font.main: int 2
 $ font.sub : int 1
 $ lab      : int [1:3] 5 5 7
 $ las      : int 0
 $ lend     : chr "round"
 $ lheight  : num 1
 $ ljoin    : chr "round"
 $ lmitre   : num 10
 $ lty      : chr "solid"
 $ lwd      : num 1
 $ mai      : num [1:4] 1.02 0.82 0.82 0.42
 $ mar      : num [1:4] 5.1 4.1 4.1 2.1
 $ mex      : num 1
 $ mfcol    : int [1:2] 1 1
 $ mfg      : int [1:4] 1 1 1 1
 $ mfrow    : int [1:2] 1 1
 $ mgp      : num [1:3] 3 1 0
 $ mkh      : num 0.001
 $ new      : logi FALSE
 $ oma      : num [1:4] 0 0 0 0
 $ omd      : num [1:4] 0 1 0 1
 $ omi      : num [1:4] 0 0 0 0
 $ page     : logi TRUE
 $ pch      : int 1
 $ pin      : num [1:2] 5.76 5.16
 $ plt      : num [1:4] 0.117 0.94 0.146 0.883
 $ ps       : int 12
 $ pty      : chr "m"
 $ smo      : num 1
 $ srt      : num 0
 $ tck      : num NA
 $ tcl      : num -0.5
 $ usr      : num [1:4] 1943.81 1975.94 -3.48 90.48
 $ xaxp     : num [1:3] 1945 1975 6
 $ xaxs     : chr "r"
 $ xaxt     : chr "s"
 $ xpd      : logi FALSE
 $ yaxp     : num [1:3] 0 80 4
 $ yaxs     : chr "r"
 $ yaxt     : chr "s"
 $ ylbias   : num 0.2
> ch <- letters[1:12]; is.na(ch) <- 3:5
> str(ch) # character NA's
 chr [1:12] "a" "b" NA NA NA "f" "g" "h" "i" "j" "k" "l"
> 
> str(list(a = "A", L = as.list(1:100)), list.len = 9)
List of 2
 $ a: chr "A"
 $ L:List of 100
  ..$ : int 1
  ..$ : int 2
  ..$ : int 3
  ..$ : int 4
  ..$ : int 5
  ..$ : int 6
  ..$ : int 7
  ..$ : int 8
  ..$ : int 9
  .. [list output truncated]
> ##                                     ------------
> ## " .. [list output truncated] "
> 
> ## Long strings,   'nchar.max'; 'strict.width' :
> nchar(longch <- paste(rep(letters,100), collapse = ""))
[1] 2600
> str(longch)
 chr "abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefg"| __truncated__
> str(longch, nchar.max = 52)
 chr "abcdefghijklmnopqrstuvwxyzabcdefghi"| __truncated__
> str(longch, strict.width = "wrap")
chr
   "abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstu"..
   __truncated__
> 
> ## Multibyte characters in strings (in multibyte locales):
> oloc <- Sys.getlocale("LC_CTYPE")
> mbyte.lc <- if(.Platform$OS.type == "windows")
+  "English_United States.28605" else "en_GB.UTF-8"
> try(Sys.setlocale("LC_CTYPE", mbyte.lc))
Warning in Sys.setlocale("LC_CTYPE", mbyte.lc) :
  OS reports request to set locale to "en_GB.UTF-8" cannot be honored
[1] ""
> ## Truncation behavior (<-> correct width measurement) for "long" non-ASCII:
> idx <- c(65313:65338, 65345:65350)
> fwch <- intToUtf8(idx) # full width character string: each has width 2
> ch <- strtrim(paste(LETTERS, collapse="._"), 64)
> (ncc <- c(c.ch = nchar(ch),   w.ch = nchar(ch,   "w"),
+           c.fw = nchar(fwch), w.fw = nchar(fwch, "w")))
c.ch w.ch c.fw w.fw 
  64   64   32   64 
> stopifnot(unname(ncc) == c(64,64, 32, 64))
> ## nchar.max: 1st line needs an increase of  2  in order to see  1  (in UTF-8!):
> invisible(lapply(60:66, function(N) str(fwch, nchar.max = N)))
 chr "ＡＢＣＤＥＦＧＨＩＪＫＬＭＮＯＰＱＲＳＴＵ"| __truncated__
 chr "ＡＢＣＤＥＦＧＨＩＪＫＬＭＮＯＰＱＲＳＴＵＶ"| __truncated__
 chr "ＡＢＣＤＥＦＧＨＩＪＫＬＭＮＯＰＱＲＳＴＵＶ"| __truncated__
 chr "ＡＢＣＤＥＦＧＨＩＪＫＬＭＮＯＰＱＲＳＴＵＶＷ"| __truncated__
 chr "ＡＢＣＤＥＦＧＨＩＪＫＬＭＮＯＰＱＲＳＴＵＶＷ"| __truncated__
 chr "ＡＢＣＤＥＦＧＨＩＪＫＬＭＮＯＰＱＲＳＴＵＶＷＸ"| __truncated__
 chr "ＡＢＣＤＥＦＧＨＩＪＫＬＭＮＯＰＱＲＳＴＵＶＷＸＹＺａｂｃｄｅｆ"
> invisible(lapply(60:66, function(N) str( ch , nchar.max = N))) # "1 is 1" here
 chr "A._B._C._D._E._F._G._H._I._J._K._L._M._N._O"| __truncated__
 chr "A._B._C._D._E._F._G._H._I._J._K._L._M._N._O."| __truncated__
 chr "A._B._C._D._E._F._G._H._I._J._K._L._M._N._O._"| __truncated__
 chr "A._B._C._D._E._F._G._H._I._J._K._L._M._N._O._P"| __truncated__
 chr "A._B._C._D._E._F._G._H._I._J._K._L._M._N._O._P."| __truncated__
 chr "A._B._C._D._E._F._G._H._I._J._K._L._M._N._O._P._"| __truncated__
 chr "A._B._C._D._E._F._G._H._I._J._K._L._M._N._O._P._Q._R._S._T._U._V"
> ## revert locale to previous:
> Sys.setlocale("LC_CTYPE", oloc)
[1] "en_US.UTF-8"
> 
> 
> ## Settings for narrow transcript :
> op <- options(width = 60,
+               str = strOptions(strict.width = "wrap"))
> str(lsfit(1:9,1:9))
List of 4
$ coefficients: Named num [1:2] 1.11e-15 1.00
..- attr(*, "names")= chr [1:2] "Intercept" "X"
$ residuals : num [1:9] -7.86e-16 1.44e-15 -2.09e-16
   -1.96e-16 -1.69e-16 ...
$ intercept : logi TRUE
$ qr :List of 6
..$ qt : num [1:9] -1.50e+01 7.75 -1.81e-16 4.17e-32
   1.95e-16 ...
..$ qr : num [1:9, 1:2] -3 0.333 0.333 0.333 0.333 ...
.. ..- attr(*, "dimnames")=List of 2
.. .. ..$ : NULL
.. .. ..$ : chr [1:2] "Intercept" "X"
..$ qraux: num [1:2] 1.33 1.26
..$ rank : int 2
..$ pivot: int [1:2] 1 2
..$ tol : num 1e-07
..- attr(*, "class")= chr "qr"
> str(options())
List of 67
$ add.smooth : logi TRUE
$ ambiguousMethodSelection:function (cond)
$ bitmapType : chr "cairo"
$ browser : chr "xdg-open"
$ browserNLdisabled : logi FALSE
$ CBoundsCheck : logi FALSE
$ check.bounds : logi FALSE
$ citation.bibtex.max : int 1
$ continue : chr "+ "
$ contrasts : Named chr [1:2] "contr.treatment"
   "contr.poly"
..- attr(*, "names")= chr [1:2] "unordered" "ordered"
$ defaultPackages : chr [1:6] "datasets" "utils"
   "grDevices" "graphics" ...
$ demo.ask : chr "default"
$ deparse.cutoff : int 60
$ device :function (file = if (onefile) "Rplots.pdf" else
   "Rplot%03d.pdf",
width, height, onefile, family, title, fonts, version,
paper, encoding, bg, fg, pointsize, pagecentre,
colormodel, useDingbats, useKerning, fillOddEven,
compress)
$ device.ask.default : logi FALSE
$ digits : int 7
$ dvipscmd : chr "dvips"
$ echo : logi TRUE
$ editor : chr "vi"
$ encoding : chr "native.enc"
$ example.ask : chr "default"
$ expressions : int 5000
$ help.search.types : chr [1:3] "vignette" "demo" "help"
$ help.try.all.packages : logi FALSE
$ HTTPUserAgent : chr "R (4.0.3 x86_64-pc-linux-gnu x86_64
   linux-gnu)"
$ internet.info : int 2
$ keep.parse.data : logi TRUE
$ keep.parse.data.pkgs : logi FALSE
$ keep.source : logi FALSE
$ keep.source.pkgs : logi FALSE
$ locatorBell : logi TRUE
$ mailer : chr "mailto"
$ matprod : chr "default"
$ max.print : int 99999
$ menu.graphics : logi TRUE
$ na.action : chr "na.omit"
$ nwarnings : int 50
$ OutDec : chr "."
$ pager : chr "/usr/local/lib/R/bin/pager"
$ papersize : chr "letter"
$ PCRE_limit_recursion : logi NA
$ PCRE_study : logi FALSE
$ PCRE_use_JIT : logi TRUE
$ pdfviewer : chr "/usr/bin/xdg-open"
$ pkgType : chr "source"
$ printcmd : chr "/usr/bin/lpr"
$ prompt : chr "> "
$ repos : Named chr "@CRAN@"
..- attr(*, "names")= chr "CRAN"
$ rl_word_breaks : chr " \t\n\"\\'`><=%;,|&{()}"
$ scipen : num 0
$ show.coef.Pvalues : logi TRUE
$ show.error.messages : logi TRUE
$ show.signif.stars : logi TRUE
$ showErrorCalls : logi TRUE
$ str :List of 7
..$ strict.width : chr "wrap"
..$ digits.d : int 3
..$ vec.len : int 4
..$ list.len : int 99
..$ deparse.lines : NULL
..$ drop.deparse.attr: logi TRUE
..$ formatNum :function (x, ...)
$ str.dendrogram.last : chr "`"
$ stringsAsFactors : logi FALSE
$ texi2dvi : chr "/usr/bin/texi2dvi"
$ timeout : int 60
$ ts.eps : num 1e-05
$ ts.S.compat : logi FALSE
$ unzip : chr "/usr/bin/unzip"
$ useFancyQuotes : logi TRUE
$ verbose : logi FALSE
$ warn : int 1
$ warning.length : int 1000
$ width : int 60
> ## reset to previous:
> options(op)
> 
> 
> ## Don't show: 
>  ##-- Some "crazy" objects
>  str(array(1:5, dim = 20))
 int [1:20(1d)] 1 2 3 4 5 1 2 3 4 5 ...
>  str(factor(character(0)))
 Factor w/ 0 levels: 
>  str(as.data.frame(NULL))
'data.frame':	0 obs. of  0 variables
> ## End(Don't show)
> str(quote( { A+B; list(C, D) } ))
 language {  A + B; list(C, D) }
> 
> ## Don't show: 
> had.stats4 <- "package:stats4" %in% search()
> if(!had.stats4)
+    rs <- 
+ ## End(Don't show)
+ ## S4 classes :
+ require(stats4)
Loading required package: stats4
> x <- 0:10; y <- c(26, 17, 13, 12, 20, 5, 9, 8, 5, 4, 8)
> ll <- function(ymax = 15, xh = 6)
+       -sum(dpois(y, lambda=ymax/(1+x/xh), log=TRUE))
> fit <- mle(ll)
Warning in dpois(y, lambda = ymax/(1 + x/xh), log = TRUE) :
  NaNs produced
> str(fit)
Formal class 'mle' [package "stats4"] with 10 slots
  ..@ call     : language mle(minuslogl = ll)
  ..@ coef     : Named num [1:2] 24.99 3.06
  .. ..- attr(*, "names")= chr [1:2] "ymax" "xh"
  ..@ fullcoef : Named num [1:2] 24.99 3.06
  .. ..- attr(*, "names")= chr [1:2] "ymax" "xh"
  ..@ fixed    : Named num [1:2] NA NA
  .. ..- attr(*, "names")= chr [1:2] "ymax" "xh"
  ..@ vcov     : num [1:2, 1:2] 17.85 -3.72 -3.72 1.07
  .. ..- attr(*, "dimnames")=List of 2
  .. .. ..$ : chr [1:2] "ymax" "xh"
  .. .. ..$ : chr [1:2] "ymax" "xh"
  ..@ min      : num 28.6
  ..@ details  :List of 6
  .. ..$ par        : Named num [1:2] 24.99 3.06
  .. .. ..- attr(*, "names")= chr [1:2] "ymax" "xh"
  .. ..$ value      : num 28.6
  .. ..$ counts     : Named int [1:2] 25 18
  .. .. ..- attr(*, "names")= chr [1:2] "function" "gradient"
  .. ..$ convergence: int 0
  .. ..$ message    : NULL
  .. ..$ hessian    : num [1:2, 1:2] 0.203 0.706 0.706 3.388
  .. .. ..- attr(*, "dimnames")=List of 2
  .. .. .. ..$ : chr [1:2] "ymax" "xh"
  .. .. .. ..$ : chr [1:2] "ymax" "xh"
  ..@ minuslogl:function (ymax = 15, xh = 6)  
  ..@ nobs     : int NA
  ..@ method   : chr "BFGS"
> ## Don't show: 
> if(!had.stats4 && rs) detach("package:stats4")
> ## End(Don't show)
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("strcapture")
> ### * strcapture
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: strcapture
> ### Title: Capture String Tokens into a data.frame
> ### Aliases: strcapture
> ### Keywords: utilities
> 
> ### ** Examples
> 
> x <- "chr1:1-1000"
> pattern <- "(.*?):([[:digit:]]+)-([[:digit:]]+)"
> proto <- data.frame(chr=character(), start=integer(), end=integer())
> strcapture(pattern, x, proto)
   chr start  end
1 chr1     1 1000
> 
> 
> 
> cleanEx()
> nameEx("summaryRprof")
> ### * summaryRprof
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: summaryRprof
> ### Title: Summarise Output of R Sampling Profiler
> ### Aliases: summaryRprof
> ### Keywords: utilities
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ## Rprof() is not available on all platforms
> ##D Rprof(tmp <- tempfile())
> ##D example(glm)
> ##D Rprof()
> ##D summaryRprof(tmp)
> ##D unlink(tmp)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("txtProgressBar")
> ### * txtProgressBar
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: txtProgressBar
> ### Title: Text Progress Bar
> ### Aliases: txtProgressBar getTxtProgressBar setTxtProgressBar
> ###   close.txtProgressBar
> ### Keywords: utilities
> 
> ### ** Examples
> 
> 
> cleanEx()
> nameEx("type.convert")
> ### * type.convert
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: type.convert
> ### Title: Convert Data to Appropriate Type
> ### Aliases: type.convert type.convert.default type.convert.list
> ###   type.convert.data.frame
> ### Keywords: manip
> 
> ### ** Examples
> 
> ## Numeric to integer
> class(rivers)
[1] "numeric"
> x <- type.convert(rivers)
> class(x)
[1] "integer"
> 
> ## Convert many columns
> auto <- type.convert(mtcars)
> str(mtcars)
'data.frame':	32 obs. of  11 variables:
 $ mpg : num  21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...
 $ cyl : num  6 6 4 6 8 6 8 4 4 6 ...
 $ disp: num  160 160 108 258 360 ...
 $ hp  : num  110 110 93 110 175 105 245 62 95 123 ...
 $ drat: num  3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ...
 $ wt  : num  2.62 2.88 2.32 3.21 3.44 ...
 $ qsec: num  16.5 17 18.6 19.4 17 ...
 $ vs  : num  0 0 1 1 0 1 0 1 1 1 ...
 $ am  : num  1 1 1 0 0 0 0 0 0 0 ...
 $ gear: num  4 4 4 3 3 3 3 4 4 4 ...
 $ carb: num  4 4 1 1 2 1 4 2 2 4 ...
> str(auto)
'data.frame':	32 obs. of  11 variables:
 $ mpg : num  21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...
 $ cyl : int  6 6 4 6 8 6 8 4 4 6 ...
 $ disp: num  160 160 108 258 360 ...
 $ hp  : int  110 110 93 110 175 105 245 62 95 123 ...
 $ drat: num  3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ...
 $ wt  : num  2.62 2.88 2.32 3.21 3.44 ...
 $ qsec: num  16.5 17 18.6 19.4 17 ...
 $ vs  : int  0 0 1 1 0 1 0 1 1 1 ...
 $ am  : int  1 1 1 0 0 0 0 0 0 0 ...
 $ gear: int  4 4 4 3 3 3 3 4 4 4 ...
 $ carb: int  4 4 1 1 2 1 4 2 2 4 ...
> 
> ## Convert matrix
> phones <- type.convert(WorldPhones)
> storage.mode(WorldPhones)
[1] "double"
> storage.mode(phones)
[1] "integer"
> 
> ## Factor or character
> chr <- c("A", "B", "B", "A")
> fac <- factor(c("A", "B", "B", "A"))
> type.convert(chr)               # -> factor
[1] A B B A
Levels: A B
> type.convert(fac)               # -> factor
[1] A B B A
Levels: A B
> type.convert(chr, as.is = TRUE) # -> character
[1] "A" "B" "B" "A"
> type.convert(fac, as.is = TRUE) # -> character
[1] "A" "B" "B" "A"
> 
> 
> 
> cleanEx()
> nameEx("url.show")
> ### * url.show
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: url.show
> ### Title: Display a Text URL
> ### Aliases: url.show
> ### Keywords: file misc
> 
> ### ** Examples
> 
> ## Not run: url.show("http://www.stats.ox.ac.uk/pub/datasets/csb/ch3a.txt")
> 
> 
> 
> cleanEx()
> nameEx("vignette")
> ### * vignette
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: vignette
> ### Title: View, List or Get R Source of Package Vignettes
> ### Aliases: vignette edit.vignette print.vignette vignettes
> ### Keywords: documentation
> 
> ### ** Examples
> 
> ## List vignettes from all *attached* packages
> vignette(all = FALSE)
Vignettes in package ‘utils’:

Sweave                  Sweave User Manual (source, pdf)


Use ‘vignette(all = TRUE)’
to list the vignettes in all *available* packages.

> 
> ## List vignettes from all *installed* packages (can take a long time!):
> vignette(all = TRUE)
Vignettes in package ‘digest’:

sha1                    sha1() versus digest() (source, html)

Vignettes in package ‘dplyr’:

colwise                 colwise (source, html)
compatibility           dplyr compatibility (source, html)
base                    From base R to dplyr (source, html)
grouping                Grouped data (source, html)
dplyr                   Introduction to dplyr (source, html)
programming             Programming with dplyr (source, html)
rowwise                 rowwise (source, html)
two-table               Two-table verbs (source, html)
window-functions        Window functions (source, html)

Vignettes in package ‘fansi’:

sgr-in-rmd              ANSI CSI SGR Sequences in Rmarkdown (source,
                        html)

Vignettes in package ‘glue’:

speed                   Speed of glue (source, html)
transformers            Transformers (source, html)

Vignettes in package ‘grid’:

moveline                Demonstrating move-to and line-to (source, pdf)
displaylist             Display Lists in grid (source, pdf)
interactive             Editing grid Graphics (source, pdf)
frame                   Frames and packing grobs (source, pdf)
grid                    Introduction to grid (source, pdf)
locndimn                Locations versus Dimensions (source, pdf)
sharing                 Modifying multiple grobs simultaneously
                        (source, pdf)
nonfinite               Non-finite values (source, pdf)
saveload                Persistent representations (source, pdf)
rotated                 Rotated Viewports (source, pdf)
grobs                   Working with grid grobs (source, pdf)
viewports               Working with viewports (source, pdf)
plotexample             Writing grid Code (source, pdf)

Vignettes in package ‘highr’:

highr-custom            Customization of the highr package (source,
                        html)
highr-internals         Internals of the highr package (source, html)

Vignettes in package ‘jsonlite’:

json-mapping            A mapping between JSON data and R objects
                        (source, pdf)
json-paging             Combining pages of JSON data with jsonlite
                        (source, html)
json-apis               Fetching JSON data from REST APIs (source,
                        html)
json-aaquickstart       Getting started with JSON and jsonlite (source,
                        html)
json-opencpu            Simple JSON RPC with OpenCPU (source, pdf)

Vignettes in package ‘knitr’:

knitr-html              An R HTML Vignette with knitr (source, html)
knitr-markdown          An R Markdown Vignette with knitr (source,
                        html)
knit_print              Custom Print Methods (source, html)
datatables              Display Tables with the JavaScript Library
                        DataTables (source, html)
knitr-refcard           knitr Reference Card (source, pdf)
knitr-intro             Not an Introduction to knitr (source, html)
docco-classic           R Markdown with the Docco Classic Style
                        (source, html)
docco-linear            R Markdown with the Docco Linear Style (source,
                        html)
knit_expand             Templating with knit_expand() (source, html)

Vignettes in package ‘lifecycle’:

communicate             Communicate lifecycle changes in your functions
                        (source, html)
stages                  Lifecycle stages (source, html)
manage                  Manage lifecycle changes in functions you use
                        (source, html)

Vignettes in package ‘magrittr’:

tradeoffs               Design tradeoffs (source, html)
magrittr                Introducing magrittr (source, html)

Vignettes in package ‘markdown’:

markdown-output         HTML Output from Markdown Examples (source,
                        html)
markdown-examples       Some Markdown Examples (source, html)

Vignettes in package ‘Matrix’:

Intro2Matrix            2nd Introduction to the Matrix Package (source,
                        pdf)
Comparisons             Comparisons of Least Squares calculation speeds
                        (source, pdf)
Design-issues           Design Issues in Matrix package Development
                        (source, pdf)
Introduction            Introduction to the Matrix Package (source,
                        pdf)
sparseModels            Sparse Model Matrices (source, pdf)

Vignettes in package ‘parallel’:

parallel                Package 'parallel' (source, pdf)

Vignettes in package ‘pillar’:

numbers                 Controlling display of numbers (source, html)
extending               Custom formatting (source, html)
printing                Printing a tibble: Control and data flow
                        (source, html)
debugme                 Printing a tibble: Tracking control flow
                        (source, html)
digits                  Significant figures and scientific notation
                        (source, html)

Vignettes in package ‘purrr’:

other-langs             Functional programming in other languages
                        (source, html)

Vignettes in package ‘rmarkdown’:

rmarkdown               Learn R Markdown (source, html)
lua-filters             Lua filters in R Markdown (source, html)

Vignettes in package ‘rpart’:

longintro               Introduction to Rpart (source, pdf)
usercode                User Written Split Functions (source, pdf)

Vignettes in package ‘stringr’:

stringr                 Introduction to stringr (source, html)
regular-expressions     Regular expressions (source, html)

Vignettes in package ‘survival’:

adjcurve                Adjusted Survival Curves (source, pdf)
approximate             Approximating a Cox Model (source, pdf)
concordance             Concordance (source, pdf)
compete                 Multi-state models and competing risks (source,
                        pdf)
multi                   Multi-state survival curves (source, pdf)
other                   Other vignettes (source, pdf)
population              Population contrasts (source, pdf)
tiedtimes               Roundoff error and tied times (source, pdf)
splines                 Splines, plots, and interactions (source, pdf)
survival                The survival package (source, pdf)
timedep                 Using Time Dependent Covariates (source, pdf)
validate                Validation (source, pdf)

Vignettes in package ‘tibble’:

types                   Column data types (source, html)
formats                 Column formats (source, html)
digits                  Comparison with data frames (source, html)
numbers                 Controlling display of numbers (source, html)
extending               Extending tibble (source, html)
invariants              Invariants: Comparing behavior with data frames
                        (source, html)
tibble                  Tibbles (source, html)

Vignettes in package ‘tidyselect’:

tidyselect              Implementing tidyselect interfaces (source,
                        html)
syntax                  Technical description of tidyselect (source,
                        html)

Vignettes in package ‘utf8’:

utf8                    Unicode: Emoji, accents, and international text
                        (source, html)

Vignettes in package ‘utils’:

Sweave                  Sweave User Manual (source, pdf)

Vignettes in package ‘vctrs’:

pillar                  Printing vectors nicely in tibbles (source,
                        html)
type-size               Prototypes and sizes (source, html)
s3-vector               S3 vectors (source, html)
stability               Type and size stability (source, html)

Vignettes in package ‘xfun’:

xfun                    An Introduction to xfun (source, html)

> 
> ## The grid intro vignette -- open it
> ## Not run: vignette("grid") # calling print()
> ## The same (conditional on existence of the vignettte).
> ## Note that 'package = *' is much faster in the case of many installed packages:
> if(!is.null(v1 <- vignette("grid", package="grid"))) {
+ ## Not run: v1 # calling print(.)
+   str(v1)
+   ## Now let us have a closer look at the code
+   
+   
+   
+   
+ ## Not run: edit(v1) # e.g., to send lines ...
+ }# if( has vignette "installed")
List of 7
 $ Package: chr "grid"
 $ Dir    : chr "/usr/local/lib/R/library/grid"
 $ Topic  : chr "grid"
 $ File   : chr "grid.Rnw"
 $ Title  : chr "Introduction to grid"
 $ R      : chr "grid.R"
 $ PDF    : chr "grid.pdf"
 - attr(*, "class")= chr "vignette"
> ## A package can have more than one vignette (package grid has several):
> vignette(package = "grid")
Vignettes in package ‘grid’:

moveline                Demonstrating move-to and line-to (source, pdf)
displaylist             Display Lists in grid (source, pdf)
interactive             Editing grid Graphics (source, pdf)
frame                   Frames and packing grobs (source, pdf)
grid                    Introduction to grid (source, pdf)
locndimn                Locations versus Dimensions (source, pdf)
sharing                 Modifying multiple grobs simultaneously
                        (source, pdf)
nonfinite               Non-finite values (source, pdf)
saveload                Persistent representations (source, pdf)
rotated                 Rotated Viewports (source, pdf)
grobs                   Working with grid grobs (source, pdf)
viewports               Working with viewports (source, pdf)
plotexample             Writing grid Code (source, pdf)

> if(interactive()) {
+    ## vignette("rotated")
+    ## The same, but without searching for it:
+    vignette("rotated", package = "grid")
+ }
> 
> 
> 
> cleanEx()
> nameEx("warnErrList")
> ### * warnErrList
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: warnErrList
> ### Title: Collect and Summarize Errors From List
> ### Aliases: warnErrList
> ### Keywords: error utilities
> 
> ### ** Examples
> 
> ## Regression for each Chick:
> ChWtgrps <- split(ChickWeight, ChickWeight[,"Chick"])
> sapply(ChWtgrps, nrow)# typically 12 obs.
18 16 15 13  9 20 10  8 17 19  4  6 11  3  1 12  2  5 14  7 24 30 22 23 27 28 
 2  7  8 12 12 12 12 11 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 
26 25 29 21 33 37 36 31 39 38 32 40 34 35 44 45 43 41 47 49 46 50 42 48 
12 12 12 12 12 12 12 12 12 12 12 12 12 12 10 12 12 12 12 12 12 12 12 12 
> nlis1 <- lapply(ChWtgrps, function(DAT) tryCatch(error = identity,
+                       lm(weight ~ (Time + I(Time^2)) * Diet, data = DAT)))
> nl1 <- warnErrList(nlis1) #-> warning :
Warning: 50 times caught the same error in `contrasts<-`(`*tmp*`, value = contr.funs[1 + isOF[nn]]): contrasts can be applied only to factors with 2 or more levels
> ## 50 times the same error (as Diet has only one level in each group)
> stopifnot(sapply(nl1, is.null)) ## all errors --> all replaced by NULL
> nlis2 <- lapply(ChWtgrps, function(DAT) tryCatch(error = identity,
+                       lm(weight ~ Time + I(Time^2), data = DAT)))
> nl2 <- warnErrList(nlis2)
> stopifnot(identical(nl2, nlis2)) # because there was *no* error at all
> nlis3 <- lapply(ChWtgrps, function(DAT) tryCatch(error = identity,
+                       lm(weight ~ poly(Time, 3), data = DAT)))
> nl3 <- warnErrList(nlis3) # 1 error caught:
Warning: 1 error caught in poly(Time, 3): 'degree' must be less than number of unique points
> stopifnot(inherits(nlis3[[1]], "error")
+         , identical(nl3[-1], nlis3[-1])
+         , is.null(nl3[[1]])
+ )
> 
> ## With different error messages
> if(requireNamespace("nlme")) { # almost always, as it is recommended
+  data(Soybean, package="nlme")
+  attr(Soybean, "formula") #-> weight ~ Time | Plot  => split by "Plot":
+  L <- lapply(split(Soybean, Soybean[,"Plot"]),
+              function(DD) tryCatch(error = identity,
+                  nls(weight ~ SSlogis(Time, Asym, xmid, scal), data = DD)))
+  Lw <- warnErrList(L)
+ } # if <nlme>
Loading required namespace: nlme
Warning: 2 errors caught in nls(y ~ 1/(1 + exp((xmid - x)/scal)), data = xy, start = list(xmid = aux[[1L]], scal = aux[[2L]]), algorithm = "plinear").  The error messages and their frequencies are

                     number of iterations exceeded maximum of 50 
                                                               1 
step factor 0.000488281 reduced below 'minFactor' of 0.000976562 
                                                               1 
> 
> 
> 
> cleanEx()
> nameEx("winDialog")
> ### * winDialog
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: winDialog
> ### Title: Dialog Boxes under Windows
> ### Aliases: winDialog winDialogString
> ### Keywords: utilities
> 
> ### ** Examples
> 
> ## Not run: winDialog("yesno", "Is it OK to delete file blah")
> 
> 
> 
> cleanEx()
> nameEx("winMenus")
> ### * winMenus
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: winMenus
> ### Title: User Menus under MS Windows (Rgui)
> ### Aliases: winMenuAdd winMenuAddItem winMenuDel winMenuDelItem
> ###   winMenuNames winMenuItems
> ### Keywords: utilities
> 
> ### ** Examples
> ## Not run: 
> ##D winMenuAdd("Testit")
> ##D winMenuAddItem("Testit", "one", "aaaa")
> ##D winMenuAddItem("Testit", "two", "bbbb")
> ##D winMenuAdd("Testit/extras")
> ##D winMenuAddItem("Testit", "-", "")
> ##D winMenuAddItem("Testit", "two", "disable")
> ##D winMenuAddItem("Testit", "three", "cccc")
> ##D winMenuAddItem("Testit/extras", "one more", "ddd")
> ##D winMenuAddItem("Testit/extras", "and another", "eee")
> ##D winMenuAdd("$ConsolePopup/Testit")
> ##D winMenuAddItem("$ConsolePopup/Testit", "six", "fff")
> ##D winMenuNames()
> ##D winMenuItems("Testit")
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("winProgressBar")
> ### * winProgressBar
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: winProgressBar
> ### Title: Progress Bars under MS Windows
> ### Aliases: winProgressBar getWinProgressBar setWinProgressBar
> ###   close.winProgressBar
> ### Keywords: utilities
> 
> ### ** Examples
> 
> 
> cleanEx()
> nameEx("winextras")
> ### * winextras
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: winextras
> ### Title: Get Windows Version
> ### Aliases: win.version
> ### Keywords: utilities
> 
> ### ** Examples
> 
> if(.Platform$OS.type == "windows")
+    print(win.version())
> 
> 
> 
> cleanEx()
> nameEx("write.table")
> ### * write.table
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: write.table
> ### Title: Data Output
> ### Aliases: write.table write.csv write.csv2
> ### Keywords: print file
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ## To write a CSV file for input to Excel one might use
> ##D x <- data.frame(a = I("a \" quote"), b = pi)
> ##D write.table(x, file = "foo.csv", sep = ",", col.names = NA,
> ##D             qmethod = "double")
> ##D ## and to read this file back into R one needs
> ##D read.table("foo.csv", header = TRUE, sep = ",", row.names = 1)
> ##D ## NB: you do need to specify a separator if qmethod = "double".
> ##D 
> ##D ### Alternatively
> ##D write.csv(x, file = "foo.csv")
> ##D read.csv("foo.csv", row.names = 1)
> ##D ## or without row names
> ##D write.csv(x, file = "foo.csv", row.names = FALSE)
> ##D read.csv("foo.csv")
> ##D 
> ##D ## To write a file in Mac Roman for simple use in Mac Excel 2004/8
> ##D write.csv(x, file = "foo.csv", fileEncoding = "macroman")
> ##D ## or for Windows Excel 2007/10
> ##D write.csv(x, file = "foo.csv", fileEncoding = "UTF-16LE")
> ## End(Not run)
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  5.416 0.568 5.767 0.043 0.04 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
